{
  "score": 0.6725,
  "candidate": {
    "program": "import dspy\nfrom typing import List, Tuple, Optional, Any, Dict\nimport pydantic\nimport re\nimport copy\nimport textwrap\nfrom collections import Counter\n\nMATRIX = List[List[int]]\n\nclass TrainingExample(pydantic.BaseModel):\n    input: MATRIX\n    output: MATRIX\n\ndef _strip_code_fences(s: str) -> str:\n    if s is None:\n        return \"\"\n    s = s.strip()\n    # Remove fenced blocks and language markers\n    if s.startswith(\"```\"):\n        s = \"\\n\".join(s.split(\"\\n\")[1:])\n    if s.endswith(\"```\"):\n        s = \"\\n\".join(s.split(\"\\n\")[:-1])\n    s = re.sub(r\"^```[a-zA-Z0-9_+-]*\\s*\", \"\", s.strip())\n    s = re.sub(r\"\\s*```$\", \"\", s.strip())\n    return s.strip()\n\ndef _ensure_transform_code(code: str) -> str:\n    \"\"\"\n    Ensure code contains a def transform(grid): function.\n    If code appears to be just the body, wrap it. Otherwise, return full code as-is.\n    \"\"\"\n    code = _strip_code_fences(code)\n    if \"def transform\" in code:\n        # Keep helpers that may be defined before/after transform.\n        return code\n    # If it's likely just a body (has return or grid indexing), wrap it\n    lines = code.strip().splitlines()\n    body = code.strip()\n    if len(body) == 0:\n        return \"\"\n    if \"return\" in body or \"grid\" in body:\n        wrapped = \"def transform(grid):\\n\" + textwrap.indent(body, \"    \")\n        return wrapped\n    return \"\"\n\ndef _height(grid: MATRIX) -> int:\n    return len(grid)\n\ndef _width(grid: MATRIX) -> int:\n    return len(grid[0]) if grid and isinstance(grid[0], list) else 0\n\ndef _in_bounds(grid: MATRIX, r: int, c: int) -> bool:\n    h, w = _height(grid), _width(grid)\n    return 0 <= r < h and 0 <= c < w\n\ndef _colors(grid: MATRIX) -> List[int]:\n    s = set()\n    for row in grid:\n        for v in row:\n            try:\n                s.add(int(v))\n            except Exception:\n                pass\n    return sorted(list(s))\n\ndef _color_counts(grid: MATRIX) -> Dict[int, int]:\n    cnt = Counter()\n    for row in grid:\n        for v in row:\n            try:\n                cnt[int(v)] += 1\n            except Exception:\n                pass\n    return dict(cnt)\n\ndef _positions_of(grid: MATRIX, color: int) -> List[Tuple[int, int]]:\n    pos = []\n    for r, row in enumerate(grid):\n        for c, v in enumerate(row):\n            if v == color:\n                pos.append((r, c))\n    return pos\n\ndef _bbox_of(grid: MATRIX, colors: Optional[List[int]] = None, nonzero: bool = True) -> Optional[Tuple[int, int, int, int]]:\n    h, w = _height(grid), _width(grid)\n    rs = []\n    if colors is not None:\n        color_set = set(colors)\n        for r in range(h):\n            for c in range(w):\n                if grid[r][c] in color_set:\n                    rs.append((r, c))\n    elif nonzero:\n        for r in range(h):\n            for c in range(w):\n                if grid[r][c] != 0:\n                    rs.append((r, c))\n    else:\n        # if not using nonzero and no colors, bbox of entire grid\n        for r in range(h):\n            for c in range(w):\n                rs.append((r, c))\n    if not rs:\n        return None\n    rmin = min(r for r, _ in rs)\n    rmax = max(r for r, _ in rs)\n    cmin = min(c for _, c in rs)\n    cmax = max(c for _, c in rs)\n    return (rmin, cmin, rmax, cmax)\n\ndef _crop(grid: MATRIX, bbox: Tuple[int, int, int, int]) -> MATRIX:\n    rmin, cmin, rmax, cmax = bbox\n    out = []\n    for r in range(rmin, rmax + 1):\n        row = []\n        for c in range(cmin, cmax + 1):\n            row.append(int(grid[r][c]))\n        out.append(row)\n    return out\n\ndef _transpose(grid: MATRIX) -> MATRIX:\n    h, w = _height(grid), _width(grid)\n    if h == 0 or w == 0:\n        return []\n    return [[int(grid[r][c]) for r in range(h)] for c in range(w)]\n\ndef _new_grid(h: int, w: int, fill: int = 0) -> MATRIX:\n    return [[int(fill) for _ in range(w)] for _ in range(h)]\n\ndef _normalize_matrix(mat: MATRIX) -> MATRIX:\n    out: MATRIX = []\n    for row in mat:\n        new_row = []\n        for v in row:\n            try:\n                iv = int(v)\n            except Exception:\n                iv = 0\n            if iv < 0:\n                iv = 0\n            if iv > 9:\n                iv = 9\n            new_row.append(iv)\n        out.append(new_row)\n    return out\n\ndef _same_shape(a: MATRIX, b: MATRIX) -> bool:\n    if len(a) != len(b):\n        return False\n    return all(len(ra) == len(rb) for ra, rb in zip(a, b))\n\ndef _compare_matrices(a: MATRIX, b: MATRIX) -> Tuple[bool, List[Tuple[int, int, int, int]]]:\n    diffs: List[Tuple[int, int, int, int]] = []\n    if not _same_shape(a, b):\n        return False, diffs\n    for i, (ra, rb) in enumerate(zip(a, b)):\n        for j, (va, vb) in enumerate(zip(ra, rb)):\n            if va != vb:\n                diffs.append((i, j, va, vb))\n    return (len(diffs) == 0), diffs\n\ndef _verify_on_training(transform_fn, training_examples: List[TrainingExample]) -> Tuple[bool, str]:\n    reports = []\n    all_ok = True\n    for idx, ex in enumerate(training_examples):\n        try:\n            out = transform_fn(copy.deepcopy(ex.input))\n        except Exception as e:\n            all_ok = False\n            reports.append(f\"Example {idx}: Exception during transform: {repr(e)}\")\n            continue\n        if not isinstance(out, list) or (len(out) > 0 and not isinstance(out[0], list)):\n            all_ok = False\n            reports.append(f\"Example {idx}: Output is not a 2D list.\")\n            continue\n        out = _normalize_matrix(out)\n        # For ARC, output shape must match the example's output shape, not necessarily the input shape.\n        if not _same_shape(out, ex.output):\n            all_ok = False\n            reports.append(f\"Example {idx}: Shape mismatch. Got {len(out)}x{len(out[0]) if out else 0}, expected {len(ex.output)}x{len(ex.output[0]) if ex.output else 0}.\")\n            continue\n        ok, diffs = _compare_matrices(out, ex.output)\n        if not ok:\n            all_ok = False\n            sample_diffs = diffs[:20]\n            reports.append(f\"Example {idx}: {len(diffs)} cells differ. Sample diffs (r,c got->exp): \" +\n                           \", \".join([f\"({r},{c} {gv}->{ev})\" for r, c, gv, ev in sample_diffs]))\n    return all_ok, \"\\n\".join(reports)\n\ndef _apply_code_to_tests(code: str, test_inputs: List[MATRIX]) -> List[MATRIX]:\n    fn = _safe_exec_transform(code)\n    if not fn:\n        return []\n    outputs = []\n    for idx, ti in enumerate(test_inputs):\n        try:\n            out = fn(copy.deepcopy(ti))\n        except Exception:\n            return []\n        if not isinstance(out, list) or (len(out) > 0 and not isinstance(out[0], list)):\n            return []\n        out = _normalize_matrix(out)\n        outputs.append(out)\n    return outputs\n\ndef _safe_exec_transform(code: str) -> Optional[Any]:\n    \"\"\"\n    Exec the transform function in a restricted namespace with helper utilities.\n    Returns callable transform or None if failure.\n    \"\"\"\n    code = _ensure_transform_code(code)\n    if not code:\n        return None\n\n    # Safe helper library exposed to the model's code.\n    sandbox_globals: Dict[str, Any] = {\n        \"__builtins__\": {\n            \"range\": range,\n            \"len\": len,\n            \"enumerate\": enumerate,\n            \"min\": min,\n            \"max\": max,\n            \"sum\": sum,\n            \"abs\": abs,\n            \"all\": all,\n            \"any\": any,\n            \"sorted\": sorted,\n            \"zip\": zip,\n            \"list\": list,\n            \"set\": set,\n            \"tuple\": tuple,\n            \"int\": int\n        },\n        \"deepcopy\": copy.deepcopy,\n        # helpers\n        \"height\": _height,\n        \"width\": _width,\n        \"in_bounds\": _in_bounds,\n        \"colors\": _colors,\n        \"color_counts\": _color_counts,\n        \"positions_of\": _positions_of,\n        \"bbox_of\": _bbox_of,\n        \"crop\": _crop,\n        \"transpose\": _transpose,\n        \"new_grid\": _new_grid,\n    }\n    sandbox_locals: Dict[str, Any] = {}\n    try:\n        exec(code, sandbox_globals, sandbox_locals)\n        fn = sandbox_locals.get(\"transform\") or sandbox_globals.get(\"transform\")\n        if callable(fn):\n            return fn\n    except Exception:\n        return None\n    return None\n\ndef _matrix_shape(mat: MATRIX) -> Tuple[int, int]:\n    if not isinstance(mat, list) or (mat and not isinstance(mat[0], list)):\n        return (0, 0)\n    return (len(mat), len(mat[0]) if mat else 0)\n\ndef _stats_for_grid(grid: MATRIX) -> Dict[str, Any]:\n    h, w = _matrix_shape(grid)\n    pal = _colors(grid)\n    cnt = _color_counts(grid)\n    nonzero_bbox = _bbox_of(grid, colors=None, nonzero=True)\n    counts_str = \",\".join(f\"{k}:{cnt[k]}\" for k in sorted(cnt.keys()))\n    return {\n        \"shape\": [h, w],\n        \"palette\": pal,\n        \"counts\": counts_str,\n        \"nonzero_bbox\": nonzero_bbox\n    }\n\ndef _build_training_summary(training_examples: List[TrainingExample]) -> str:\n    # Construct a concise, structured summary string for the LM.\n    lines = []\n    for i, ex in enumerate(training_examples):\n        in_stats = _stats_for_grid(ex.input)\n        out_stats = _stats_for_grid(ex.output)\n        lines.append(\n            f\"Example {i}: input_shape={in_stats['shape']}, output_shape={out_stats['shape']}, \"\n            f\"input_palette={in_stats['palette']}, output_palette={out_stats['palette']}, \"\n            f\"input_counts={in_stats['counts']}, output_counts={out_stats['counts']}, \"\n            f\"input_nonzero_bbox={in_stats['nonzero_bbox']}, output_nonzero_bbox={out_stats['nonzero_bbox']}\"\n        )\n    # Heuristics across examples:\n    shape_deltas = []\n    for ex in training_examples:\n        ih, iw = _matrix_shape(ex.input)\n        oh, ow = _matrix_shape(ex.output)\n        shape_deltas.append((oh - ih, ow - iw))\n    unique_deltas = sorted(set(shape_deltas))\n    lines.append(f\"Unique shape deltas (oh-ih, ow-iw) across training: {unique_deltas}\")\n    return \"\\n\".join(lines)\n\nclass InduceRuleSignature(dspy.Signature):\n    \"\"\"\n    You are given several training input/output pairs from an ARC task. Infer a single deterministic transformation rule\n    that maps any input grid to its output grid. Produce:\n    1) A succinct, generalized rule_summary describing the pattern.\n    2) A Python function `def transform(grid): ...` implementing the rule.\n\n    Execution constraints and helpers:\n      - grid is a 2D list of ints (0..9). Deterministic logic only (loops, conditionals, list ops).\n      - Do not import modules or use randomness.\n      - You MAY change the output shape when the task demands it. Match the training outputs' shapes for their inputs.\n      - Indices must be in-bounds; handle arbitrary rectangular shapes.\n      - Mutations: copy if needed; avoid mutating the input in-place unless safe.\n      - Values must remain ints 0..9.\n\n    Common pitfalls to avoid:\n      - Off-by-one when cropping or expanding; mixing up row/col order.\n      - Assuming output has same shape as input when training shows otherwise.\n      - Forgetting to preserve anchor colors or key markers when summarizing patterns.\n      - Using unavailable libraries (numpy/pandas).\n\n    Successful strategies:\n      - Use bounding boxes of non-zero or target colors to crop or extract regions (bbox_of, crop).\n      - Build frequency maps to pick dominant or anchor colors (color_counts, colors).\n      - Compress by selecting rows/cols that contain target colors; preserve ordering.\n      - When outputs are smaller, they often summarize a motif or mask of specific colors (e.g., 1 and 2).\n\n    Helper functions available in the environment:\n      - height(grid), width(grid), in_bounds(grid,r,c)\n      - colors(grid) -> sorted list of unique colors\n      - color_counts(grid) -> dict color->count\n      - positions_of(grid, color) -> list of (r,c)\n      - bbox_of(grid, colors=None, nonzero=True) -> (rmin,cmin,rmax,cmax) inclusive or None\n      - crop(grid, bbox) -> returns subgrid bounded by bbox\n      - transpose(grid), new_grid(h,w,fill)\n\n    Return fields:\n      - rule_summary: Concise paragraph of the inferred rule.\n      - python_code: Only the code defining def transform(grid): ...; no extra commentary or fences.\n\n    Important: Return only rule_summary and python_code; do not include explanations beyond those fields.\n    \"\"\"\n    training_examples: List[TrainingExample] = dspy.InputField(desc=\"Examples showing input->output mappings for the task.\")\n    training_summary: str = dspy.InputField(desc=\"Structured stats about shapes, palettes, counts, and bboxes across examples.\")\n    rule_summary: str = dspy.OutputField(desc=\"One concise paragraph describing the inferred rule.\")\n    python_code: str = dspy.OutputField(desc=\"Only the code defining def transform(grid): ...; no explanations.\")\n\nclass RefineRuleSignature(dspy.Signature):\n    \"\"\"\n    The previous Python transform did not perfectly match all training examples.\n    Given the training_examples, training_summary (stats), the prior_code for transform(grid), and a failure_report\n    describing mismatches, produce a corrected version of transform(grid).\n\n    Instructions:\n    - Keep the same overall approach but fix the logic to satisfy all training pairs.\n    - You MAY alter the output shape; match each training output's shape for its input.\n    - Maintain determinism; no external imports; values are ints 0..9.\n    - Be careful with off-by-one, bounds, and row/col order.\n    - Return only a complete, standalone function definition: def transform(grid): ...\n    \"\"\"\n    training_examples: List[TrainingExample] = dspy.InputField(desc=\"Authoritative input/output examples.\")\n    training_summary: str = dspy.InputField(desc=\"Structured stats about shapes, palettes, counts, and bboxes across examples.\")\n    prior_code: str = dspy.InputField(desc=\"Previous attempt's function code.\")\n    failure_report: str = dspy.InputField(desc=\"Concrete mismatches and diagnostics from verification.\")\n    python_code: str = dspy.OutputField(desc=\"Revised code: only def transform(grid): ...\")\n\nclass DirectSolveSignature(dspy.Signature):\n    \"\"\"\n    If code induction fails, directly produce outputs for test_inputs using a consistent rule induced from training.\n    Requirements:\n    - Return only a Python literal list of output grids aligned with test_inputs (e.g., [[[...],[...]], [[...], ...]]).\n    - Do not include any commentary, bullets, or extra text.\n    - Output ints in 0..9 only. Shapes may differ from inputs; match the pattern demonstrated in training pairs.\n    - Apply the same inferred rule consistently across all test inputs.\n    \"\"\"\n    training_examples: List[TrainingExample] = dspy.InputField(desc=\"Training pairs for the task.\")\n    test_inputs: List[MATRIX] = dspy.InputField(desc=\"Unseen inputs to solve.\")\n    test_outputs: List[MATRIX] = dspy.OutputField(desc=\"Predicted outputs for each test input.\")\n\nclass ARCRuleProgram(dspy.Module):\n    def __init__(self, max_refinements: int = 4):\n        super().__init__()\n        self.induce = dspy.ChainOfThought(InduceRuleSignature)\n        self.refine = dspy.ChainOfThought(RefineRuleSignature)\n        self.direct = dspy.ChainOfThought(DirectSolveSignature)\n        self.max_refinements = max_refinements\n\n    def forward(self, training_examples: List[TrainingExample], test_inputs: List[MATRIX]) -> dspy.Prediction:\n        training_summary = _build_training_summary(training_examples)\n\n        # Step 1: Induce rule and code\n        draft = self.induce(training_examples=training_examples, training_summary=training_summary)\n        code = draft.python_code or \"\"\n        code = _strip_code_fences(code)\n\n        # Step 2: Verify and refine iteratively\n        for _ in range(self.max_refinements + 1):\n            fn = _safe_exec_transform(code)\n            if fn is None:\n                failure_report = \"Could not exec transform function. Ensure a valid def transform(grid): ... exists and no imports.\"\n            else:\n                ok, report = _verify_on_training(fn, training_examples)\n                if ok:\n                    # Step 3: Apply to tests\n                    outputs = _apply_code_to_tests(code, test_inputs)\n                    if outputs:\n                        return dspy.Prediction(test_outputs=outputs)\n                    failure_report = \"Execution on test inputs failed or returned invalid outputs.\"\n                else:\n                    failure_report = report\n            # Attempt refinement\n            refined = self.refine(\n                training_examples=training_examples,\n                training_summary=training_summary,\n                prior_code=code,\n                failure_report=failure_report\n            )\n            new_code = _strip_code_fences(refined.python_code or \"\")\n            if not new_code or new_code.strip() == code.strip():\n                code = new_code or code\n                break\n            code = new_code\n\n        # Fallback: direct solve via LM\n        direct = self.direct(training_examples=training_examples, test_inputs=test_inputs)\n        safe_outs: List[MATRIX] = []\n        if isinstance(direct.test_outputs, list):\n            for mat in direct.test_outputs:\n                try:\n                    safe_outs.append(_normalize_matrix(mat))\n                except Exception:\n                    # Skip invalid entries\n                    pass\n        return dspy.Prediction(test_outputs=safe_outs)\n\nclass SolveTaskSignature(dspy.Signature):\n    \"\"\"\n    Solve ARC tasks using rule induction with verifiable code and robust fallback.\n    Inputs:\n      - training_examples: list of TrainingExample(input, output)\n      - test_inputs: list of matrices to solve\n    Output:\n      - test_outputs: list of predicted output matrices\n    \"\"\"\n    training_examples: List[TrainingExample] = dspy.InputField(desc=\"Input/output examples demonstrating the task to be performed.\")\n    test_inputs: List[MATRIX] = dspy.InputField(desc=\"Input matrices to be solved following the task described in the training examples.\")\n    test_outputs: List[MATRIX] = dspy.OutputField(desc=\"Output matrices corresponding to the test inputs.\")\n\nclass SolveARC(dspy.Module):\n    def __init__(self):\n        super().__init__()\n        self.core = ARCRuleProgram()\n\n    def forward(self, training_examples: List[TrainingExample], test_inputs: List[MATRIX]) -> dspy.Prediction:\n        return self.core(training_examples=training_examples, test_inputs=test_inputs)\n\nprogram = SolveARC()"
  }
}