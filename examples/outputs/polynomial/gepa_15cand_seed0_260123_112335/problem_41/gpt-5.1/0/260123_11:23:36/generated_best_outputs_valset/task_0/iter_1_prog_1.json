{
    "score": 0.0006900803899986662,
    "Input": "Parsopoulos",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization with budget-aware randomized local search.\n\n    Strategy:\n    - Use prev_best_x as warm start if provided.\n    - Global exploration via random sampling in the box.\n    - Around the current best, perform adaptive Gaussian local search.\n    - Fully consume the budget (or as close as possible).\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG to avoid side effects\n\n    bounds = np.asarray(config['bounds'], dtype=float)\n    dim = int(config['dim'])\n    budget = int(config['budget'])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n    span[span == 0.0] = 1.0  # avoid zero-variance issues\n\n    # If no budget, return midpoint\n    if budget <= 0:\n        return (low + high) / 2.0\n\n    # Helper: clip to bounds\n    def clip_to_bounds(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    # Initialization: use prev_best_x if valid, otherwise random\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip_to_bounds(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n        else:\n            x0 = rng.uniform(low, high)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n    else:\n        x0 = rng.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Allocate evaluations: mix of global and local search\n    # Rough heuristic: 30% global, 70% local (at least 1 each if possible)\n    global_evals = max(1, int(0.3 * remaining))\n    local_evals = max(0, remaining - global_evals)\n\n    # Global exploration: random uniform samples in the box\n    for _ in range(global_evals):\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = x, y\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Local search around best found so far using adaptive Gaussian steps\n    # Initial step size: 20% of box width, reduced over time\n    base_sigma = 0.2 * span\n    base_sigma[base_sigma == 0.0] = 0.1  # fallback\n\n    for i in range(remaining):\n        # Decrease step size over time to focus search\n        frac = 1.0 - (i / max(1, remaining - 1))\n        sigma = np.maximum(0.05 * span, base_sigma * frac)\n\n        step = rng.normal(loc=0.0, scale=sigma, size=dim)\n        candidate = clip_to_bounds(best_x + step)\n        y = objective_function(candidate)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = candidate, y\n\n    return best_x",
    "X": "1.596923554308201 3.138835171690376"
}