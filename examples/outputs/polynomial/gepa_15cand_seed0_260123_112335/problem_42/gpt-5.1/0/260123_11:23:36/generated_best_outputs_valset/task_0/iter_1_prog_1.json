{
    "score": 1.716458933245154e-05,
    "Input": "Pinter",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization using a simple hybrid strategy:\n    - Global search via random / quasi-random sampling\n    - Local search via coordinate-wise hill climbing around good points\n    - Warm start from prev_best_x if provided\n\n    Assumes:\n        config['bounds']: array-like of shape (dim, 2)\n        config['dim']: int\n        config['budget']: int\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG to avoid side effects\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    def clip(x):\n        return np.minimum(high, np.maximum(low, x))\n\n    def eval_point(x):\n        return objective_function(x)\n\n    # Handle tiny budgets robustly\n    if budget <= 0:\n        # With no evaluations allowed, just return center of bounds\n        return (low + high) / 2.0\n\n    # Initialization: use prev_best_x if available, otherwise random in bounds\n    evals = 0\n    best_x = None\n    best_y = None\n\n    if prev_best_x is not None:\n        x0 = clip(np.asarray(prev_best_x, dtype=float).reshape(dim))\n        y0 = eval_point(x0)\n        evals += 1\n        best_x, best_y = x0, y0\n    else:\n        x0 = rng.uniform(low, high)\n        y0 = eval_point(x0)\n        evals += 1\n        best_x, best_y = x0, y0\n\n    # If budget is already exhausted\n    if evals >= budget:\n        return best_x\n\n    # Global sampling phase\n    # Use ~60% of remaining budget (at least dim + 3 samples) for global exploration\n    remaining = budget - evals\n    global_budget = max(dim + 3, int(0.6 * budget))\n    global_budget = min(global_budget, remaining)\n\n    # Low discrepancy / stratified-like sampling in [0,1]^dim, then scale\n    # We'll generate points in batches for efficiency\n    n_global = global_budget\n    if n_global > 0:\n        # Latin-hypercube-like: for each dimension, permuted strata\n        strata = (rng.rand(n_global, dim) + np.arange(n_global)[:, None]) / n_global\n        # Randomly shuffle strata per dimension\n        for d in range(dim):\n            rng.shuffle(strata[:, d])\n        samples = low + strata * span\n\n        for i in range(n_global):\n            x = samples[i]\n            y = eval_point(x)\n            evals += 1\n            if y < best_y:\n                best_x, best_y = x, y\n            if evals >= budget:\n                return best_x\n\n    # Local search phase (coordinate-wise hill climbing)\n    remaining = budget - evals\n    if remaining <= 0:\n        return best_x\n\n    # Use multiple starting points for robustness: best_x plus a few randoms if budget allows\n    n_starts = 1\n    if remaining > 5 * dim:\n        n_starts = min(3, 1 + remaining // (4 * dim))\n    starts = [best_x]\n    for _ in range(n_starts - 1):\n        starts.append(rng.uniform(low, high))\n\n    # Step scales for local search: start moderate, then shrink\n    base_step = 0.2 * span  # 20% of range per dimension\n\n    for start in starts:\n        if evals >= budget:\n            break\n        current_x = clip(np.array(start, dtype=float))\n        current_y = eval_point(current_x)\n        evals += 1\n        if current_y < best_y:\n            best_x, best_y = current_x, current_y\n        if evals >= budget:\n            break\n\n        step = base_step.copy()\n        # Number of local iterations per start depends on remaining budget\n        # Roughly allocate evaluations so that each iteration uses about 2*dim evals\n        remaining_local = budget - evals\n        max_iters = max(1, remaining_local // (2 * dim))\n        max_iters = min(max_iters, 15)  # hard cap to avoid overfitting local search\n\n        for _ in range(max_iters):\n            improved = False\n            for d in range(dim):\n                if evals >= budget:\n                    break\n\n                # Try positive step\n                cand_pos = current_x.copy()\n                cand_pos[d] = cand_pos[d] + step[d]\n                cand_pos = clip(cand_pos)\n                y_pos = eval_point(cand_pos)\n                evals += 1\n                if y_pos < current_y:\n                    current_x, current_y = cand_pos, y_pos\n                    improved = True\n                    if current_y < best_y:\n                        best_x, best_y = current_x, current_y\n                    continue  # move to next dimension\n\n                if evals >= budget:\n                    break\n\n                # Try negative step\n                cand_neg = current_x.copy()\n                cand_neg[d] = cand_neg[d] - step[d]\n                cand_neg = clip(cand_neg)\n                y_neg = eval_point(cand_neg)\n                evals += 1\n                if y_neg < current_y:\n                    current_x, current_y = cand_neg, y_neg\n                    improved = True\n                    if current_y < best_y:\n                        best_x, best_y = current_x, current_y\n\n            if evals >= budget:\n                break\n\n            # If no improvement in this full coordinate pass, shrink steps\n            if not improved:\n                step *= 0.5\n                # Stop if steps are extremely small compared to bounds\n                if np.all(step < 1e-6 * np.maximum(1.0, span)):\n                    break\n\n    return best_x",
    "X": "-0.00021077605923876296 -0.0007549085156185091"
}