{
    "score": -3.6196729203894136,
    "Input": "Michalewicz",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Basic black-box minimization using random search with optional local\n    refinement around a warm start (prev_best_x).\n\n    Strategy:\n    - Use ~20% of budget for global uniform random search.\n    - If prev_best_x is provided, allocate ~40% for local search around it.\n    - Use remaining budget for global search around the current best found.\n    \"\"\"\n    bounds = np.asarray(config['bounds'], dtype=float)\n    dim = int(config.get('dim', bounds.shape[0]))\n    budget = int(config.get('budget', 1))\n\n    low, high = bounds[:, 0], bounds[:, 1]\n\n    # Ensure at least one evaluation\n    if budget <= 0:\n        # Fallback: return middle of bounds\n        return (low + high) / 2.0\n\n    # Helper: project x back into box constraints\n    def clip_to_bounds(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    # Initialization: use prev_best_x if provided and within bounds\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.shape[0] != dim:\n            x0 = np.random.uniform(low, high)\n        else:\n            x0 = clip_to_bounds(x0)\n    else:\n        x0 = np.random.uniform(low, high)\n\n    best_x = x0\n    best_y = objective_function(best_x)\n    evals_used += 1\n\n    # Determine budget slices\n    # At least 1 eval per phase if possible\n    global_frac_initial = 0.2\n    local_frac = 0.4 if prev_best_x is not None else 0.0\n    global_frac_final = max(0.0, 1.0 - global_frac_initial - local_frac)\n\n    global_initial_budget = int(budget * global_frac_initial)\n    local_budget = int(budget * local_frac)\n    # Ensure total doesn't exceed budget when rounding\n    if global_initial_budget + local_budget > budget - 1:\n        # Leave at least one for final phase if possible\n        excess = global_initial_budget + local_budget - (budget - 1)\n        # Remove from local search first\n        reduce_local = min(excess, local_budget)\n        local_budget -= reduce_local\n        excess -= reduce_local\n        if excess > 0:\n            global_initial_budget = max(0, global_initial_budget - excess)\n\n    # Adjust final budget as remaining\n    final_budget = max(0, budget - evals_used - global_initial_budget - local_budget)\n\n    rng = np.random.default_rng()\n\n    # Phase 1: global random search over the box\n    n = min(global_initial_budget, budget - evals_used)\n    if n > 0:\n        # Vectorized sampling\n        xs = rng.uniform(low, high, size=(n, dim))\n        for i in range(n):\n            if evals_used >= budget:\n                break\n            y = objective_function(xs[i])\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = xs[i].copy()\n\n    # Phase 2: local search around prev_best_x if available\n    # Use decreasing radius search around current best\n    n = min(local_budget, budget - evals_used)\n    if n > 0:\n        # Initial radius is 25% of the box width\n        box_width = high - low\n        base_radius = 0.25 * box_width\n        for k in range(n):\n            if evals_used >= budget:\n                break\n            # Radius shrinks over time\n            frac = 1.0 - (k / max(1, n - 1))\n            radius = base_radius * (0.1 + 0.9 * frac)\n            step = rng.normal(loc=0.0, scale=1.0, size=dim)\n            step = step / (np.linalg.norm(step) + 1e-12)  # unit direction\n            # Scale step per-dimension by radius\n            candidate = best_x + step * radius\n            candidate = clip_to_bounds(candidate)\n            y = objective_function(candidate)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = candidate\n\n    # Phase 3: final global exploitation around current best\n    n = max(0, budget - evals_used)\n    if n > 0:\n        box_width = high - low\n        # Start moderately local and gradually move to broader search\n        for k in range(n):\n            if evals_used >= budget:\n                break\n            # Interpolate between local and global radius\n            t = k / max(1, n - 1)\n            local_scale = 0.1\n            global_scale = 0.5\n            radius = (1 - t) * (local_scale * box_width) + t * (global_scale * box_width)\n            step = rng.normal(loc=0.0, scale=1.0, size=dim)\n            step = step / (np.linalg.norm(step) + 1e-12)\n            candidate = best_x + step * radius\n            candidate = clip_to_bounds(candidate)\n            y = objective_function(candidate)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = candidate\n\n    return best_x.reshape(dim,)",
    "X": "2.1962174268445205 1.5688722083636515 1.295839387706887 1.0932619185533345"
}