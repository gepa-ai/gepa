{
    "score": -0.25,
    "Input": "McCourt07",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer:\n    - Global random search (70% of budget)\n    - Local coordinate search around best (30% of budget)\n    - Supports warm start from prev_best_x\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG to avoid side effects\n\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    # Basic safety checks\n    if bounds.shape[0] != dim:\n        bounds = np.tile(bounds.reshape(-1, 2), (dim // bounds.shape[0] + 1, 1))[:dim]\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n    span[span <= 0] = 1.0  # avoid degenerate intervals\n\n    if budget <= 0:\n        # Fallback: return middle of bounds\n        return (low + high) / 2.0\n\n    # Helper: project into bounds\n    def project(x):\n        return np.clip(x, low, high)\n\n    # Initialize best point\n    evals_used = 0\n    if prev_best_x is not None:\n        x_best = project(np.asarray(prev_best_x, dtype=float).reshape(-1)[:dim])\n    else:\n        x_best = rng.uniform(low, high)\n\n    y_best = objective_function(x_best)\n    evals_used += 1\n\n    # If only one evaluation allowed, return immediately\n    if budget == 1:\n        return x_best\n\n    # Split budget: global random search then local search\n    global_budget = max(1, int(0.7 * (budget - evals_used)))\n    local_budget = (budget - evals_used) - global_budget\n\n    # --- Global random search ---\n    for _ in range(global_budget):\n        # Latin-hypercube-like sampling per dimension via jittered uniform\n        u = (rng.rand(dim) + rng.randint(0, global_budget + 1) / (global_budget + 1)) % 1.0\n        x = low + u * span\n        y = objective_function(x)\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n\n    # --- Local coordinate search around best (simple pattern search) ---\n    if local_budget > 0:\n        # Initial step sizes: fraction of span, adapt per iteration\n        step = 0.1 * span\n        step[step == 0] = 0.1\n\n        iters = max(1, local_budget // (2 * dim))\n        for _ in range(iters):\n            improved = False\n            # For each dimension, try positive and negative moves\n            for d in range(dim):\n                if evals_used >= budget:\n                    break\n                for direction in (+1.0, -1.0):\n                    if evals_used >= budget:\n                        break\n                    candidate = x_best.copy()\n                    candidate[d] += direction * step[d]\n                    candidate = project(candidate)\n                    y = objective_function(candidate)\n                    evals_used += 1\n                    if y < y_best:\n                        x_best, y_best = candidate, y\n                        improved = True\n            # Simple step size adaptation\n            if not improved:\n                step *= 0.5\n                if np.all(step < 1e-8 * span):\n                    break  # steps too small, stop local search\n            else:\n                step *= 1.05  # slightly increase step when improving\n\n            if evals_used >= budget:\n                break\n\n    return x_best",
    "X": "0.37253984583281596 1.0 0.6452172211148922 0.2037207070916307 0.9721141222591538 0.3220316820181792"
}