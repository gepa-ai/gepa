{
    "score": -2.2838809713997126,
    "Input": "Mishra06",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    lower, upper = bounds[:, 0], bounds[:, 1]\n    span = upper - lower\n\n    rng = np.random.RandomState()  # independent RNG\n\n    def project(x):\n        return np.clip(x, lower, upper)\n\n    evals_used = 0\n\n    # Initialize best solution\n    best_x = None\n    best_y = np.inf\n\n    # Use warm start if available and within bounds\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            x0 = project(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # If no warm start used or budget still mostly unused, add a random start\n    if evals_used < budget and best_x is None:\n        x0 = rng.uniform(lower, upper)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x.astype(float)\n\n    # Split remaining budget between global sampling and local search\n    # At least 2 for each phase if possible\n    global_evals = max(2, int(0.5 * remaining))\n    global_evals = min(global_evals, remaining)\n    local_evals = remaining - global_evals\n\n    # Global random search around entire space, biased near current best if any\n    for _ in range(global_evals):\n        if best_x is not None and rng.rand() < 0.7:\n            # sample near best_x\n            scale = span * 0.1\n            cand = best_x + rng.normal(0.0, 1.0, size=dim) * scale\n        else:\n            cand = rng.uniform(lower, upper)\n        cand = project(cand)\n        y = objective_function(cand)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = cand, y\n\n    remaining = budget - evals_used\n    if remaining <= 0 or best_x is None:\n        return best_x.astype(float)\n\n    # Simple local search: coordinate-wise adaptive step search\n    x = best_x.copy()\n    step = span * 0.1\n    step = np.where(step == 0, 1.0, step)\n\n    for _ in range(remaining):\n        # choose a coordinate to perturb\n        i = rng.randint(0, dim)\n        direction = rng.choice([-1.0, 1.0])\n        cand = x.copy()\n        cand[i] += direction * step[i]\n        cand = project(cand)\n        y = objective_function(cand)\n        evals_used += 1\n\n        if y < best_y:\n            best_y = y\n            best_x = cand\n            x = cand\n        else:\n            # reduce step size for that dimension to refine locally\n            step[i] *= 0.5\n            if step[i] < 1e-12 * max(span[i], 1.0):\n                step[i] = 1e-12 * max(span[i], 1.0)\n\n        if evals_used >= budget:\n            break\n\n    return best_x.astype(float)",
    "X": "2.881126553584162 1.8256954984686935"
}