{
    "score": -2.2839498384223296,
    "Input": "Mishra06",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    lower, upper = bounds[:, 0], bounds[:, 1]\n    span = upper - lower\n    span = np.where(span == 0.0, 1.0, span)\n\n    rng = np.random.RandomState()\n\n    def project(x):\n        return np.clip(x, lower, upper)\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # --- Warm start / initial points ---\n    # 1) Try prev_best_x if available and valid\n    if prev_best_x is not None and evals_used < budget:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            x0 = project(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # 2) Ensure at least one random start if we still have no solution\n    if best_x is None and evals_used < budget:\n        x0 = rng.uniform(lower, upper)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if evals_used >= budget:\n        return best_x.astype(float)\n\n    remaining = budget - evals_used\n\n    # --- Phase allocation: global (diverse) + local (exploit) ---\n    # Give more to global for small budgets, more balanced for larger ones\n    if remaining <= 5:\n        global_evals = remaining\n        local_evals = 0\n    else:\n        global_evals = int(0.6 * remaining)\n        global_evals = max(3, min(global_evals, remaining - 2))\n        local_evals = remaining - global_evals\n\n    # --- Global search: mixture of uniform + best-centered Gaussian ---\n    for _ in range(global_evals):\n        if rng.rand() < 0.5 and best_x is not None:\n            # Sample around current best with adaptive scale\n            scale = 0.2 * span\n            noise = rng.normal(0.0, 1.0, size=dim) * scale\n            cand = best_x + noise\n        else:\n            # Pure global sample\n            cand = rng.uniform(lower, upper, size=dim)\n\n        cand = project(cand)\n        y = objective_function(cand)\n        evals_used += 1\n\n        if y < best_y:\n            best_x, best_y = cand, y\n\n        if evals_used >= budget:\n            return best_x.astype(float)\n\n    if local_evals <= 0 or best_x is None:\n        return best_x.astype(float)\n\n    # --- Local search: stochastic coordinate search with adaptive radius ---\n    x = best_x.copy()\n    # Initial step size smaller to allow finer search, scaled by domain\n    step = 0.1 * span\n    step = np.where(step <= 0.0, 1.0, step)\n\n    min_step = 1e-6 * span\n    min_step = np.where(min_step <= 0.0, 1e-6, min_step)\n\n    for _ in range(local_evals):\n        # Random subset of coordinates (1 or 2 depending on dimension)\n        if dim == 1:\n            idxs = [0]\n        else:\n            k = 1 if rng.rand() < 0.7 else min(2, dim)\n            idxs = rng.choice(dim, size=k, replace=False)\n\n        cand = x.copy()\n        for i in idxs:\n            direction = rng.choice([-1.0, 1.0])\n            # Randomized step magnitude around current step[i]\n            mag = step[i] * (0.5 + rng.rand())\n            cand[i] += direction * mag\n\n        cand = project(cand)\n        y = objective_function(cand)\n        evals_used += 1\n\n        if y < best_y:\n            best_y = y\n            best_x = cand\n            x = cand\n            # Slightly increase step for successful coordinates (encourage bold moves)\n            for i in idxs:\n                step[i] *= 1.1\n        else:\n            # Reduce step for unsuccessful coordinates (refinement)\n            for i in idxs:\n                step[i] *= 0.5\n                if step[i] < min_step[i]:\n                    step[i] = min_step[i]\n\n        if evals_used >= budget:\n            break\n\n    return best_x.astype(float)",
    "X": "2.886309965872995 1.823262308329116"
}