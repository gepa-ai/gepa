{
    "score": -1.4274598453979959,
    "Input": "McCourt26",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer combining global random search and\n    local coordinate search, using full evaluation budget.\n    \"\"\"\n    rng = np.random.default_rng()\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n\n    # Guard against degenerate cases\n    span[span <= 0] = 1.0\n\n    remaining = budget\n\n    # --- Initialization (use prev_best_x if provided and valid) ---\n    if prev_best_x is not None:\n        x_best = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x_best.shape[0] != dim:\n            x_best = None\n        else:\n            # Clip to bounds\n            x_best = np.clip(x_best, low, high)\n    else:\n        x_best = None\n\n    if x_best is None:\n        x_best = rng.uniform(low, high)\n    y_best = objective_function(x_best)\n    remaining -= 1\n    if remaining <= 0:\n        return x_best\n\n    # --- Global search: random sampling within bounds ---\n    # Reserve at least dim*3 evaluations for local search\n    min_local_evals = max(3 * dim, 10)\n    global_evals = max(0, remaining - min_local_evals)\n\n    if global_evals > 0:\n        # Batch size for efficiency; handle leftover individually\n        batch_size = min(32, global_evals)\n        num_full_batches = global_evals // batch_size\n        leftover = global_evals % batch_size\n\n        def evaluate_batch(n_eval):\n            nonlocal x_best, y_best, remaining\n            X = rng.uniform(low, high, size=(n_eval, dim))\n            for x in X:\n                y = objective_function(x)\n                remaining -= 1\n                if y < y_best:\n                    y_best, x_best = y, x\n                if remaining <= 0:\n                    return True  # budget exhausted\n            return False\n\n        for _ in range(num_full_batches):\n            if evaluate_batch(batch_size):\n                return x_best\n\n        if leftover > 0 and remaining > 0:\n            if evaluate_batch(leftover):\n                return x_best\n\n    if remaining <= 0:\n        return x_best\n\n    # --- Local search: coordinate perturbations around best point ---\n    # Start with step size proportional to the span\n    step = 0.2 * span\n    step[step == 0] = 0.1  # fallback\n\n    # Pattern search until budget is exhausted\n    while remaining > 0:\n        improved = False\n        for i in range(dim):\n            if remaining <= 0:\n                break\n\n            # Try positive and negative directions\n            for direction in (+1.0, -1.0):\n                if remaining <= 0:\n                    break\n\n                x_candidate = np.array(x_best, copy=True)\n                x_candidate[i] += direction * step[i]\n                x_candidate = np.clip(x_candidate, low, high)\n\n                y_candidate = objective_function(x_candidate)\n                remaining -= 1\n\n                if y_candidate < y_best:\n                    y_best, x_best = y_candidate, x_candidate\n                    improved = True\n\n                    if remaining <= 0:\n                        break\n\n        # If no improvement in full coordinate sweep, reduce step\n        if not improved:\n            step *= 0.5\n            # If step is extremely small, break to avoid wasting calls\n            if np.all(step < span * 1e-6):\n                break\n\n    # Use any leftover budget for random perturbations around best\n    while remaining > 0:\n        # Small Gaussian perturbation around best, clipped to bounds\n        perturb = rng.normal(scale=0.05 * span, size=dim)\n        x_candidate = np.clip(x_best + perturb, low, high)\n        y_candidate = objective_function(x_candidate)\n        remaining -= 1\n        if y_candidate < y_best:\n            y_best, x_best = y_candidate, x_candidate\n\n    return x_best",
    "X": "0.5303525382456779 0.7704974769271745 0.2655216092729553"
}