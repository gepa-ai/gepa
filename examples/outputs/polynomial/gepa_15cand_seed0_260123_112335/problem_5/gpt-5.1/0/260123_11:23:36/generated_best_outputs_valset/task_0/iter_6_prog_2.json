{
    "score": 1.4758214044030862e-38,
    "Input": "Csendes",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", len(bounds)))\n    budget = int(config.get(\"budget\", 1))\n\n    lower = bounds[:, 0]\n    upper = bounds[:, 1]\n    span = upper - lower\n    span[span <= 0.0] = 1.0  # avoid zero-span issues\n\n    # Clamp any provided point to bounds\n    def clamp(x):\n        return np.clip(x, lower, upper)\n\n    # Safe evaluation wrapper\n    def eval_point(x):\n        return objective_function(x)\n\n    evals_used = 0\n\n    # Initialize best solution (use prev_best_x if provided and within dimension)\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape[0] != dim:\n            # Dimension mismatch fallback\n            x0 = np.random.uniform(lower, upper)\n        x0 = clamp(x0)\n        y0 = eval_point(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n    else:\n        x0 = np.random.uniform(lower, upper)\n        y0 = eval_point(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if budget <= evals_used:\n        return best_x\n\n    remaining = budget - evals_used\n\n    # Split remaining budget: global exploration + local search\n    # Bias more to global when budget small or dim large\n    if remaining < 20 or dim > 20:\n        global_frac = 0.75\n    else:\n        global_frac = 0.6\n    global_budget = max(1, int(global_frac * remaining))\n    local_budget = remaining - global_budget\n\n    # --- Global exploration: Latin Hypercube Sampling (approx) + random ---\n    # Try to cover space better than pure random if enough budget\n    if global_budget <= dim:\n        # Very small budget: pure random\n        for _ in range(global_budget):\n            x = np.random.uniform(lower, upper)\n            y = eval_point(x)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = x, y\n    else:\n        # Simple LHS-like stratification per dimension\n        n_samples = global_budget\n        # Generate [0,1] LHS samples\n        u = (np.random.rand(n_samples, dim) + np.random.permutation(np.arange(n_samples))[:, None] / n_samples)\n        u = (u % 1.0)  # ensure in [0,1)\n        xs = lower + u * span\n        for i in range(n_samples):\n            if evals_used >= budget:\n                break\n            x = xs[i]\n            y = eval_point(x)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = x, y\n\n    if evals_used >= budget or local_budget <= 0:\n        return best_x\n\n    # --- Local search: stochastic coordinate search with adaptive step ---\n    # Start step size as fraction of span, adapt to budget/dim\n    remaining = budget - evals_used\n    # Larger step when budget is small\n    base_frac = 0.25 if remaining < 20 else 0.15\n    step = base_frac * span\n    min_step = 1e-6 * np.maximum(span, 1.0)\n\n    # Limit number of local passes to avoid overspending budget in high dim\n    max_passes = max(1, min(20, remaining // (2 * dim + 1)))\n    passes = 0\n\n    while evals_used < budget and np.any(step > min_step) and passes < max_passes:\n        improved = False\n        # Randomize coordinate order for robustness\n        coords = np.arange(dim)\n        np.random.shuffle(coords)\n        for i in coords:\n            if evals_used >= budget:\n                break\n\n            # Try two directions and one random perturbation along this coordinate\n            directions = (-1.0, 1.0)\n            for direction in directions:\n                if evals_used >= budget:\n                    break\n                candidate = np.array(best_x, copy=True)\n                candidate[i] = candidate[i] + direction * step[i]\n                candidate = clamp(candidate)\n                y = eval_point(candidate)\n                evals_used += 1\n                if y < best_y:\n                    best_x, best_y = candidate, y\n                    improved = True\n\n            if evals_used >= budget:\n                break\n\n            # Randomized step within [-step[i], step[i]]\n            rnd_step = (2.0 * np.random.rand() - 1.0) * step[i]\n            candidate = np.array(best_x, copy=True)\n            candidate[i] = candidate[i] + rnd_step\n            candidate = clamp(candidate)\n            y = eval_point(candidate)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = candidate, y\n                improved = True\n\n        if not improved:\n            step *= 0.5\n        passes += 1\n\n    return best_x",
    "X": "4.4678016010778805e-07 -9.79820548708293e-09"
}