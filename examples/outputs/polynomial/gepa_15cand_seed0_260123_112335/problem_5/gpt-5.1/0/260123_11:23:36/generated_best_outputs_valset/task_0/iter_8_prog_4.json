{
    "score": 1.977182703459663e-48,
    "Input": "Csendes",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Hybrid global-local blackbox minimization with adaptive budget allocation.\n\n    Strategy:\n    - Careful initialization (uses prev_best_x if available, plus random starts)\n    - Global search with quasi-random exploration + focused refinement\n    - Local search via adaptive coordinate-wise stochastic search\n    - Automatically adapts to dimensionality and budget size\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", len(bounds)))\n    budget = int(config.get(\"budget\", 1))\n\n    if dim <= 0 or budget <= 0:\n        mid = bounds[:, 0] + 0.5 * (bounds[:, 1] - bounds[:, 0])\n        return np.asarray(mid, dtype=float)\n\n    lower = bounds[:, 0].astype(float)\n    upper = bounds[:, 1].astype(float)\n    span = upper - lower\n\n    # Handle zero-span dimensions robustly\n    fixed_mask = span <= 0.0\n    span_safe = span.copy()\n    span_safe[fixed_mask] = 1.0\n\n    def clamp(x):\n        return np.clip(x, lower, upper)\n\n    def eval_point(x):\n        return objective_function(x)\n\n    evals_used = 0\n    best_x = None\n    best_y = None\n\n    def update_best(x, y, bx, by):\n        if bx is None or y < by:\n            return np.array(x, copy=True), float(y)\n        return bx, by\n\n    # ---- Initialization: warm start + random starts ----\n    # 1) prev_best_x if compatible\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape[0] == dim:\n            x0 = clamp(x0)\n            y0 = eval_point(x0)\n            evals_used += 1\n            best_x, best_y = update_best(x0, y0, best_x, best_y)\n\n    # 2) Random initial points (proportional to budget, capped)\n    if evals_used < budget:\n        if budget < 30:\n            init_trials = min(budget - evals_used, 3)\n        else:\n            init_trials = min(max(3, budget // 40), 10)\n        for _ in range(init_trials):\n            if evals_used >= budget:\n                break\n            xr = np.random.uniform(lower, upper)\n            yr = eval_point(xr)\n            evals_used += 1\n            best_x, best_y = update_best(xr, yr, best_x, best_y)\n\n    if best_x is None:\n        # Should not happen, but guard anyway\n        x_mid = lower + 0.5 * span\n        x_mid = clamp(x_mid)\n        y_mid = eval_point(x_mid)\n        evals_used += 1\n        best_x, best_y = x_mid, y_mid\n\n    if evals_used >= budget:\n        return best_x\n\n    remaining = budget - evals_used\n\n    # ---- Budget split: global vs local ----\n    # More global search for higher dim or very small budget\n    if remaining < 40 or dim > 20:\n        global_frac = 0.7\n    else:\n        global_frac = 0.55\n\n    global_budget = max(1, int(global_frac * remaining))\n    global_budget = min(global_budget, remaining)\n    local_budget = remaining - global_budget\n\n    # ---- Quasi-random utilities ----\n    def van_der_corput(n, base=2):\n        seq = np.empty(n, dtype=float)\n        for i in range(n):\n            v = i\n            denom = 1.0\n            x = 0.0\n            while v > 0:\n                v, r = divmod(v, base)\n                denom *= base\n                x += r / denom\n            seq[i] = x\n        return seq\n\n    def quasi_random_points(n_points, dim_):\n        if n_points <= 0:\n            return np.empty((0, dim_), dtype=float)\n        base_sequence = van_der_corput(n_points + 8, 2)[8:]\n        pts = np.empty((n_points, dim_), dtype=float)\n        for d in range(dim_):\n            perm = np.random.permutation(n_points)\n            pts[:, d] = base_sequence[perm]\n        jitter = (np.random.rand(n_points, dim_) - 0.5) / (5.0 * max(n_points, 1))\n        u = np.clip(pts + jitter, 0.0, 1.0)\n        return lower + u * span_safe\n\n    # ---- Global search: exploration + refinement ----\n    n_global = global_budget\n    refine_budget = max(0, int(0.2 * n_global))\n    pure_explore_budget = max(0, n_global - refine_budget)\n\n    # 1) Pure exploration\n    if pure_explore_budget > 0 and evals_used < budget:\n        xs = quasi_random_points(pure_explore_budget, dim)\n        for i in range(pure_explore_budget):\n            if evals_used >= budget:\n                break\n            x = xs[i]\n            y = eval_point(x)\n            evals_used += 1\n            best_x, best_y = update_best(x, y, best_x, best_y)\n\n    # 2) Refinement around current best (Gaussian sampling)\n    if refine_budget > 0 and evals_used < budget and best_x is not None:\n        base_sigma = 0.15 * span_safe\n        base_sigma[fixed_mask] = 0.0\n        for _ in range(refine_budget):\n            if evals_used >= budget:\n                break\n            noise = np.random.randn(dim) * base_sigma\n            cand = clamp(best_x + noise)\n            y = eval_point(cand)\n            evals_used += 1\n            best_x, best_y = update_best(cand, y, best_x, best_y)\n\n    if evals_used >= budget or local_budget <= 0:\n        return best_x\n\n    # ---- Local search: adaptive coordinate-wise search ----\n    remaining = budget - evals_used\n\n    # Initial step size: depends on remaining budget\n    if remaining < 40:\n        step_frac = 0.25\n    else:\n        step_frac = 0.18\n    step = step_frac * span_safe\n    step[fixed_mask] = 0.0\n    min_step = 1e-8 * np.maximum(span_safe, 1.0)\n\n    # Number of iterations; each iteration ~ 2*dim + 1 evaluations\n    per_iter_cost = max(2 * dim + 1, 1)\n    max_iters = max(1, min(30, local_budget // per_iter_cost))\n\n    it = 0\n    while evals_used < budget and it < max_iters and np.any(step > min_step):\n        it += 1\n        improved = False\n\n        # Randomize coordinate order\n        order = np.arange(dim)\n        np.random.shuffle(order)\n\n        for j in order:\n            if evals_used >= budget:\n                break\n            if fixed_mask[j]:\n                continue\n\n            # +/- step\n            for direction in (-1.0, 1.0):\n                if evals_used >= budget:\n                    break\n                cand = np.array(best_x, copy=True)\n                cand[j] = cand[j] + direction * step[j]\n                cand = clamp(cand)\n                y = eval_point(cand)\n                evals_used += 1\n                if y < best_y:\n                    best_x, best_y = cand, y\n                    improved = True\n\n            if evals_used >= budget:\n                break\n\n            # Random within step range on this coordinate\n            rnd = (2.0 * np.random.rand() - 1.0) * step[j]\n            cand = np.array(best_x, copy=True)\n            cand[j] = cand[j] + rnd\n            cand = clamp(cand)\n            y = eval_point(cand)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = cand, y\n                improved = True\n\n        # Occasional full-dimensional Gaussian step to escape locals\n        if evals_used < budget:\n            full_noise = np.random.randn(dim) * (0.4 * step)\n            full_noise[fixed_mask] = 0.0\n            cand = clamp(best_x + full_noise)\n            y = eval_point(cand)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = cand, y\n                improved = True\n\n        # Adapt step size\n        if not improved:\n            step *= 0.5\n        else:\n            step *= 1.05\n        step = np.maximum(step, min_step)\n\n    return best_x",
    "X": "-5.443762191040011e-09 -1.0444130859424483e-08"
}