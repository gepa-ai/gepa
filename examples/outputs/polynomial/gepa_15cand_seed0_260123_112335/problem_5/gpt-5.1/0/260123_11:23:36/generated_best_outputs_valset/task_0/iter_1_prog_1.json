{
    "score": 1.4988824496965925e-38,
    "Input": "Csendes",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", len(bounds)))\n    budget = int(config.get(\"budget\", 1))\n\n    lower = bounds[:, 0]\n    upper = bounds[:, 1]\n    span = upper - lower\n\n    # Clamp any provided point to bounds\n    def clamp(x):\n        return np.clip(x, lower, upper)\n\n    # Safe evaluation wrapper\n    def eval_point(x):\n        return objective_function(x)\n\n    evals_used = 0\n\n    # Initialize best solution\n    if prev_best_x is not None:\n        x0 = clamp(np.asarray(prev_best_x, dtype=float))\n        y0 = eval_point(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n    else:\n        x0 = np.random.uniform(lower, upper)\n        y0 = eval_point(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if budget <= evals_used:\n        return best_x\n\n    # Global exploration: sample remaining budget fraction\n    # Split evaluations between global search and local search\n    # Use at least a few points for each when possible\n    remaining = budget - evals_used\n    global_budget = max(1, int(0.6 * remaining))\n    local_budget = remaining - global_budget\n\n    # Global random sampling\n    for _ in range(global_budget):\n        x = np.random.uniform(lower, upper)\n        y = eval_point(x)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = x, y\n\n    if local_budget <= 0:\n        return best_x\n\n    # Local coordinate search around current best\n    # Step size starts as a fraction of bounds span and shrinks\n    step = 0.2 * span\n    min_step = 1e-6 * np.maximum(span, 1.0)\n\n    while evals_used < budget and np.any(step > min_step):\n        improved = False\n        for i in range(dim):\n            if evals_used >= budget:\n                break\n\n            for direction in (-1.0, 1.0):\n                if evals_used >= budget:\n                    break\n                candidate = np.array(best_x, copy=True)\n                candidate[i] = candidate[i] + direction * step[i]\n                candidate = clamp(candidate)\n                y = eval_point(candidate)\n                evals_used += 1\n                if y < best_y:\n                    best_x, best_y = candidate, y\n                    improved = True\n\n        # If no improvement, shrink step sizes\n        if not improved:\n            step *= 0.5\n        # stop early if local budget effectively exhausted\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "4.4678016010778805e-07 2.1597490813021793e-07"
}