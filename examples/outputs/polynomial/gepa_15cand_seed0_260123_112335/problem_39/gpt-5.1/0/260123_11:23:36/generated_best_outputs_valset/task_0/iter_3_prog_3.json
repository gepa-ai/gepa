{
    "score": -0.01631851446945593,
    "Input": "Ned01",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    ranges = high - low\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # Safeguard for tiny or invalid budgets\n    if budget <= 0:\n        return (low + high) / 2.0\n\n    evals_used = 0\n    x_best = None\n    y_best = np.inf\n\n    # Helper: objective with hard guard against exceeding budget\n    def safe_eval(x):\n        nonlocal evals_used, x_best, y_best\n        if evals_used >= budget:\n            return None  # signal that no evaluation is allowed\n        try:\n            y = objective_function(x)\n        except Exception:\n            # If objective itself throws due to budget or other issues,\n            # stop evaluating further.\n            evals_used = budget\n            return None\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n        return y\n\n    # --- Initialize with prev_best_x if available ---\n    if prev_best_x is not None:\n        try:\n            x0 = clip(np.asarray(prev_best_x, dtype=float).reshape(dim))\n            y0 = safe_eval(x0)\n            if y0 is None:\n                # No budget left or objective failed\n                return x0 if x_best is None else x_best\n        except Exception:\n            pass\n\n    # If nothing evaluated yet, start from mid-point as baseline\n    if x_best is None:\n        x_mid = (low + high) / 2.0\n        y_mid = safe_eval(x_mid)\n        if y_mid is None:\n            return x_mid\n\n    if evals_used >= budget:\n        return x_best\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return x_best\n\n    # Always ensure at least one fresh random point (if budget allows)\n    if remaining > 0:\n        x0 = np.random.uniform(low, high, size=dim)\n        y0 = safe_eval(x0)\n        if y0 is None:\n            return x_best\n        remaining = budget - evals_used\n        if remaining <= 0:\n            return x_best\n\n    # --- Global exploration: Latin-hypercube-like random sampling ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return x_best\n\n    # Use ~40% of remaining for global, but adapt for small budgets\n    global_fraction = 0.4\n    if remaining < 10:\n        global_fraction = 0.7\n    global_evals = max(1, int(global_fraction * remaining))\n    global_evals = min(global_evals, remaining)\n\n    if global_evals > 0:\n        if global_evals >= dim:\n            base = (np.arange(global_evals) + np.random.rand(global_evals)) / global_evals\n            X = np.zeros((global_evals, dim), dtype=float)\n            for d in range(dim):\n                perm = np.random.permutation(global_evals)\n                X[:, d] = base[perm]\n            X = low + X * ranges\n        else:\n            X = np.random.uniform(low, high, size=(global_evals, dim))\n\n        for i in range(global_evals):\n            if evals_used >= budget:\n                break\n            x = X[i]\n            y = safe_eval(x)\n            if y is None:\n                break\n\n    if evals_used >= budget:\n        return x_best\n\n    # --- Local exploitation: CMA-ES\u2013like adaptive search around best ---\n    remaining = budget - evals_used\n    if remaining <= 0 or x_best is None:\n        return x_best\n\n    # Desired local evaluations based on original split\n    desired_local = remaining\n    if remaining >= 10:\n        # Recompute split to preserve ratio roughly: we already spent global_fraction\n        # of the original \"remaining\"; now use whatever is left as local.\n        pass  # desired_local already equals remaining\n\n    # Small population for local search\n    lambd = max(4, min(12, 2 * dim))\n    if lambd <= 0:\n        return x_best\n\n    # Ensure at least one generation if we have enough budget for population\n    max_generations = max(1, desired_local // lambd) if desired_local >= lambd else 1\n\n    sigma = 0.2 * np.maximum(ranges, 1e-8)\n    min_sigma = 1e-8 * np.maximum(ranges, 1.0)\n    max_sigma = ranges\n\n    center = x_best.copy()\n\n    # Precompute current center value once for comparison, but guarded\n    center_val = y_best\n\n    for _ in range(max_generations):\n        if evals_used >= budget:\n            break\n        remaining = budget - evals_used\n        if remaining <= 0:\n            break\n\n        pop_size = min(lambd, remaining)\n        if pop_size <= 0:\n            break\n\n        Z = np.random.randn(pop_size, dim)\n        X_pop = clip(center + Z * sigma)\n        Y_pop = np.full(pop_size, np.inf, dtype=float)\n\n        for i in range(pop_size):\n            if evals_used >= budget:\n                break\n            y = safe_eval(X_pop[i])\n            if y is None:\n                break\n            Y_pop[i] = y\n\n        if evals_used >= budget:\n            break\n\n        # Filter out unevaluated individuals (if early stop occurred)\n        mask = np.isfinite(Y_pop)\n        if not np.any(mask):\n            break\n\n        idx = np.argsort(Y_pop[mask])\n        k = max(1, idx.size // 2)\n        best_idx = np.where(mask)[0][idx[:k]]\n        new_center = np.mean(X_pop[best_idx], axis=0)\n\n        # Improvement check using stored center_val (no extra objective call)\n        if y_best < center_val:\n            center = 0.7 * center + 0.3 * new_center\n            sigma = np.minimum(sigma * 1.2, max_sigma)\n            center_val = y_best\n        else:\n            sigma = np.maximum(sigma * 0.7, min_sigma)\n\n    return x_best",
    "X": "5.408518042786345 -7.045457492295731"
}