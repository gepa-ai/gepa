{
    "score": -0.016053143712689913,
    "Input": "Ned01",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # Safeguard for tiny budgets\n    if budget <= 0:\n        # Return center of bounds if no evaluations allowed\n        return (low + high) / 2.0\n\n    # Initialize best solution\n    evals_used = 0\n\n    # Use prev_best_x if provided and feasible\n    if prev_best_x is not None:\n        x_best = clip(np.asarray(prev_best_x, dtype=float).reshape(dim))\n        y_best = objective_function(x_best)\n        evals_used += 1\n    else:\n        # Start from a random point\n        x_best = np.random.uniform(low, high, size=dim)\n        y_best = objective_function(x_best)\n        evals_used += 1\n\n    # If only one evaluation allowed, return immediately\n    if evals_used >= budget:\n        return x_best\n\n    # Allocate evaluations: fraction for global random search, rest for local search\n    remaining = budget - evals_used\n    global_evals = max(1, int(0.4 * remaining))\n    local_evals = remaining - global_evals\n\n    # --- Global exploration: random search ---\n    for _ in range(global_evals):\n        x = np.random.uniform(low, high, size=dim)\n        y = objective_function(x)\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n\n    if evals_used >= budget or local_evals <= 0:\n        return x_best\n\n    # --- Local exploitation: adaptive random search around best ---\n    # Initial step size as fraction of range\n    ranges = high - low\n    step = 0.25 * ranges\n    min_step = 1e-6 * ranges\n\n    # Simple hill-climbing with step-size adaptation\n    for _ in range(local_evals):\n        # Propose local perturbation\n        noise = np.random.normal(loc=0.0, scale=1.0, size=dim)\n        # Scale by current step (ensure non-zero)\n        proposal = x_best + noise * np.maximum(step, min_step)\n        proposal = clip(proposal)\n\n        y = objective_function(proposal)\n        evals_used += 1\n\n        if y < y_best:\n            # Improvement: move and slightly enlarge step\n            x_best, y_best = proposal, y\n            step *= 1.1\n        else:\n            # No improvement: shrink step\n            step *= 0.7\n\n        if evals_used >= budget:\n            break\n\n    return x_best",
    "X": "5.408517395843535 -7.045451460985116"
}