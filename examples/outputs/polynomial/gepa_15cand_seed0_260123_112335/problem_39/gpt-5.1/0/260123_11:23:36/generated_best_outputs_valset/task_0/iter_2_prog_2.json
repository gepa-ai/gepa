{
    "score": -0.016315008140950958,
    "Input": "Ned01",
    "Prints": "",
    "Logs": "",
    "Error": "Evaluation budget exceeded: 571 >= 571\nTraceback (most recent call last):\n  File \"/data/lukedhlee/gepa_luke/external/gepa-optimize-anything/src/gepa/utils/code_execution.py\", line 312, in _execute_in_process\n    result = context[entry_point](*entry_point_args, **kwargs)\n             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 118, in solve\n  File \"/data/lukedhlee/gepa_luke/experiments/polynomial/gepa/evaluator.py\", line 57, in objective_function\n    raise ValueError(f\"Evaluation budget exceeded: {eval_count} >= {self.evaluation_budget}\")\nValueError: Evaluation budget exceeded: 571 >= 571\n\nCode did not return a valid numpy array.",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    ranges = high - low\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # Safeguard for tiny budgets\n    if budget <= 0:\n        return (low + high) / 2.0\n\n    # --- Initialization ---\n    evals_used = 0\n    x_best = None\n    y_best = None\n\n    # Evaluate prev_best_x if provided\n    if prev_best_x is not None:\n        try:\n            x0 = clip(np.asarray(prev_best_x, dtype=float).reshape(dim))\n            y0 = objective_function(x0)\n            evals_used += 1\n            x_best, y_best = x0, y0\n        except Exception:\n            x_best, y_best = None, None\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return x_best if x_best is not None else (low + high) / 2.0\n\n    # Always ensure at least one fresh random point\n    x0 = np.random.uniform(low, high, size=dim)\n    y0 = objective_function(x0)\n    evals_used += 1\n    if (y_best is None) or (y0 < y_best):\n        x_best, y_best = x0, y0\n\n    if evals_used >= budget:\n        return x_best\n\n    remaining = budget - evals_used\n\n    # --- Global exploration: Latin-hypercube-like random sampling ---\n    # Use ~40% of remaining for global, but adapt for small budgets\n    global_fraction = 0.4\n    if remaining < 10:\n        global_fraction = 0.7\n    global_evals = max(1, int(global_fraction * remaining))\n    global_evals = min(global_evals, remaining)\n    local_evals = remaining - global_evals\n\n    # Generate stratified samples when possible\n    if global_evals > 0:\n        if global_evals >= dim:\n            # Latin-hypercube style: stratify each dimension into global_evals intervals\n            base = (np.arange(global_evals) + np.random.rand(global_evals)) / global_evals\n            X = np.zeros((global_evals, dim), dtype=float)\n            for d in range(dim):\n                perm = np.random.permutation(global_evals)\n                X[:, d] = base[perm]\n            X = low + X * ranges\n        else:\n            # Fallback: purely random if too few points\n            X = np.random.uniform(low, high, size=(global_evals, dim))\n\n        for i in range(global_evals):\n            x = X[i]\n            y = objective_function(x)\n            evals_used += 1\n            if y < y_best:\n                x_best, y_best = x, y\n            if evals_used >= budget:\n                return x_best\n\n    # --- Local exploitation: CMA-ES\u2013like adaptive search around best ---\n    if local_evals <= 0 or evals_used >= budget:\n        return x_best\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return x_best\n\n    # Set small population for local search\n    lambd = max(4, min(12, 2 * dim))\n    # Use at most remaining evaluations\n    max_generations = max(1, remaining // lambd)\n\n    # Initial step size relative to bounds, clipped to avoid degeneration\n    sigma = 0.2 * np.maximum(ranges, 1e-8)\n    min_sigma = 1e-8 * np.maximum(ranges, 1.0)\n    max_sigma = ranges\n\n    center = x_best.copy()\n\n    for _ in range(max_generations):\n        # Ensure not to exceed budget\n        if evals_used >= budget:\n            break\n        # Adjust population if near budget end\n        remaining = budget - evals_used\n        if remaining <= 0:\n            break\n        pop_size = min(lambd, remaining)\n\n        # Sample population\n        Z = np.random.randn(pop_size, dim)\n        X_pop = clip(center + Z * sigma)\n        Y_pop = np.empty(pop_size, dtype=float)\n\n        for i in range(pop_size):\n            Y_pop[i] = objective_function(X_pop[i])\n            evals_used += 1\n            if Y_pop[i] < y_best:\n                y_best = Y_pop[i]\n                x_best = X_pop[i]\n            if evals_used >= budget:\n                break\n\n        if evals_used >= budget:\n            break\n\n        # Select best half to adapt center and sigma\n        idx = np.argsort(Y_pop)\n        k = max(1, pop_size // 2)\n        best_idx = idx[:k]\n        new_center = np.mean(X_pop[best_idx], axis=0)\n\n        # Improvement check\n        if y_best < objective_function(center):\n            # Move center towards best\n            center = 0.7 * center + 0.3 * new_center\n            sigma = np.minimum(sigma * 1.2, max_sigma)\n        else:\n            # No clear improvement: shrink step size\n            sigma = np.maximum(sigma * 0.7, min_sigma)\n\n    return x_best",
    "X": "not found"
}