{
    "score": 0.5356702702337075,
    "Input": "McCourt17",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple budget-aware blackbox minimizer using random search +\n    local refinement around the best point (including warm start if provided).\n    \"\"\"\n    rng = np.random\n\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    # Initialize best candidate\n    best_x = None\n    best_y = np.inf\n\n    # Warm start if possible\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # If still no best, sample one random point\n    if best_x is None and evals_used < budget:\n        x0 = rng.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if evals_used >= budget:\n        return np.asarray(best_x, dtype=float)\n\n    # Split remaining budget between global random search and local search\n    remaining = budget - evals_used\n    # Emphasize global search when budget is small\n    global_frac = 0.6 if remaining > 20 else 0.4\n    n_global = max(1, int(remaining * global_frac))\n    n_local = max(0, remaining - n_global)\n\n    # --- Global random search ---\n    # Sample candidates in a mildly quasi-random way: use batches\n    batch_size = min(16, n_global)\n    n_batches = (n_global + batch_size - 1) // batch_size\n\n    for _ in range(n_batches):\n        if evals_used >= budget:\n            break\n        m = min(batch_size, n_global - (evals_used - (budget - remaining)))\n        xs = rng.uniform(low, high, size=(m, dim))\n        for x in xs:\n            if evals_used >= budget:\n                break\n            y = objective_function(x)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = x.copy()\n\n    if evals_used >= budget:\n        return np.asarray(best_x, dtype=float)\n\n    # --- Local search around best_x ---\n    # Gaussian perturbations with decreasing scale\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return np.asarray(best_x, dtype=float)\n\n    # Number of local \"iterations\"\n    iters = min(10, remaining)\n    evals_per_iter = max(1, remaining // iters)\n\n    # Initial step size ~ span / 4\n    base_sigma = span / 4.0\n    base_sigma[base_sigma == 0] = 1.0  # safeguard for zero-width bounds\n\n    current_x = best_x.copy()\n    current_y = best_y\n\n    for i in range(iters):\n        if evals_used >= budget:\n            break\n        # Exponentially decay step size\n        frac = (i + 1) / iters\n        sigma = base_sigma * (0.5 ** frac)\n\n        for _ in range(evals_per_iter):\n            if evals_used >= budget:\n                break\n            candidate = current_x + rng.normal(scale=sigma, size=dim)\n            candidate = clip(candidate)\n            y = objective_function(candidate)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = candidate.copy()\n                current_x, current_y = best_x, best_y\n\n    return np.asarray(best_x, dtype=float)",
    "X": "0.28327472012634436 0.9423395532029082 0.3234932416266778 0.6584159345152817 0.0 0.8662309308533417 0.6868707765235967"
}