{
    "score": -0.9,
    "Input": "McCourt16",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization with a simple budget-aware strategy:\n    - Global random / quasi-random search over the bounds\n    - Optional warm start from prev_best_x\n    - Local refinement around current best with Gaussian perturbations\n    \"\"\"\n    rng = np.random.RandomState()  # independent RNG\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Handle degenerate spans (zero-width bounds)\n    span[span == 0.0] = 1.0\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # Warm start if possible (and inside bounds)\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    if evals_used >= budget:\n        if best_x is None:\n            # Fallback: any valid point (no objective call left)\n            best_x = (low + high) * 0.5\n        return best_x\n\n    # Heuristic split of budget: more global if budget small\n    # and allow some local refinement if budget is larger.\n    if budget <= 10:\n        global_evals = budget - evals_used\n        local_evals = 0\n    else:\n        global_evals = int(0.7 * (budget - evals_used))\n        local_evals = (budget - evals_used) - global_evals\n\n    # Ensure at least one global evaluation\n    if global_evals <= 0 and evals_used < budget:\n        global_evals = 1\n        local_evals = max(0, budget - evals_used - global_evals)\n\n    # Global search: random sampling in the box\n    for _ in range(global_evals):\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y or best_x is None:\n            best_x, best_y = x, y\n        if evals_used >= budget:\n            return best_x\n\n    # Local refinement around best found so far\n    if best_x is None:\n        # If no evaluations succeeded for some reason, return a random point\n        best_x = rng.uniform(low, high)\n        return best_x\n\n    # Adaptive step size for perturbation (start fairly broad)\n    base_sigma = 0.25 * span\n    base_sigma[base_sigma == 0.0] = 0.1  # safety\n\n    for i in range(local_evals):\n        # Gradually decrease exploration scale\n        frac = 1.0 - (i / max(1, local_evals))\n        sigma = base_sigma * (0.1 + 0.9 * frac)\n\n        noise = rng.normal(0.0, sigma, size=dim)\n        x_candidate = clip(best_x + noise)\n        y_candidate = objective_function(x_candidate)\n        evals_used += 1\n\n        if y_candidate < best_y:\n            best_x, best_y = x_candidate, y_candidate\n\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "0.16306765190246253 0.6183054709594512 0.23439302016210342 0.45003497248860796"
}