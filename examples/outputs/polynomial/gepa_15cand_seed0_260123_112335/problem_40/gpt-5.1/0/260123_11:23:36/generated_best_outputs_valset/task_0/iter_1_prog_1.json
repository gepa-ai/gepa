{
    "score": -1.0052263897328266,
    "Input": "OddSquare",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple budget-aware optimizer: random search with optional local refinement.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Safety checks\n    if budget <= 0:\n        # Return midpoint if no evaluations allowed\n        return (low + high) / 2.0\n\n    rng = np.random.default_rng()\n\n    evals_used = 0\n\n    # Initialize best solution\n    if prev_best_x is not None:\n        x_best = np.clip(np.asarray(prev_best_x, dtype=float), low, high)\n    else:\n        x_best = rng.uniform(low, high)\n\n    y_best = objective_function(x_best)\n    evals_used += 1\n\n    # If only one evaluation is allowed, we're done\n    if budget == 1:\n        return x_best\n\n    # Global random search phase\n    # Use about 60% of budget for global exploration\n    global_budget = max(1, int(0.6 * (budget - evals_used)))\n    for _ in range(global_budget):\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n        if evals_used >= budget:\n            return x_best\n\n    # Local refinement around current best\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return x_best\n\n    # Adaptive local search: gradually shrink step size\n    base_step = 0.25  # fraction of span\n    for i in range(remaining):\n        frac = base_step * (1.0 - 0.8 * (i / max(1, remaining - 1)))\n        step = frac * span\n        noise = rng.normal(loc=0.0, scale=1.0, size=dim)\n        x_candidate = x_best + noise * step\n        x_candidate = np.clip(x_candidate, low, high)\n\n        y = objective_function(x_candidate)\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x_candidate, y\n        if evals_used >= budget:\n            break\n\n    return x_best",
    "X": "0.9212978307784788 1.2477356651801212"
}