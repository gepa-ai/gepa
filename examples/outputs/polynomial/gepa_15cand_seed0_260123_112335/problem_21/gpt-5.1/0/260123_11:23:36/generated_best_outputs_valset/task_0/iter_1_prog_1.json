{
    "score": -2.5193872887037347,
    "Input": "McCourt10",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple hybrid global-local search using random sampling + Nelder-Mead-like pattern search.\n    Uses full budget of objective evaluations and supports warm-start via prev_best_x.\n    \"\"\"\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n\n    # Utility: project to bounds\n    def clip_to_bounds(x):\n        return np.minimum(np.maximum(x, low), high)\n\n    evals_used = 0\n\n    # Initialize best solution\n    if prev_best_x is not None:\n        x0 = clip_to_bounds(np.asarray(prev_best_x, dtype=float))\n    else:\n        x0 = np.random.uniform(low, high)\n\n    best_x = x0\n    best_y = objective_function(best_x)\n    evals_used += 1\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # --- Global random search phase ---\n    # Use about half budget for global exploration (at least dim+3 points)\n    global_evals = max(dim + 3, remaining // 2)\n    for _ in range(global_evals):\n        x = np.random.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y = y\n            best_x = x\n        if evals_used >= budget:\n            return best_x\n\n    # --- Local search phase (pattern search / coordinate search) ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    x = best_x.copy()\n    y = best_y\n\n    # Initial step size: fraction of span per dimension\n    # Decrease adaptively when no improvement is found\n    step = 0.25 * span\n    step[step == 0] = 0.25  # fallback if any dimension has zero span\n\n    # Local search loop: each \"iteration\" tries 2*dim moves at most\n    while evals_used < budget:\n        improved = False\n        # For each dimension, try positive and negative moves\n        for i in range(dim):\n            if evals_used >= budget:\n                break\n\n            # Positive direction\n            xp = x.copy()\n            xp[i] = xp[i] + step[i]\n            xp = clip_to_bounds(xp)\n            yp = objective_function(xp)\n            evals_used += 1\n            if yp < y:\n                x, y = xp, yp\n                improved = True\n                if y < best_y:\n                    best_x, best_y = x, y\n                if evals_used >= budget:\n                    break\n                continue  # skip negative direction if already improved\n\n            if evals_used >= budget:\n                break\n\n            # Negative direction\n            xn = x.copy()\n            xn[i] = xn[i] - step[i]\n            xn = clip_to_bounds(xn)\n            yn = objective_function(xn)\n            evals_used += 1\n            if yn < y:\n                x, y = xn, yn\n                improved = True\n                if y < best_y:\n                    best_x, best_y = x, y\n            if evals_used >= budget:\n                break\n\n        if not improved:\n            # Reduce step size when stuck; terminate if steps become too small\n            step *= 0.5\n            if np.all(step < 1e-6 * np.maximum(span, 1.0)):\n                break\n\n    return best_x",
    "X": "0.5080342046703518 0.5436202205499269 0.22819689006402988 1.0 0.3373106660564512 0.025390625 1.0 0.5029515054680963"
}