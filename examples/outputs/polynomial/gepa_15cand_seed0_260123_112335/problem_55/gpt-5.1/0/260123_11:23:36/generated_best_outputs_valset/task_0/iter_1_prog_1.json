{
    "score": 0.9669414774880922,
    "Input": "Xor",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization with a simple hybrid global-local search.\n\n    Strategy:\n    1. Global exploration via random sampling / local random walks.\n    2. Intensification around the current best.\n    3. Uses full budget and optionally warm-starts from prev_best_x.\n    \"\"\"\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Utility to project inside bounds\n    def clip_to_bounds(x):\n        return np.clip(x, low, high)\n\n    # Handle degenerate budget\n    if budget <= 0:\n        # Return something valid in bounds\n        if prev_best_x is not None:\n            return clip_to_bounds(np.asarray(prev_best_x, dtype=float)).reshape(dim)\n        return np.random.uniform(low, high, size=dim)\n\n    evals_used = 0\n\n    # --- Initialization ---\n    candidates = []\n\n    # Warm start from prev_best_x if available\n    if prev_best_x is not None:\n        x0 = clip_to_bounds(np.asarray(prev_best_x, dtype=float).reshape(dim))\n        candidates.append(x0)\n\n    # Always add at least one random point\n    x_rand = np.random.uniform(low, high, size=dim)\n    candidates.append(x_rand)\n\n    # Optionally add more diverse initial points if budget allows\n    init_count = min(len(candidates) + max(0, budget // 10), budget)  # ~10% for init\n    while len(candidates) < init_count:\n        candidates.append(np.random.uniform(low, high, size=dim))\n\n    # Evaluate initial candidates\n    best_x = None\n    best_y = np.inf\n    for x in candidates:\n        if evals_used >= budget:\n            break\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y = y\n            best_x = x\n\n    # If we exhausted budget already, return best found\n    if evals_used >= budget:\n        return best_x.reshape(dim)\n\n    # --- Main search loop ---\n    # Budget split:\n    #   - 60% local search around best\n    #   - 40% global exploration\n    remaining = budget - evals_used\n    local_budget = int(0.6 * remaining)\n    global_budget = remaining - local_budget\n\n    # Local search: adaptive random perturbations around current best\n    # Step sizes start as a fraction of bounds and shrink over time\n    if local_budget > 0:\n        # Minimum step scale to keep searching at the end\n        min_scale = 0.01\n        max_scale = 0.25\n        for i in range(local_budget):\n            if evals_used >= budget:\n                break\n            # Linearly decreasing scale\n            t = i / max(1, local_budget - 1)\n            scale = max_scale * (1 - t) + min_scale * t\n            step = np.random.normal(loc=0.0, scale=scale * span, size=dim)\n            x_new = clip_to_bounds(best_x + step)\n            y_new = objective_function(x_new)\n            evals_used += 1\n            if y_new < best_y:\n                best_y = y_new\n                best_x = x_new\n\n    # Global exploration: random sampling plus biased sampling around best\n    remaining = budget - evals_used\n    if remaining > 0:\n        for i in range(remaining):\n            if evals_used >= budget:\n                break\n            # Mix pure random and around-best sampling\n            if np.random.rand() < 0.5 or best_x is None:\n                x_new = np.random.uniform(low, high, size=dim)\n            else:\n                # Broad perturbation around best\n                scale = 0.5  # larger radius than local search\n                step = np.random.normal(loc=0.0, scale=scale * span, size=dim)\n                x_new = clip_to_bounds(best_x + step)\n            y_new = objective_function(x_new)\n            evals_used += 1\n            if y_new < best_y:\n                best_y = y_new\n                best_x = x_new\n\n    return best_x.reshape(dim)",
    "X": "1.0 1.0 1.0 -0.8428316500349151 0.6431590392667003 1.0 0.9948889106931862 -1.0 -0.04842403957235929"
}