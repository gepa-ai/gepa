{
    "score": -6.00767875523974,
    "Input": "Michalewicz",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config.get('dim', bounds.shape[0]))\n    budget = int(config.get('budget', 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n    # Avoid zeros in span: if bound is fixed, perturb in relative coordinates later\n    span_safe = span.copy()\n    span_safe[span_safe == 0.0] = 1.0\n\n    def clamp(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    def eval_point(x):\n        nonlocal evals_used\n        if evals_used >= budget:\n            return np.inf\n        fx = objective_function(x)\n        evals_used += 1\n        return fx\n\n    best_x = None\n    best_y = np.inf\n\n    # Use prev_best_x if valid\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clamp(x0)\n            y0 = eval_point(x0)\n            if y0 < best_y:\n                best_x, best_y = x0, y0\n\n    # If nothing evaluated yet, sample a first random point\n    if best_x is None and evals_used < budget:\n        x0 = np.random.uniform(low, high)\n        y0 = eval_point(x0)\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Very small remaining budget: perform purely local search around best_x\n    if remaining <= 5:\n        base_step = 0.25 * span_safe\n        for _ in range(remaining):\n            if evals_used >= budget:\n                break\n            step = base_step * np.exp(np.random.uniform(-1.5, 0.0, size=dim))\n            # use Cauchy perturbation for better tails\n            perturb = np.random.standard_cauchy(size=dim) * step\n            candidate = clamp(best_x + perturb)\n            y = eval_point(candidate)\n            if y < best_y:\n                best_x, best_y = candidate, y\n        return best_x\n\n    # Global seeding: mix of uniform and local samples\n    remaining = budget - evals_used\n    n_seed = max(3, min(15, remaining // 8))\n    for i in range(n_seed):\n        if evals_used >= budget:\n            break\n        if i == 0 and best_x is not None:\n            # a small local perturbation around current best\n            step = 0.2 * span_safe\n            perturb = np.random.uniform(-1.0, 1.0, size=dim) * step\n            x = clamp(best_x + perturb)\n        else:\n            x = np.random.uniform(low, high)\n        y = eval_point(x)\n        if y < best_y:\n            best_x, best_y = x, y\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Evolution Strategy with adaptive covariance (diagonal) and step-size\n    lam = max(4, int(4 + 3 * np.log(dim + 1)))  # population size\n    mu = max(2, lam // 2)\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1.0 / np.sum(weights ** 2)\n\n    mean = best_x.copy()\n    # Initial step-size relative to domain\n    sigma = 0.3 * np.mean(span_safe)\n    if not np.isfinite(sigma) or sigma <= 0:\n        sigma = 0.3\n\n    # Start with diagonal covariance aligned to bounds\n    cov_diag = (0.3 * span_safe) ** 2\n    cov_diag = np.maximum(cov_diag, 1e-30)\n    cov = np.diag(cov_diag)\n\n    pc = np.zeros(dim)\n    ps = np.zeros(dim)\n\n    cc = (4 + mueff / dim) / (dim + 4 + 2 * mueff / dim)\n    cs = (mueff + 2) / (dim + mueff + 5)\n    c1 = 2 / ((dim + 1.3) ** 2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1 / mueff) / ((dim + 2) ** 2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1) / (dim + 1)) - 1) + cs\n\n    # Decomposition cache: for diagonal covariance this is simple\n    def sample_population(m, s, C_diag, size):\n        # C_diag is 1D: diagonal of covariance\n        std = np.sqrt(np.maximum(C_diag, 1e-30))\n        z = np.random.randn(size, dim) * std\n        return m + s * z\n\n    max_generations = max(1, remaining // lam)\n\n    for _ in range(max_generations):\n        if evals_used >= budget:\n            break\n\n        C_diag = np.diag(cov)\n        pop = sample_population(mean, sigma, C_diag, lam)\n        pop = clamp(pop)\n\n        fitness = np.empty(lam)\n        for i in range(lam):\n            if evals_used >= budget:\n                fitness[i] = np.inf\n            else:\n                fitness[i] = eval_point(pop[i])\n\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < best_y:\n            best_x, best_y = pop[idx_best].copy(), fitness[idx_best]\n\n        valid_mask = np.isfinite(fitness)\n        if not np.any(valid_mask):\n            break\n\n        # Sort valid individuals\n        idx = np.argsort(fitness[valid_mask])\n        valid_pop = pop[valid_mask][idx]\n        max_parents = min(mu, valid_pop.shape[0])\n        parents = valid_pop[:max_parents]\n        w = weights[:max_parents]\n        w /= np.sum(w)\n\n        old_mean = mean.copy()\n        mean = np.sum(parents * w[:, None], axis=0)\n\n        # Update evolution paths\n        y = (mean - old_mean) / max(1e-12, sigma)\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * y\n\n        norm_ps = np.linalg.norm(ps)\n        expected_norm = np.sqrt(dim) * (1 - 1 / (4 * dim) + 1 / (21 * dim ** 2))\n        hsig = int(\n            norm_ps /\n            np.sqrt(1 - (1 - cs) ** (2 * (evals_used / max(1, lam) + 1))) /\n            (1.4 + 2 / (dim + 1))\n            < 2 + 4 / (dim + 1)\n        )\n\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * (mean - old_mean)\n\n        # Covariance update (diagonal)\n        diff = parents - old_mean\n        C_mu = np.sum(w[:, None] * (diff ** 2), axis=0)\n        C_diag = np.diag(cov)\n        C_diag = (\n            (1 - c1 - cmu) * C_diag\n            + c1 * (pc ** 2)\n            + cmu * C_mu\n        )\n        C_diag = np.maximum(C_diag, 1e-30)\n        cov = np.diag(C_diag)\n\n        # Step size adaptation\n        sigma *= np.exp((cs / damps) * (norm_ps / expected_norm - 1))\n\n        # Clamp sigma relative to domain\n        avg_span = float(np.mean(span_safe))\n        if not np.isfinite(avg_span) or avg_span <= 0:\n            avg_span = 1.0\n        sigma = float(np.clip(sigma, 1e-6 * avg_span, 0.5 * avg_span))\n\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "2.228291306302148 1.580753887088767 1.295114680395588 1.2930413590001 1.7202626469865976 0.9147437728664878 2.517336762928184 2.077252724705592"
}