{
    "score": -5.885427027890231,
    "Input": "Michalewicz",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config.get('dim', bounds.shape[0]))\n    budget = int(config.get('budget', 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n    span[span == 0.0] = 1.0  # avoid zeros in step size computations\n\n    def clamp(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    def eval_point(x):\n        nonlocal evals_used\n        if evals_used >= budget:\n            return np.inf\n        fx = objective_function(x)\n        evals_used += 1\n        return fx\n\n    best_x = None\n    best_y = np.inf\n\n    # Use prev_best_x if valid\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clamp(x0)\n            y0 = eval_point(x0)\n            if y0 < best_y:\n                best_x, best_y = x0, y0\n\n    # If nothing evaluated yet, sample a first random point\n    if best_x is None and evals_used < budget:\n        x0 = np.random.uniform(low, high)\n        y0 = eval_point(x0)\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # If very small budget left, just do simple local sampling\n    if remaining <= 5:\n        base_step = 0.3 * span\n        for _ in range(remaining):\n            if evals_used >= budget:\n                break\n            step = base_step * np.random.uniform(0.5, 1.0, size=dim)\n            candidate = best_x + np.random.normal(0.0, step)\n            candidate = clamp(candidate)\n            y = eval_point(candidate)\n            if y < best_y:\n                best_x, best_y = candidate, y\n        return best_x\n\n    # Larger budgets: use a simple CMA-ES\u2013like strategy with global seeding\n    # Allocate a few global random samples to diversify start point\n    n_seed = max(3, min(10, remaining // 10))\n    for _ in range(n_seed):\n        if evals_used >= budget:\n            break\n        x = np.random.uniform(low, high)\n        y = eval_point(x)\n        if y < best_y:\n            best_x, best_y = x, y\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # CMA-ES\u2013like parameters\n    lam = max(4, int(4 + 3 * np.log(dim + 1)))  # population size\n    mu = max(2, lam // 2)\n    weights = np.log(mu + 0.5) - np.log(np.arange(1, mu + 1))\n    weights /= np.sum(weights)\n    mueff = 1.0 / np.sum(weights ** 2)\n\n    # Initialize mean and covariance\n    mean = best_x.copy()\n    sigma = 0.3  # global scale of step size\n    cov = np.diag((0.4 * span) ** 2)\n\n    # Evolution paths\n    pc = np.zeros(dim)\n    ps = np.zeros(dim)\n\n    # Strategy parameters for adaptation\n    cc = (4 + mueff / dim) / (dim + 4 + 2 * mueff / dim)\n    cs = (mueff + 2) / (dim + mueff + 5)\n    c1 = 2 / ((dim + 1.3) ** 2 + mueff)\n    cmu = min(1 - c1, 2 * (mueff - 2 + 1 / mueff) / ((dim + 2) ** 2 + mueff))\n    damps = 1 + 2 * max(0, np.sqrt((mueff - 1) / (dim + 1)) - 1) + cs\n\n    # Decomposition cache\n    def sample_population(m, s, C):\n        # Robust sampling: ensure positive semidefinite via jitter if needed\n        for _ in range(3):\n            try:\n                B, D = np.linalg.eigh(C)\n                if np.any(B < 0):\n                    B = np.maximum(B, 1e-30)\n                B = np.sqrt(B)\n                A = (np.eye(dim) * B)  # diagonal since C is often diagonal-like\n                z = np.random.randn(lam, dim)\n                y = z @ A.T\n                return m + s * y\n            except np.linalg.LinAlgError:\n                # Add jitter and retry\n                C.flat[:: dim + 1] += 1e-8\n        # Fall back to diagonal covariance\n        diag = np.maximum(np.diag(C), 1e-30)\n        z = np.random.randn(lam, dim) * np.sqrt(diag)\n        return m + s * z\n\n    # Number of generations limited by remaining evaluations\n    max_generations = max(1, remaining // lam)\n\n    for _ in range(max_generations):\n        if evals_used >= budget:\n            break\n\n        pop = sample_population(mean, sigma, cov)\n        # Clamp to bounds\n        pop = np.clip(pop, low, high)\n\n        # Evaluate population\n        fitness = np.empty(lam)\n        for i in range(lam):\n            if evals_used >= budget:\n                fitness[i] = np.inf\n            else:\n                fitness[i] = eval_point(pop[i])\n        # Update best\n        idx_best = np.argmin(fitness)\n        if fitness[idx_best] < best_y:\n            best_x, best_y = pop[idx_best].copy(), fitness[idx_best]\n\n        # Remove any not-evaluated individuals if budget exhausted\n        valid_mask = np.isfinite(fitness)\n        if not np.any(valid_mask):\n            break\n\n        # Select parents\n        idx = np.argsort(fitness[valid_mask])\n        valid_pop = pop[valid_mask][idx]\n        mu_eff = min(mu, valid_pop.shape[0])\n        parents = valid_pop[:mu_eff]\n        w = weights[:mu_eff]\n        w /= np.sum(w)\n\n        old_mean = mean.copy()\n        mean = np.sum(parents * w[:, None], axis=0)\n\n        # Update evolution paths (using diagonal covariance approximation)\n        y = (mean - old_mean) / max(1e-12, sigma)\n        ps = (1 - cs) * ps + np.sqrt(cs * (2 - cs) * mueff) * y\n        hsig = int(\n            np.linalg.norm(ps) /\n            np.sqrt(1 - (1 - cs) ** (2 * (evals_used / lam + 1))) /\n            (1.4 + 2 / (dim + 1))\n            < 2 + 4 / (dim + 1)\n        )\n        pc = (1 - cc) * pc + hsig * np.sqrt(cc * (2 - cc) * mueff) * (mean - old_mean)\n\n        # Covariance update (rank-1 + rank-mu, diagonal approx for stability)\n        # Use only diagonal of full update for robustness in blackbox setting\n        diff = parents - old_mean\n        C_mu = np.sum(w[:, None] * (diff ** 2), axis=0)\n        cov_diag = np.diag(cov)\n        cov_diag = (\n            (1 - c1 - cmu) * cov_diag\n            + c1 * (pc ** 2)\n            + cmu * C_mu\n        )\n        cov = np.diag(np.maximum(cov_diag, 1e-30))\n\n        # Step size control\n        norm_ps = np.linalg.norm(ps)\n        expected_norm = np.sqrt(dim) * (1 - 1 / (4 * dim) + 1 / (21 * dim ** 2))\n        sigma *= np.exp((cs / damps) * (norm_ps / expected_norm - 1))\n\n        # Ensure sigma not too small or too large relative to box\n        avg_span = np.mean(span)\n        sigma = float(np.clip(sigma, 1e-3, 0.5 * avg_span))\n\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "2.2129129209545426 0.9235154255754566 2.222165417229778 1.116399123962014 2.220429896549568 2.027280817243273 1.4552769727802843 0.7878467761109181"
}