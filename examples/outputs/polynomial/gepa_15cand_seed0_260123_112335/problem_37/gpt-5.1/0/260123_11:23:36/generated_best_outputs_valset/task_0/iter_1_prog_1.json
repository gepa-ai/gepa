{
    "score": -3.295647024394519,
    "Input": "Michalewicz",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config.get('dim', bounds.shape[0]))\n    budget = int(config.get('budget', 1))\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    def clamp(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    # Helper: evaluate point with budget check\n    def eval_point(x):\n        nonlocal evals_used\n        if evals_used >= budget:\n            return np.inf\n        fx = objective_function(x)\n        evals_used += 1\n        return fx\n\n    # Initialization\n    best_x = None\n    best_y = np.inf\n\n    # Use prev_best_x if valid\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clamp(x0)\n            y0 = eval_point(x0)\n            if y0 < best_y:\n                best_x, best_y = x0, y0\n\n    # If nothing evaluated yet, sample a random point\n    if best_x is None and evals_used < budget:\n        x0 = np.random.uniform(low, high)\n        y0 = eval_point(x0)\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Split remaining budget between global sampling and local search\n    # Ensure at least some global and some local evaluations when possible\n    if remaining <= 5:\n        n_global = remaining\n        n_local = 0\n    else:\n        n_global = max(remaining // 2, 3)\n        n_local = remaining - n_global\n\n    # Global exploration: low-discrepancy random sampling\n    for _ in range(n_global):\n        if evals_used >= budget:\n            break\n        x = np.random.uniform(low, high)\n        y = eval_point(x)\n        if y < best_y:\n            best_x, best_y = x, y\n\n    remaining = budget - evals_used\n    if remaining <= 0 or n_local <= 0:\n        return best_x\n\n    # Local search around best_x using adaptive Gaussian steps\n    # Step size scaled to box size; shrink over iterations\n    base_step = 0.2 * span\n    base_step[base_step == 0.0] = 1.0  # fallback if degenerate bounds\n\n    for i in range(remaining):\n        if evals_used >= budget:\n            break\n        # Exponential schedule to reduce step size\n        frac = (i + 1) / max(1, remaining)\n        step_scale = (0.5 ** frac)  # from 1.0 to ~0.5\n        step = base_step * step_scale\n\n        candidate = best_x + np.random.normal(loc=0.0, scale=step)\n        candidate = clamp(candidate)\n        y = eval_point(candidate)\n        if y < best_y:\n            best_x, best_y = candidate, y\n\n    return best_x",
    "X": "2.0067292443367943 1.5403396747333102 3.1083224877066833 0.2051592174365387 2.460603557445203 0.9060306005229568 0.7584389632723502 2.081319494896708"
}