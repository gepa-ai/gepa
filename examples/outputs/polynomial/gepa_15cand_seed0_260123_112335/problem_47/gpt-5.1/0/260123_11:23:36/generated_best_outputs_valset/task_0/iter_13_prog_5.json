{
    "score": 2.9404128003017705e-08,
    "Input": "Sargan",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Budget-aware blackbox minimizer using a hybrid strategy:\n    - Careful handling of degenerate bounds / dimensionality\n    - Warm start from prev_best_x when available\n    - Global quasi-random sampling (scrambled progression)\n    - Local adaptive hill-climbing with restart logic\n    - Robustness improvements for small budgets and numeric edge cases\n    \"\"\"\n\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    # Basic shape / dimensionality safety\n    if bounds.ndim != 2 or bounds.shape[1] != 2:\n        # Fallback: infer dim from bounds if possible\n        if bounds.ndim == 2 and bounds.shape[1] == 2:\n            dim = bounds.shape[0]\n        else:\n            # No reliable bounds; safest is zeros of requested dim\n            return np.zeros(dim, dtype=float)\n\n    if bounds.shape[0] != dim:\n        # If inconsistent, trust bounds for dimensionality\n        dim = bounds.shape[0]\n\n    # Degenerate cases: if no evaluations, return center of bounds\n    if dim <= 0 or budget <= 0:\n        return np.mean(bounds, axis=1)\n\n    low = bounds[:, 0].astype(float)\n    high = bounds[:, 1].astype(float)\n\n    # Ensure proper ordering of bounds\n    swapped = low > high\n    if np.any(swapped):\n        tmp = low[swapped].copy()\n        low[swapped] = high[swapped]\n        high[swapped] = tmp\n\n    span = high - low\n\n    # Clamp helper\n    def clip_to_bounds(x):\n        x = np.asarray(x, dtype=float).reshape(-1)\n        # Robust clipping that also handles NaNs by resetting them to center\n        center = (low + high) * 0.5\n        x = np.where(np.isnan(x), center, x)\n        return np.minimum(np.maximum(x, low), high)\n\n    # Handle zero-width dimensions robustly\n    fixed_mask = span == 0.0\n    if np.any(fixed_mask):\n        span_safe = span.copy()\n        span_safe[fixed_mask] = 1.0\n    else:\n        span_safe = span\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # ---------- Warm start ----------\n    if prev_best_x is not None and budget > 0:\n        try:\n            x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n            if x0.size == dim:\n                x0 = clip_to_bounds(x0)\n                y0 = objective_function(x0)\n                evals_used += 1\n                if np.isfinite(y0):\n                    best_x, best_y = x0, float(y0)\n        except Exception:\n            best_x, best_y = None, np.inf\n\n    # If no valid warm start, sample one random point\n    if best_x is None and evals_used < budget:\n        x0 = np.random.uniform(low, high)\n        try:\n            y0 = objective_function(x0)\n            evals_used += 1\n            if np.isfinite(y0):\n                best_x, best_y = x0, float(y0)\n            else:\n                best_x, best_y = x0, np.inf\n        except Exception:\n            best_x, best_y = x0, np.inf\n\n    if evals_used >= budget:\n        return best_x\n\n    remaining = budget - evals_used\n\n    # Adaptive allocation: for very small budgets, lean fully global\n    if remaining < 15:\n        global_evals = remaining\n        local_evals = 0\n    else:\n        # Slightly more global exploration for robustness, but reserve\n        # at least some budget for local refinement when possible\n        global_evals = max(10, int(0.6 * remaining))\n        local_evals = remaining - global_evals\n\n    # ========== Helper: Global quasi-random search ==========\n    def global_search(start_best_x, start_best_y, eval_budget):\n        nonlocal evals_used\n\n        if eval_budget <= 0:\n            return start_best_x, start_best_y\n\n        g_best_x = start_best_x\n        g_best_y = float(start_best_y)\n\n        # Low-discrepancy-like sampling\n        dim_shifts = np.random.rand(dim)\n        use_perm = eval_budget <= 20000\n        if use_perm:\n            perms = [np.random.permutation(eval_budget) for _ in range(dim)]\n        else:\n            perms = None\n\n        for i in range(eval_budget):\n            if evals_used >= budget:\n                break\n\n            t = (i + 0.5) / float(eval_budget)\n            if use_perm:\n                u = np.empty(dim)\n                for d in range(dim):\n                    idx = perms[d][i]\n                    u[d] = np.mod(\n                        t + dim_shifts[d] + (idx + 0.5) / float(eval_budget), 1.0\n                    )\n            else:\n                r = (i * 1.61803398875 + dim_shifts) % 1.0\n                u = np.mod(t + r, 1.0)\n\n            x = low + span_safe * u\n            x = clip_to_bounds(x)\n            try:\n                y = objective_function(x)\n            except Exception:\n                continue\n            evals_used += 1\n\n            if not np.isfinite(y):\n                continue\n\n            y = float(y)\n            if y < g_best_y:\n                g_best_y = y\n                g_best_x = x\n\n        return g_best_x, g_best_y\n\n    # ========== Helper: Local adaptive hill-climbing ==========\n    def local_search(center_x, center_y, eval_budget):\n        nonlocal evals_used\n\n        if eval_budget <= 0:\n            return center_x, center_y\n\n        x_center = center_x.copy()\n        l_best_x = center_x.copy()\n        l_best_y = float(center_y)\n\n        # If center_y is inf (e.g., objective failed), fall back to a random center\n        if not np.isfinite(l_best_y):\n            rand_x = np.random.uniform(low, high)\n            try:\n                rand_y = objective_function(rand_x)\n                evals_used += 1\n                if np.isfinite(rand_y):\n                    x_center = rand_x\n                    l_best_x = rand_x\n                    l_best_y = float(rand_y)\n            except Exception:\n                pass\n\n        # Initial step ~ 10% of span, but respect fixed dims\n        base_step = 0.10 * (span_safe + 1e-12)\n        base_step[fixed_mask] = 0.0\n        step = base_step.copy()\n        success_count = 0\n        window = max(5, eval_budget // 10)\n\n        for k in range(eval_budget):\n            if evals_used >= budget:\n                break\n\n            # Mild occasional exploration jumps\n            if k > 0 and k % max(10, eval_budget // 5) == 0:\n                jump_scale = 1.5\n            else:\n                jump_scale = 1.0\n\n            # Heavy-tailed noise to escape local minima, but bounded\n            noise = np.random.standard_cauchy(size=dim)\n            noise = np.clip(noise, -5.0, 5.0)\n            perturb = noise * step * jump_scale\n            perturb[fixed_mask] = 0.0\n            x_candidate = clip_to_bounds(x_center + perturb)\n\n            try:\n                y_candidate = objective_function(x_candidate)\n            except Exception:\n                continue\n            evals_used += 1\n\n            if not np.isfinite(y_candidate):\n                continue\n\n            y_candidate = float(y_candidate)\n            if y_candidate < l_best_y:\n                l_best_y = y_candidate\n                l_best_x = x_candidate\n                x_center = x_candidate\n                success_count += 1\n\n            # Adapt step size\n            if (k + 1) % window == 0:\n                if window > 0:\n                    success_rate = success_count / float(window)\n                else:\n                    success_rate = 0.0\n\n                if success_rate > 0.3:\n                    step *= 1.3\n                elif success_rate < 0.1:\n                    step *= 0.5\n\n                # Clamp step: avoid collapse, but keep within domain scale\n                min_step = 1e-8 * (span_safe + 1.0)\n                max_step = 0.5 * (span_safe + 1.0)\n                step = np.clip(step, min_step, max_step)\n                step[fixed_mask] = 0.0\n                success_count = 0\n\n        return l_best_x, l_best_y\n\n    # ---------- Global Search ----------\n    best_x, best_y = global_search(best_x, best_y, global_evals)\n    if evals_used >= budget or local_evals <= 0:\n        return best_x\n\n    # ---------- Local Search ----------\n    remaining_local = budget - evals_used\n    if remaining_local <= 0:\n        return best_x\n\n    # Use up to 3 local phases if budget allows for robustness\n    if remaining_local > 60:\n        n_phases = 3\n    elif remaining_local > 20:\n        n_phases = 2\n    else:\n        n_phases = 1\n\n    phase_budget = [remaining_local // n_phases] * n_phases\n    for i in range(remaining_local % n_phases):\n        phase_budget[i] += 1\n\n    current_x = best_x\n    current_y = best_y\n\n    for p in range(n_phases):\n        if evals_used >= budget or phase_budget[p] <= 0:\n            break\n\n        # For later phases, perturb around global best_x to escape local traps\n        if p > 0 and evals_used < budget:\n            noise = np.random.normal(loc=0.0, scale=0.5, size=dim)\n            small_perturb = noise * 0.05 * (span_safe + 1e-12)\n            small_perturb[fixed_mask] = 0.0\n            candidate_x = clip_to_bounds(best_x + small_perturb)\n            try:\n                candidate_y = objective_function(candidate_x)\n                evals_used += 1\n            except Exception:\n                candidate_y = np.inf\n\n            if np.isfinite(candidate_y):\n                candidate_y = float(candidate_y)\n                if candidate_y < current_y:\n                    current_x, current_y = candidate_x, candidate_y\n\n        current_x, current_y = local_search(current_x, current_y, phase_budget[p])\n        if current_y < best_y:\n            best_x, best_y = current_x, current_y\n\n    return best_x",
    "X": "-3.983833579633592e-05 -9.968865057357481e-05"
}