{
    "score": 1.362396851245041e-07,
    "Input": "Sargan",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Budget-aware blackbox minimizer using:\n    - Warm start from prev_best_x when available\n    - Global quasi-random sampling (scrambled progression)\n    - Local adaptive hill-climbing with step-size control\n    - Simple restart logic for robustness\n    \"\"\"\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    # Degenerate cases: return center of bounds\n    if dim <= 0 or budget <= 0:\n        return np.mean(bounds, axis=1)\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Clamp helper\n    def clip_to_bounds(x):\n        return np.clip(x, low, high)\n\n    # Handle zero-width dimensions robustly\n    fixed_mask = span == 0.0\n    if np.any(fixed_mask):\n        # For zero-width dims, low == high; span is zero\n        span_safe = span.copy()\n        span_safe[fixed_mask] = 1.0\n    else:\n        span_safe = span\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # ---------- Warm start ----------\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip_to_bounds(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # If no valid warm start, sample one random point\n    if best_x is None and evals_used < budget:\n        x0 = np.random.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if evals_used >= budget:\n        return best_x\n\n    remaining = budget - evals_used\n\n    # Adaptive allocation: more global search for small budgets\n    if remaining < 20:\n        global_evals = remaining\n        local_evals = 0\n    else:\n        global_evals = max(5, int(0.6 * remaining))\n        local_evals = remaining - global_evals\n\n    # ========== Helper: Global quasi-random search ==========\n    def global_search(start_best_x, start_best_y, eval_budget):\n        nonlocal evals_used\n\n        if eval_budget <= 0:\n            return start_best_x, start_best_y\n\n        g_best_x = start_best_x\n        g_best_y = start_best_y\n\n        # Low-discrepancy-like sampling\n        dim_shifts = np.random.rand(dim)\n        perms = [np.random.permutation(eval_budget) for _ in range(dim)]\n\n        for i in range(eval_budget):\n            t = (i + 0.5) / eval_budget\n            u = np.empty(dim)\n            for d in range(dim):\n                idx = perms[d][i]\n                u[d] = np.mod(t + dim_shifts[d] + (idx + 0.5) / eval_budget, 1.0)\n            x = low + span_safe * u\n            x = clip_to_bounds(x)\n            y = objective_function(x)\n            evals_used += 1\n            if y < g_best_y:\n                g_best_y = y\n                g_best_x = x\n\n            if evals_used >= budget:\n                break\n\n        return g_best_x, g_best_y\n\n    # ========== Helper: Local adaptive hill-climbing ==========\n    def local_search(center_x, center_y, eval_budget):\n        nonlocal evals_used\n\n        if eval_budget <= 0:\n            return center_x, center_y\n\n        x_center = center_x.copy()\n        l_best_x = center_x.copy()\n        l_best_y = center_y\n\n        # Initial step ~ 15% of span, but respect fixed dims\n        base_step = 0.15 * (span_safe + 1e-12)\n        base_step[fixed_mask] = 0.0\n        step = base_step.copy()\n        success_count = 0\n        window = max(5, eval_budget // 10)\n\n        for k in range(eval_budget):\n            # Mild occasional exploration jumps\n            if k > 0 and k % max(10, eval_budget // 5) == 0:\n                jump_scale = 1.5\n            else:\n                jump_scale = 1.0\n\n            noise = np.random.normal(loc=0.0, scale=0.5, size=dim)\n            perturb = noise * step * jump_scale\n            perturb[fixed_mask] = 0.0\n            x_candidate = clip_to_bounds(x_center + perturb)\n            y_candidate = objective_function(x_candidate)\n            evals_used += 1\n\n            if y_candidate < l_best_y:\n                l_best_y = y_candidate\n                l_best_x = x_candidate\n                x_center = x_candidate\n                success_count += 1\n\n            # Adapt step size\n            if (k + 1) % window == 0:\n                if window > 0:\n                    success_rate = success_count / float(window)\n                else:\n                    success_rate = 0.0\n\n                if success_rate > 0.3:\n                    step *= 1.2\n                elif success_rate < 0.1:\n                    step *= 0.5\n\n                # Clamp step: avoid collapse, but keep within domain scale\n                min_step = 1e-8 * (span_safe + 1.0)\n                max_step = 0.5 * (span_safe + 1.0)\n                step = np.clip(step, min_step, max_step)\n                step[fixed_mask] = 0.0\n                success_count = 0\n\n            if evals_used >= budget:\n                break\n\n        return l_best_x, l_best_y\n\n    # ---------- Global Search ----------\n    best_x, best_y = global_search(best_x, best_y, global_evals)\n    if evals_used >= budget or local_evals <= 0:\n        return best_x\n\n    # ---------- Local Search ----------\n    # Split local search into a couple of restarts around best_x\n    # to improve robustness against poor local basins.\n    remaining_local = budget - evals_used\n    if remaining_local <= 0:\n        return best_x\n\n    # Use up to 2 local phases if budget allows\n    n_phases = 2 if remaining_local > 20 else 1\n    phase_budget = [remaining_local // n_phases] * n_phases\n    for i in range(remaining_local % n_phases):\n        phase_budget[i] += 1\n\n    current_x = best_x\n    current_y = best_y\n\n    for p in range(n_phases):\n        if evals_used >= budget or phase_budget[p] <= 0:\n            break\n\n        # For later phases, slightly perturb the center to escape local traps\n        if p > 0:\n            noise = np.random.normal(loc=0.0, scale=0.3, size=dim)\n            small_perturb = noise * 0.05 * (span_safe + 1e-12)\n            small_perturb[fixed_mask] = 0.0\n            candidate_x = clip_to_bounds(best_x + small_perturb)\n            candidate_y = objective_function(candidate_x)\n            evals_used += 1\n            if candidate_y < current_y:\n                current_x, current_y = candidate_x, candidate_y\n\n        current_x, current_y = local_search(current_x, current_y, phase_budget[p])\n        if current_y < best_y:\n            best_x, best_y = current_x, current_y\n\n    return best_x",
    "X": "-0.00028440182204874796 0.00012706296920027667"
}