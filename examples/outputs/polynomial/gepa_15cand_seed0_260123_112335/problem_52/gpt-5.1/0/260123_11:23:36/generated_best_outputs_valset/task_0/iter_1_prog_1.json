{
    "score": 2.5329593715138348,
    "Input": "Sphere",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple budget-aware optimizer: global random search + local perturbation around best.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Safety checks\n    if dim <= 0 or budget <= 0:\n        # Degenerate case: return midpoint of bounds\n        return (low + high) / 2.0\n\n    # Decide how many evaluations to use for different phases\n    # Use at least 3 evals for any phase with a minimum of 1\n    global_frac = 0.6  # proportion of budget for global random search\n    local_frac = 0.4   # proportion for local search around best\n\n    global_budget = max(1, int(budget * global_frac))\n    # Ensure we never exceed total budget\n    local_budget = max(0, min(budget - global_budget, int(budget * local_frac)))\n    remaining = budget - global_budget - local_budget\n    global_budget += remaining  # allocate any leftover to global phase\n\n    evals_used = 0\n\n    # --- Initialization of best solution ---\n    best_x = None\n    best_y = np.inf\n\n    # Warm-start from previous best if available and valid\n    if prev_best_x is not None:\n        try:\n            prev_best_x = np.asarray(prev_best_x, dtype=float).reshape(dim)\n            # Clip to bounds to be safe\n            prev_best_x = np.clip(prev_best_x, low, high)\n            best_x = prev_best_x\n            best_y = objective_function(best_x)\n            evals_used += 1\n        except Exception:\n            # Fallback: ignore invalid prev_best_x\n            best_x = None\n            best_y = np.inf\n\n    # --- Global random search phase ---\n    # If we already used one eval for prev_best_x, adjust global_budget\n    remaining_global = max(0, global_budget - (1 if evals_used > 0 else 0))\n    if remaining_global > 0:\n        # Always evaluate at least one completely new random point\n        for _ in range(remaining_global):\n            if evals_used >= budget:\n                break\n            x = low + span * np.random.rand(dim)\n            y = objective_function(x)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = x\n\n    # If nothing evaluated successfully (budget could be 0 or error in warm-start),\n    # fall back to a random point without evaluation.\n    if best_x is None:\n        best_x = low + span * np.random.rand(dim)\n        # Try to evaluate once if we have budget\n        if evals_used < budget:\n            try:\n                best_y = objective_function(best_x)\n                evals_used += 1\n            except Exception:\n                # Keep best_x as is; no further evals\n                pass\n\n    # --- Local search phase around best solution ---\n    # Adaptive step size: start from a fraction of the domain span\n    # and gradually shrink it.\n    if local_budget > 0 and evals_used < budget:\n        # Base scale: 1/4 of span in each dimension (non-zero)\n        base_scale = span / 4.0\n        base_scale[base_scale == 0.0] = 1.0  # avoid zero step if degenerate bounds\n\n        # Number of iterations equals allocated evaluations\n        for i in range(local_budget):\n            if evals_used >= budget:\n                break\n            # Geometric decay of step size\n            decay = 0.5 ** (i / max(1, local_budget - 1))\n            step_scale = base_scale * decay\n\n            # Generate candidate: Gaussian perturbation around current best\n            noise = np.random.randn(dim) * step_scale\n            cand_x = best_x + noise\n            cand_x = np.clip(cand_x, low, high)\n\n            y = objective_function(cand_x)\n            evals_used += 1\n\n            if y < best_y:\n                best_y = y\n                best_x = cand_x\n\n    # Ensure correct shape and type\n    best_x = np.asarray(best_x, dtype=float).reshape(dim)\n    return best_x",
    "X": "0.25812810560322297 -0.10546753913553991 -0.5757027188859853 0.888138774051358 1.1208468663372273 0.2696799166172722 -0.0771802636000492"
}