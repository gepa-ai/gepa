{
    "score": 0.688453507667486,
    "Input": "Sphere",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Budget-aware optimizer: global sampling (quasi-random) + adaptive local search.\n    Uses prev_best_x as warm start if available.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Degenerate / invalid config\n    if dim <= 0 or budget <= 0:\n        return (low + high) / 2.0\n\n    # Ensure span is non-zero to avoid division issues\n    safe_span = np.where(span > 0, span, 1.0)\n\n    # Phase allocation: slightly more to global search on small budgets\n    if budget < 20:\n        global_frac = 0.7\n    elif budget < 100:\n        global_frac = 0.6\n    else:\n        global_frac = 0.5\n    local_frac = 1.0 - global_frac\n\n    global_budget = max(1, int(budget * global_frac))\n    local_budget = max(0, min(budget - global_budget, int(budget * local_frac)))\n    remaining = budget - global_budget - local_budget\n    global_budget += max(0, remaining)\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # --- Helper: scrambled Sobol-like low-discrepancy samples via randomized grid ---\n    def quasi_random_samples(n_samples):\n        if n_samples <= 0:\n            return np.empty((0, dim), dtype=float)\n        # Choose grid size roughly equal in each dimension\n        m = int(np.ceil(n_samples ** (1.0 / max(1, dim))))\n        # Total points in grid\n        total_pts = m**dim\n        # We'll generate indices and randomly shuffle, then take first n_samples\n        # To avoid huge memory when m^dim is enormous, cap total_pts\n        max_pts = min(total_pts, n_samples * 10)\n        if dim == 1:\n            grid = (np.arange(max_pts) % m + np.random.rand(max_pts)) / float(m)\n            grid = grid.reshape(-1, 1)\n        else:\n            grid = np.empty((max_pts, dim), dtype=float)\n            base = np.arange(max_pts)\n            for d in range(dim):\n                # scramble with different prime steps per dimension\n                step = 2 * d + 1\n                coord = (base * step) % m\n                grid[:, d] = (coord + np.random.rand()) / float(m)\n        # scale to bounds\n        grid = low + span * grid\n        if max_pts > n_samples:\n            idx = np.random.choice(max_pts, size=n_samples, replace=False)\n            grid = grid[idx]\n        return grid\n\n    # --- Warm start ---\n    if prev_best_x is not None:\n        try:\n            prev_best_x_arr = np.asarray(prev_best_x, dtype=float).reshape(dim)\n            prev_best_x_arr = np.clip(prev_best_x_arr, low, high)\n            y = objective_function(prev_best_x_arr)\n            evals_used += 1\n            best_x = prev_best_x_arr\n            best_y = y\n        except Exception:\n            best_x = None\n            best_y = np.inf\n\n    # Adjust global budget if we already consumed an eval\n    remaining_global = max(0, global_budget - (1 if evals_used > 0 else 0))\n\n    # --- Global search: quasi-random sampling + a few pure random points ---\n    if remaining_global > 0 and evals_used < budget:\n        n_qr = int(0.8 * remaining_global)\n        n_qr = max(0, min(remaining_global, n_qr))\n        n_rand = remaining_global - n_qr\n\n        # Quasi-random grid-like samples\n        if n_qr > 0:\n            samples = quasi_random_samples(n_qr)\n            for i in range(n_qr):\n                if evals_used >= budget:\n                    break\n                x = samples[i]\n                try:\n                    y = objective_function(x)\n                except Exception:\n                    # Skip failing point, don't count toward budget\n                    continue\n                evals_used += 1\n                if y < best_y:\n                    best_y = y\n                    best_x = x\n\n        # Pure random samples for additional diversity\n        for _ in range(n_rand):\n            if evals_used >= budget:\n                break\n            x = low + span * np.random.rand(dim)\n            try:\n                y = objective_function(x)\n            except Exception:\n                continue\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = x\n\n    # If still nothing evaluated successfully, fall back to midpoint/random\n    if best_x is None:\n        # Prefer center of domain, as many functions are well-behaved around origin\n        center = (low + high) / 2.0\n        best_x = center\n        if evals_used < budget:\n            try:\n                best_y = objective_function(best_x)\n                evals_used += 1\n            except Exception:\n                # As a last resort, just keep center without a valid y\n                best_y = np.inf\n\n    # --- Local search: adaptive Gaussian + coordinate search ---\n    if local_budget > 0 and evals_used < budget:\n        # Base step is moderate fraction of span; ensure non-zero\n        base_step = 0.25 * safe_span\n\n        # Local search loop\n        for i in range(local_budget):\n            if evals_used >= budget:\n                break\n\n            # Geometric decay of step size, but not below a floor\n            t = i / max(1, local_budget - 1)\n            decay = 0.5 ** t\n            step = base_step * decay\n            step_floor = 1e-3 * safe_span\n            step = np.maximum(step, step_floor)\n\n            # Alternate between Gaussian perturbation and coordinate-wise moves\n            if i % 3 == 0:\n                # Gaussian perturbation\n                noise = np.random.randn(dim) * step\n                cand_x = best_x + noise\n            else:\n                # Coordinate descent-like move\n                cand_x = best_x.copy()\n                coord = np.random.randint(dim)\n                direction = 1.0 if np.random.rand() < 0.5 else -1.0\n                cand_x[coord] += direction * step[coord]\n\n            cand_x = np.clip(cand_x, low, high)\n\n            try:\n                y = objective_function(cand_x)\n            except Exception:\n                continue\n\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = cand_x\n\n    best_x = np.asarray(best_x, dtype=float).reshape(dim)\n    return best_x",
    "X": "0.25812810560322297 -0.10546753913553991 0.4533381431974556 -0.33542536621665886 -0.4625908430335627 0.2696799166172722 -0.0771802636000492"
}