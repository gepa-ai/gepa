{
    "score": -8.672688259602014,
    "Input": "McCourt19",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Budget-aware blackbox optimizer (drop-in replacement).\n\n    Strategy: robust hybrid global + local search with stronger global coverage\n    and safer, simpler local refinement.\n\n    - Uses warm-start from prev_best_x when available.\n    - Allocates budget between global exploration and local exploitation in a\n      dimension-aware way.\n    - Uses low-discrepancy-like sequences plus random sampling for global search.\n    - Uses adaptive coordinate-wise local search around the best point.\n    - Always respects the evaluation budget and aims to use it fully.\n    \"\"\"\n\n    rng = np.random.RandomState()\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n    span[span < 1e-12] = 0.0\n\n    def clamp(x):\n        return np.minimum(np.maximum(x, low), high)\n\n    evals_used = 0\n    best_x = None\n    best_y = None\n\n    # ---- Safe evaluation wrapper ----\n    def eval_point(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        x = np.asarray(x, dtype=float).reshape(dim)\n        x = clamp(x)\n        try:\n            y = float(objective_function(x))\n        except Exception:\n            evals_used += 1\n            return None\n        evals_used += 1\n        if (best_y is None) or (y < best_y):\n            best_y = y\n            best_x = x.copy()\n        return y\n\n    # ---- Degenerate budget handling ----\n    if budget <= 0:\n        if prev_best_x is not None:\n            try:\n                x0 = np.asarray(prev_best_x, dtype=float).reshape(dim)\n                return clamp(x0)\n            except Exception:\n                pass\n        return ((low + high) * 0.5).astype(float)\n\n    # ================== Initialization / warm start ================== #\n    # 1) Warm start from previous best, if any\n    if prev_best_x is not None:\n        try:\n            x0 = np.asarray(prev_best_x, dtype=float).reshape(dim)\n            eval_point(x0)\n        except Exception:\n            pass\n\n    # 2) Center point if nothing evaluated yet\n    if evals_used < budget and best_x is None:\n        x0 = ((low + high) * 0.5).astype(float)\n        eval_point(x0)\n\n    # 3) A few random points for diversity\n    remaining = budget - evals_used\n    if remaining > 0:\n        n_init_rand = min(max(1, 2 * dim), remaining)\n        for _ in range(n_init_rand):\n            if evals_used >= budget:\n                break\n            xr = rng.uniform(low, high)\n            eval_point(xr)\n\n    if evals_used >= budget:\n        return best_x.astype(float)\n\n    remaining = budget - evals_used\n\n    # ================== Very small budget: global-only search ================== #\n    tiny_threshold = max(6, 2 * dim)\n    if remaining <= tiny_threshold:\n        # Use a simple low-discrepancy-like progression + jitter\n        golden_ratio_conj = (np.sqrt(5.0) - 1.0) / 2.0\n        base = rng.uniform(0.0, 1.0, size=dim)\n        increments = np.mod(\n            golden_ratio_conj * (np.sqrt(np.arange(1, dim + 1)) * 1.31 + 0.27), 1.0\n        )\n        for i in range(remaining):\n            if evals_used >= budget:\n                break\n            t = (base + increments * (i + 1)) % 1.0\n            jitter = rng.uniform(-1e-3, 1e-3, size=dim)\n            u = np.mod(t + jitter, 1.0)\n            x = low + u * span\n            eval_point(x)\n        return best_x.astype(float)\n\n    # ================== Budget split: global vs local ================== #\n    # Make global search a bit stronger, especially in higher dimensions.\n    if dim <= 4:\n        global_frac = 0.55\n    elif dim <= 12:\n        global_frac = 0.65\n    else:\n        global_frac = 0.7\n\n    remaining = budget - evals_used\n    global_budget = int(global_frac * remaining)\n    # Ensure at least some global and some local evaluations where possible.\n    if remaining > 5:\n        global_budget = max(global_budget, min(remaining - 2, dim + 5))\n        global_budget = min(global_budget, remaining - 2)\n    else:\n        global_budget = max(1, remaining - 1)\n    local_budget = remaining - global_budget\n\n    if local_budget <= 0 and remaining > 1:\n        local_budget = 1\n        global_budget = remaining - 1\n    if global_budget < 0:\n        global_budget = max(0, remaining - 1)\n\n    # ================== Global search ================== #\n    start_evals_global = evals_used\n    n_global = global_budget\n\n    golden_ratio_conj = (np.sqrt(5.0) - 1.0) / 2.0\n    increments = np.mod(\n        golden_ratio_conj * (np.sqrt(np.arange(1, dim + 1)) * 1.37 + 0.11), 1.0\n    )\n    base = rng.uniform(0.0, 1.0, size=dim)\n\n    # Mix low-discrepancy-like and random samples\n    ld_fraction = 0.6\n    n_ld = int(ld_fraction * n_global)\n    n_ld = min(n_ld, n_global)\n\n    for i in range(n_ld):\n        if evals_used >= budget:\n            break\n        t = (base + increments * (i + 1)) % 1.0\n        jitter_scale = max(20, 4 * n_ld)\n        jitter = rng.uniform(-1.0 / jitter_scale, 1.0 / jitter_scale, size=dim)\n        u = np.mod(t + jitter, 1.0)\n        x = low + u * span\n        eval_point(x)\n\n    remaining_global = n_global - (evals_used - start_evals_global)\n    for _ in range(max(0, remaining_global)):\n        if evals_used >= budget:\n            break\n        x = rng.uniform(low, high)\n        eval_point(x)\n\n    if evals_used >= budget or local_budget <= 0 or best_x is None:\n        return best_x.astype(float)\n\n    # ================== Local refinement ================== #\n    # Use simpler coordinate-wise adaptive random search which is more robust\n    # across problems than the previous directional heavy-tail scheme.\n    x_center = best_x.copy()\n\n    # Step sizes informed by span, with stable lower/upper bounds\n    base_step = np.maximum(0.25 * span, 5e-4)\n    min_step = np.where(span > 0.0, np.maximum(1e-4 * span, 1e-6), 0.0)\n    max_step = np.where(span > 0.0, np.maximum(0.5 * span, 5e-3), 0.0)\n    step_sizes = np.clip(base_step, min_step, max_step)\n\n    n_local = local_budget\n\n    # Split into coarse and fine phases\n    if n_local < 30:\n        n_coarse = int(0.4 * n_local)\n    else:\n        n_coarse = int(0.55 * n_local)\n    n_coarse = max(0, min(n_coarse, n_local))\n    n_fine = n_local - n_coarse\n\n    def local_phase(n_iter, shrink_factor):\n        nonlocal x_center, step_sizes, best_x, best_y, evals_used\n        if n_iter <= 0:\n            return\n\n        for it in range(n_iter):\n            if evals_used >= budget:\n                break\n\n            # Shrink steps gradually within phase\n            phase_progress = (it + 1) / max(1.0, n_iter)\n            current_step = step_sizes * (\n                (1.0 - phase_progress) + shrink_factor * phase_progress\n            )\n            current_step = np.clip(current_step, min_step, max_step)\n\n            # Coordinate-wise perturbation\n            coord = it % max(1, dim)\n            direction = 1.0 if rng.rand() < 0.5 else -1.0\n            delta = np.zeros(dim, dtype=float)\n            # Use heavier sampling near zero but allow some larger jumps\n            mag = rng.beta(1.0, 3.0)\n            delta[coord] = direction * mag * current_step[coord]\n\n            x_new = x_center + delta\n            y_new = eval_point(x_new)\n            if y_new is None:\n                break\n\n            if y_new < best_y:\n                # Successful move: center follows best, expand slightly\n                x_center = best_x.copy()\n                step_sizes[coord] = np.clip(\n                    step_sizes[coord] * 1.1, min_step[coord], max_step[coord]\n                )\n            else:\n                # Unsuccessful move: slightly contract step size in that coord\n                step_sizes[coord] = np.clip(\n                    step_sizes[coord] * 0.9, min_step[coord], max_step[coord]\n                )\n\n            # Periodic re-centering to best point for numerical stability\n            if (it + 1) % (2 * max(1, dim)) == 0 and best_x is not None:\n                x_center = best_x.copy()\n\n    # Coarse phase: larger steps\n    local_phase(n_coarse, shrink_factor=0.6)\n\n    if best_x is not None:\n        x_center = best_x.copy()\n\n    # Fine phase: smaller steps\n    local_phase(n_fine, shrink_factor=0.2)\n\n    return best_x.astype(float)",
    "X": "0.4000002740819455 0.7999999993669468"
}