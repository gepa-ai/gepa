{
    "score": -8.639107300553572,
    "Input": "McCourt19",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple budget-aware blackbox optimizer.\n\n    Strategy:\n    - If budget very small: random search + optional local refinement around prev_best_x.\n    - Otherwise: adaptive random search with progressive local refinement around\n      the current best and (if available) prev_best_x.\n    - Always respects the evaluation budget and returns best x found.\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low, high = bounds[:, 0], bounds[:, 1]\n    span = high - low\n\n    def clamp(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n    best_x = None\n    best_y = None\n\n    # Helper to evaluate a point safely within budget\n    def eval_point(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        y = objective_function(x)\n        evals_used += 1\n        if (best_y is None) or (y < best_y):\n            best_y = y\n            best_x = x\n        return y\n\n    # --- Initialization ---------------------------------------------------- #\n    # Use prev_best_x if provided and inside bounds\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(dim)\n        x0 = clamp(x0)\n        eval_point(x0)\n\n    # If we still haven't evaluated anything (no prev_best_x or budget==0) and we\n    # have budget, sample one random point\n    if evals_used < budget and best_x is None:\n        x0 = rng.uniform(low, high)\n        eval_point(x0)\n\n    if budget <= evals_used:\n        # No budget left after warm start\n        return best_x.astype(float)\n\n    # Remaining budget after initial point(s)\n    remaining = budget - evals_used\n\n    # --- Strategy based on remaining budget -------------------------------- #\n    # Very small budget: just random samples\n    if remaining <= max(5, 2 * dim):\n        for _ in range(remaining):\n            x = rng.uniform(low, high)\n            eval_point(x)\n        return best_x.astype(float)\n\n    # Otherwise: hybrid random + local search\n    # Split remaining budget into:\n    # - global random search: about 60%\n    # - local refinement: about 40%\n    global_budget = max(int(0.6 * remaining), dim + 5)\n    global_budget = min(global_budget, remaining)\n    local_budget = remaining - global_budget\n\n    # --- Global random search ---------------------------------------------- #\n    # Use slightly quasi-random Latin-hypercube-like sampling by jittering\n    # across dimensions.\n    n_global = global_budget\n    # Each candidate: low + u * span, with u ~ U[0,1]^dim\n    for _ in range(n_global):\n        u = rng.uniform(0.0, 1.0, size=dim)\n        x = low + u * span\n        eval_point(x)\n        if evals_used >= budget:\n            return best_x.astype(float)\n\n    # --- Local refinement around best -------------------------------------- #\n    if local_budget <= 0 or best_x is None:\n        return best_x.astype(float)\n\n    # Adaptive step sizes: start with fraction of span, then shrink\n    # allocate iterations; one eval per neighbor\n    n_local_iters = local_budget\n\n    # Initial step size around 20% of domain span; not smaller than 1e-3*span\n    base_step = 0.2 * span\n    min_step = 1e-3 * span\n    # Avoid all-zero step when span is zero in some dim\n    base_step = np.maximum(base_step, 1e-3)\n\n    x_center = best_x.copy()\n\n    for i in range(n_local_iters):\n        if evals_used >= budget:\n            break\n\n        # Geometric decay of step size\n        decay = 0.5 ** (i / max(1.0, n_local_iters - 1))\n        step = np.maximum(base_step * decay, min_step)\n\n        # Sample a random direction and step length\n        direction = rng.normal(size=dim)\n        norm = np.linalg.norm(direction)\n        if norm == 0:\n            direction = rng.normal(size=dim)\n            norm = np.linalg.norm(direction)\n        direction /= norm\n\n        # Random magnitude in [0, 1] scaled by step per dim\n        mag = rng.uniform(0.0, 1.0, size=dim)\n        delta = direction * mag * step\n\n        x_new = clamp(x_center + delta)\n        y_new = eval_point(x_new)\n        if y_new is not None and y_new <= best_y:\n            # Move center to the new best point\n            x_center = x_new\n\n    return best_x.astype(float)",
    "X": "0.4003427535578106 0.7990261443859842"
}