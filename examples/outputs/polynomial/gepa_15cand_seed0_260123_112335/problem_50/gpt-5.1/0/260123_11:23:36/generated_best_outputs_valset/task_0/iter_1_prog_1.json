{
    "score": -3455.944053182309,
    "Input": "Schwefel36",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Basic black-box minimization with budget-aware random search plus\n    optional local refinement around the best point and optional warm start.\n\n    Strategy:\n    1. Use prev_best_x if available and feasible (counts as one eval).\n    2. Spend ~70% of budget on global random search.\n    3. Spend remaining budget on local Gaussian search around current best.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    # Safety checks\n    if dim <= 0 or budget <= 0:\n        # Degenerate case: fabricate a point in the middle of bounds\n        return np.mean(bounds, axis=1)\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # Helper: evaluate with budget tracking\n    def eval_point(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y = y\n            best_x = x.copy()\n        return y\n\n    # 1) Warm-start from prev_best_x if provided and inside bounds\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            # Clip to bounds just in case\n            x0 = np.clip(x0, low, high)\n            eval_point(x0)\n\n    # 2) Global random search\n    # Allocate ~70% of budget to global search (at least 1 eval if budget > 0)\n    remaining = budget - evals_used\n    if remaining <= 0:\n        # If budget exhausted by warm start, just return that\n        if best_x is None:\n            # Should not normally happen, but be safe\n            best_x = np.random.uniform(low, high)\n        return best_x\n\n    global_budget = max(1, int(0.7 * remaining))\n    for _ in range(global_budget):\n        if evals_used >= budget:\n            break\n        x = np.random.uniform(low, high)\n        eval_point(x)\n\n    # 3) Local search around best_x using Gaussian perturbations\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # If no best_x yet (very unlikely), initialize randomly\n    if best_x is None:\n        best_x = np.random.uniform(low, high)\n        eval_point(best_x)\n        remaining = budget - evals_used\n        if remaining <= 0:\n            return best_x\n\n    # Initial local step size: fraction of span (handle zero-span gracefully)\n    step_scale = 0.15\n    step = np.where(span > 0, step_scale * span, 0.1)\n\n    # Perform local search with simple annealing of step size\n    for i in range(remaining):\n        if evals_used >= budget:\n            break\n        # Gradually shrink step size\n        frac = 1.0 - (i / max(1, remaining))\n        cur_step = np.maximum(step * frac, 1e-8)\n        candidate = best_x + np.random.normal(loc=0.0, scale=cur_step)\n        candidate = np.clip(candidate, low, high)\n        eval_point(candidate)\n\n    return best_x",
    "X": "11.989011042632313 12.052850317822953"
}