{
    "score": -2.0217973703230543,
    "Input": "Adjiman",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer using randomized local search\n    with warm-start support and full budget usage.\n    \"\"\"\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Helper: project point back into bounds\n    def clip_to_bounds(x):\n        return np.minimum(np.maximum(x, low), high)\n\n    # Initialization: use prev_best_x if valid, otherwise random in bounds\n    evals_used = 0\n    if prev_best_x is not None:\n        x_best = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x_best.shape[0] != dim:\n            x_best = np.random.uniform(low, high)\n    else:\n        x_best = np.random.uniform(low, high)\n\n    y_best = objective_function(x_best)\n    evals_used += 1\n\n    if budget <= evals_used:\n        return x_best\n\n    # Split budget between global exploration and local refinement\n    # At least a few global samples and a few local moves\n    remaining = budget - evals_used\n    global_samples = max(5, remaining // 3)\n    global_samples = min(global_samples, remaining)\n    local_steps = remaining - global_samples\n\n    # Global random sampling\n    if global_samples > 0:\n        xs = np.random.uniform(low, high, size=(global_samples, dim))\n        ys = []\n        for i in range(global_samples):\n            ys.append(objective_function(xs[i]))\n        ys = np.asarray(ys)\n        evals_used += global_samples\n\n        idx = np.argmin(ys)\n        if ys[idx] < y_best:\n            x_best = xs[idx].copy()\n            y_best = ys[idx]\n\n    if evals_used >= budget or local_steps <= 0:\n        return x_best\n\n    # Local stochastic search around current best\n    # Step size starts at 25% of span, shrinks over time\n    base_step = 0.25 * span\n    base_step[base_step == 0.0] = 1.0  # fallback for zero-width bounds\n\n    for t in range(local_steps):\n        frac = 1.0 - (t / max(1, local_steps - 1))\n        step = base_step * (0.1 + 0.9 * frac)  # from ~span*0.25 to ~span*0.025\n\n        # Random Gaussian perturbation scaled by step\n        noise = np.random.normal(loc=0.0, scale=1.0, size=dim)\n        x_candidate = x_best + noise * step\n        x_candidate = clip_to_bounds(x_candidate)\n\n        y_candidate = objective_function(x_candidate)\n        # greedy acceptance\n        if y_candidate < y_best:\n            x_best, y_best = x_candidate, y_candidate\n\n        evals_used += 1\n        if evals_used >= budget:\n            break\n\n    return x_best",
    "X": "2.0 0.10355354212957524"
}