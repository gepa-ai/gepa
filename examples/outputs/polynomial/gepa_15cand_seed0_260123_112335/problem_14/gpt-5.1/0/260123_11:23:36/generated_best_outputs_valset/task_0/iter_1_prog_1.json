{
    "score": -0.9999999901019662,
    "Input": "LennardJones6",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config.get('dim', bounds.shape[0]))\n    budget = int(config.get('budget', 1))\n    low, high = bounds[:, 0], bounds[:, 1]\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # At least one evaluation must be allowed\n    if budget <= 0:\n        # Fallback: return center of bounds\n        return (low + high) / 2.0\n\n    rng = np.random.default_rng()\n\n    evals_used = 0\n\n    # --- Initialization ---\n    best_x = None\n    best_y = None\n\n    # Use prev_best_x if given and valid and we have budget\n    if prev_best_x is not None and evals_used < budget:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # If no warm start or invalid, sample a random start\n    if best_x is None and evals_used < budget:\n        x0 = rng.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    # If only one evaluation is allowed, return the best we have\n    if evals_used >= budget:\n        return np.array(best_x, dtype=float)\n\n    # --- Global random search phase ---\n    # Allocate about 60% of remaining budget to broad exploration\n    remaining = budget - evals_used\n    global_evals = max(1, int(0.6 * remaining))\n\n    for _ in range(global_evals):\n        if evals_used >= budget:\n            break\n        # Biased sampling around current best, plus full-range noise\n        center = best_x\n        radius = (high - low) * 0.25\n        x_candidate = center + rng.normal(0.0, 1.0, size=dim) * radius\n        # Mix with pure uniform to keep exploration\n        mask = rng.random(dim) < 0.3\n        if mask.any():\n            x_candidate[mask] = rng.uniform(low[mask], high[mask])\n        x_candidate = clip(x_candidate)\n\n        y_candidate = objective_function(x_candidate)\n        evals_used += 1\n        if y_candidate < best_y:\n            best_x, best_y = x_candidate, y_candidate\n\n    if evals_used >= budget:\n        return np.array(best_x, dtype=float)\n\n    # --- Local search phase (coordinate-wise hill climbing) ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return np.array(best_x, dtype=float)\n\n    # Number of local iterations: one sweep per dimension if possible\n    # Each sweep may use up to 2 evaluations per dimension (left/right)\n    max_sweeps = max(1, remaining // (2 * dim) if dim > 0 else 1)\n\n    step = 0.1 * (high - low)  # initial step as fraction of range\n    step = np.where(step == 0.0, 1.0, step)\n\n    x_current = best_x.copy()\n    y_current = best_y\n\n    for _ in range(max_sweeps):\n        improved = False\n        for d in range(dim):\n            if evals_used >= budget:\n                break\n\n            # Try negative direction\n            x_try = x_current.copy()\n            x_try[d] = x_try[d] - step[d]\n            x_try = clip(x_try)\n            y_try = objective_function(x_try)\n            evals_used += 1\n\n            if y_try < y_current:\n                x_current, y_current = x_try, y_try\n                if y_current < best_y:\n                    best_x, best_y = x_current, y_current\n                improved = True\n                continue  # go to next dimension\n\n            if evals_used >= budget:\n                break\n\n            # Try positive direction\n            x_try = x_current.copy()\n            x_try[d] = x_try[d] + step[d]\n            x_try = clip(x_try)\n            y_try = objective_function(x_try)\n            evals_used += 1\n\n            if y_try < y_current:\n                x_current, y_current = x_try, y_try\n                if y_current < best_y:\n                    best_x, best_y = x_current, y_current\n                improved = True\n\n        # Shrink step if no improvement in this sweep\n        if not improved:\n            step *= 0.5\n            # If steps are extremely small, stop early\n            if np.all(step < (high - low) * 1e-4):\n                break\n\n        if evals_used >= budget:\n            break\n\n    return np.array(best_x, dtype=float)",
    "X": "-0.9397450290303938 -0.0946477926511593 2.1930964595822537 -1.1561251683264417 0.5585658680252329 1.4674762347780783"
}