{
    "score": -1.4211467466822925,
    "Input": "McCourt18",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef _project_bounds(x, bounds):\n    return np.clip(x, bounds[:, 0], bounds[:, 1])\n\n\ndef _random_in_bounds(bounds, n=1, rng=None):\n    if rng is None:\n        rng = np.random\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    return rng.uniform(low, high, size=(n, bounds.shape[0]))\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer:\n    - Global random / quasi-grid search for exploration\n    - Local Gaussian search around best for exploitation\n    - Uses full evaluation budget\n    - Uses prev_best_x for warm start if provided\n    \"\"\"\n    rng = np.random.RandomState()\n\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    # Basic safety\n    if bounds.shape[0] != dim:\n        bounds = bounds.reshape(dim, 2)\n\n    # Minimum 1 evaluation\n    if budget <= 0:\n        x0 = _random_in_bounds(bounds, n=1, rng=rng)[0]\n        return x0\n\n    # --- Initialization / warm start ---\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # If prev_best_x is available, project it into bounds and evaluate\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(dim)\n        x0 = _project_bounds(x0, bounds)\n    else:\n        x0 = _random_in_bounds(bounds, n=1, rng=rng)[0]\n\n    y0 = objective_function(x0)\n    evals_used += 1\n    best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # --- Global exploration phase ---\n    # Use about 40% of remaining budget for global search (at least dim points)\n    global_evals = max(dim, int(0.4 * budget))\n    global_evals = min(global_evals, remaining)\n\n    if global_evals > 0:\n        # Latin-hypercube-like sampling using stratification per dimension\n        # Simple implementation: shuffled strata per dimension\n        m = global_evals\n        # Generate m points in [0,1]^dim\n        base = (np.arange(m) + rng.rand(m)) / m  # m stratified positions\n        X_unit = np.empty((m, dim), dtype=float)\n        for j in range(dim):\n            rng.shuffle(base)\n            X_unit[:, j] = base\n        # Map to bounds\n        low = bounds[:, 0]\n        high = bounds[:, 1]\n        X_global = low + (high - low) * X_unit\n\n        for i in range(m):\n            x = X_global[i]\n            y = objective_function(x)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = x\n            if evals_used >= budget:\n                return best_x\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # --- Local exploitation phase ---\n    # Gaussian search around best_x, with adaptive step size\n    # Start with step ~ 1/6 of box width per dimension (so \u00b13\u03c3 spans interval)\n    widths = bounds[:, 1] - bounds[:, 0]\n    # Avoid degenerate zero width\n    widths[widths == 0] = 1.0\n    base_sigma = widths / 6.0\n\n    # Partition remaining evaluations into few \"iterations\"\n    iters = max(3, min(15, remaining // max(3, 2 * dim)))\n    iters = max(1, iters)\n    evals_per_iter = max(1, remaining // iters)\n\n    current_sigma = base_sigma.copy()\n\n    for it in range(iters):\n        # Anneal step size moderately\n        frac = 1.0 - (it / max(1, iters - 1))\n        sigma = current_sigma * (0.2 + 0.8 * frac)\n\n        for _ in range(evals_per_iter):\n            if evals_used >= budget:\n                return best_x\n\n            # Sample symmetric candidate around current best\n            step = rng.randn(dim) * sigma\n            x_candidate = best_x + step\n            x_candidate = _project_bounds(x_candidate, bounds)\n\n            y = objective_function(x_candidate)\n            evals_used += 1\n            if y < best_y:\n                best_y = y\n                best_x = x_candidate\n\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "0.28551488678078213 0.8504385110367292 0.2540764149613283 0.6686475378385517 0.13532371526997672 0.9680117218821902 0.032183294590116665 0.2807390011266424"
}