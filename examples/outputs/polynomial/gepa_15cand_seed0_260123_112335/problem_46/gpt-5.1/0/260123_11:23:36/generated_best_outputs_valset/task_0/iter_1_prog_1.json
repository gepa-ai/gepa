{
    "score": -100.0,
    "Input": "Sargan",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization using a simple hybrid of:\n    - Random search (global exploration)\n    - Local search around the current best (exploitation)\n    with optional warm-start from prev_best_x.\n\n    Uses the full evaluation budget: config['budget'].\n    \"\"\"\n    rng = np.random.RandomState()  # independent RNG\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config[\"budget\"])\n\n    lower = bounds[:, 0]\n    upper = bounds[:, 1]\n    span = upper - lower\n\n    def clip(x):\n        return np.clip(x, lower, upper)\n\n    # --- Initialization (use prev_best_x if available and valid) ---\n    evals_used = 0\n\n    best_x = None\n    best_y = None\n\n    # Helper to evaluate safely and track best\n    def evaluate(x, current_best_x, current_best_y):\n        nonlocal evals_used\n        if evals_used >= budget:\n            return current_best_x, current_best_y\n        y = objective_function(x)\n        evals_used += 1\n        if (current_best_y is None) or (y < current_best_y):\n            return x, y\n        return current_best_x, current_best_y\n\n    # Start from prev_best_x if provided and within bounds\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            x0 = clip(x0)\n            best_x, best_y = evaluate(x0, best_x, best_y)\n\n    # If no warm start or budget still plentiful, do an initial random sample\n    # Use up to max(5, dim*2) evaluations or remaining budget, whichever smaller\n    if evals_used < budget:\n        initial_samples = min(budget - evals_used, max(5, dim * 2))\n        for _ in range(initial_samples):\n            x = lower + span * rng.rand(dim)\n            best_x, best_y = evaluate(x, best_x, best_y)\n            if evals_used >= budget:\n                break\n\n    # If still no valid point (very small budget edge case), just return something\n    if best_x is None:\n        x = lower + span * rng.rand(dim)\n        return x\n\n    # --- Main search loop: balance global and local search ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Parameters for search\n    # Fraction of remaining evaluations devoted to global vs local search\n    global_frac = 0.5\n    n_global = int(remaining * global_frac)\n    n_local = remaining - n_global\n\n    # Global random search\n    for _ in range(n_global):\n        x = lower + span * rng.rand(dim)\n        best_x, best_y = evaluate(x, best_x, best_y)\n        if evals_used >= budget:\n            return best_x\n\n    # Local search around best_x using Gaussian perturbations,\n    # gradually shrinking the step size.\n    # Step size proportional to search space size.\n    base_sigma = 0.2  # relative to span\n    for i in range(n_local):\n        # Geometric decay of step size over iterations\n        frac = 1.0 - (i / max(1, n_local - 1))\n        sigma = (0.05 + base_sigma * frac) * span\n        perturbation = rng.randn(dim) * sigma\n        x_candidate = clip(best_x + perturbation)\n        best_x, best_y = evaluate(x_candidate, best_x, best_y)\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "-2.0 4.0 -2.0 4.0 -2.0"
}