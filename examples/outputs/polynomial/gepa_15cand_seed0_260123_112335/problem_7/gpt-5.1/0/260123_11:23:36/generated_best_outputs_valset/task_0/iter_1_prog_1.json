{
    "score": -0.37335729191411726,
    "Input": "DeflectedCorrugatedSpring",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef _project_bounds(x, bounds):\n    \"\"\"Clamp x to the provided box-constraints.\"\"\"\n    return np.clip(x, bounds[:, 0], bounds[:, 1])\n\n\ndef _ensure_array(x, dim, bounds):\n    \"\"\"Convert x to a valid numpy array inside bounds.\"\"\"\n    x = np.asarray(x, dtype=float).reshape(-1)\n    if x.shape[0] != dim:\n        # Fallback to random if dimension mismatch\n        x = np.random.uniform(bounds[:, 0], bounds[:, 1])\n    return _project_bounds(x, bounds)\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Hybrid search:\n    1) Use prev_best_x if available and valid.\n    2) Global exploration with low-discrepancy random search.\n    3) Local search around current best using adaptive Gaussian perturbations.\n    \"\"\"\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config['dim'])\n    budget = int(config['budget'])\n\n    # Handle degenerate budget\n    if budget <= 0:\n        # Return a feasible point without evaluating\n        return np.random.uniform(bounds[:, 0], bounds[:, 1], size=dim)\n\n    rng = np.random.default_rng()\n\n    # Initialization\n    evaluations_used = 0\n\n    # Start from prev_best_x if provided and valid\n    if prev_best_x is not None:\n        try:\n            x_best = _ensure_array(prev_best_x, dim, bounds)\n        except Exception:\n            x_best = rng.uniform(bounds[:, 0], bounds[:, 1])\n    else:\n        x_best = rng.uniform(bounds[:, 0], bounds[:, 1])\n\n    y_best = objective_function(x_best)\n    evaluations_used += 1\n\n    # If budget is exhausted, return the best found\n    if evaluations_used >= budget:\n        return x_best\n\n    # Global random search phase: use ~40% of remaining budget\n    remaining = budget - evaluations_used\n    global_evals = max(1, int(0.4 * remaining))\n\n    # Use a simple quasi-random style sampling by scrambling uniforms\n    for i in range(global_evals):\n        # Low-discrepancy inspired: use deterministic fraction + noise\n        base = (i + 0.5) / (global_evals + 1.0)\n        # Create a vector by cycling the base with different powers\n        # and adding small noise for diversity.\n        u = np.mod(base * (np.arange(dim) + 1), 1.0)\n        u = np.mod(u + rng.uniform(0.0, 1.0 / (global_evals + 1.0), size=dim), 1.0)\n        x = bounds[:, 0] + u * (bounds[:, 1] - bounds[:, 0])\n        y = objective_function(x)\n        evaluations_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n        if evaluations_used >= budget:\n            return x_best\n\n    # Local search phase: use the rest of the budget\n    remaining = budget - evaluations_used\n    if remaining <= 0:\n        return x_best\n\n    # Initial step sizes proportional to box size\n    box_sizes = bounds[:, 1] - bounds[:, 0]\n    # Avoid zero step sizes\n    box_sizes[box_sizes == 0.0] = 1.0\n    base_sigma = 0.2 * box_sizes  # 20% of range\n\n    # Split remaining budget into iterations with small batches\n    # to periodically reduce step size and balance exploration.\n    # Choose batch size between 3 and 10 depending on dimension and remaining budget\n    batch_size = min(max(3, 2 * dim), 10)\n    iterations = max(1, remaining // batch_size)\n\n    sigma = base_sigma.copy()\n\n    for it in range(iterations):\n        # Gradually reduce step size\n        decay = 0.9 ** it\n        cur_sigma = sigma * decay\n\n        for _ in range(batch_size):\n            if evaluations_used >= budget:\n                break\n\n            # Sample a perturbation\n            noise = rng.normal(0.0, 1.0, size=dim)\n            step = noise * cur_sigma\n            x_candidate = _project_bounds(x_best + step, bounds)\n\n            y_candidate = objective_function(x_candidate)\n            evaluations_used += 1\n\n            if y_candidate < y_best:\n                x_best, y_best = x_candidate, y_candidate\n\n        if evaluations_used >= budget:\n            break\n\n    return x_best",
    "X": "4.523109202329552 4.33830195092097 6.527257356392106 3.7851285192856072 4.436798559710182 5.654505318071082 6.000244042109091"
}