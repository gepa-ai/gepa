{
    "score": 3.544134047625615,
    "Input": "McCourt12",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer:\n    - Global random search (50% of budget)\n    - Local search around best points (50% of budget)\n    - Warm-start from prev_best_x when available\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG for reproducibility isolation\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Handle degenerate cases\n    if budget <= 0:\n        # No evaluations allowed: just return center of bounds\n        return (low + high) / 2.0\n\n    # Helper to clip to bounds\n    def clip_to_bounds(x):\n        return np.minimum(high, np.maximum(low, x))\n\n    evals_used = 0\n\n    # --- Initialization / warm-start ---\n    candidates = []\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip_to_bounds(x0)\n            try:\n                y0 = objective_function(x0)\n                evals_used += 1\n                candidates.append((y0, x0))\n            except Exception:\n                # If the objective fails once, fall back to random search\n                candidates = []\n\n    # If no valid warm-start evaluation, sample one random point\n    if not candidates and evals_used < budget:\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        candidates.append((y, x))\n\n    best_y, best_x = min(candidates, key=lambda t: t[0])\n\n    # Remaining evaluations\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # --- Global random search phase ---\n    # Allocate about half of remaining to global search\n    global_budget = max(1, remaining // 2)\n    for _ in range(global_budget):\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y, best_x = y, x\n        if evals_used >= budget:\n            return best_x\n\n    # --- Local search phase (adaptive perturbation around best) ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Start with moderate radius, shrink over time\n    # relative to bounds span; fall back to 1.0 if span is zero\n    base_radius = 0.2\n    min_radius = 1e-3\n    scale = np.where(span > 0, span, 1.0)\n\n    for i in range(remaining):\n        # Linearly decreasing radius\n        t = i / max(1, remaining - 1)\n        radius = base_radius * (1.0 - t) + min_radius * t\n\n        noise = rng.normal(loc=0.0, scale=radius, size=dim) * scale\n        x = clip_to_bounds(best_x + noise)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y, best_x = y, x\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "0.45694667534589634 0.4467285540489875 0.0 1.0 0.38494115332516265 0.29974920755870854 0.6024995620022285"
}