{
    "score": 3.303172587007517,
    "Input": "Easom",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple blackbox minimization using a hybrid of\n    random sampling (global) and local search around the best point.\n    \"\"\"\n    rng = np.random.RandomState()\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config[\"budget\"])\n\n    lower = bounds[:, 0]\n    upper = bounds[:, 1]\n    span = upper - lower\n\n    def clip(x):\n        return np.clip(x, lower, upper)\n\n    evals_used = 0\n\n    # --- Initialization (use prev_best_x if available) ---\n    best_x = None\n    best_y = None\n\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            x0 = clip(x0)\n            y0 = objective_function(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n\n    # If we still have no incumbent, take one random sample\n    if best_x is None and evals_used < budget:\n        x0 = rng.uniform(lower, upper)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    if evals_used >= budget:\n        return best_x\n\n    # --- Global random search phase ---\n    # Allocate about 60% of budget to global exploration\n    remaining = budget - evals_used\n    global_budget = max(1, int(0.6 * remaining))\n\n    # Use low-discrepancy-like stratified sampling if possible\n    n_global = global_budget\n    for i in range(n_global):\n        # simple stratified attempt along each dim\n        t = (i + 0.5) / n_global\n        base = lower + t * span\n        # add local perturbation around the stratified base\n        perturb = rng.normal(scale=0.25, size=dim) * span\n        x = base + perturb\n        x = clip(x)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = x, y\n        if evals_used >= budget:\n            return best_x\n\n    # --- Local search phase around best found ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Local random search with decreasing radius\n    center = best_x.copy()\n    radius_start = 0.25\n    radius_end = 0.02\n    for k in range(remaining):\n        frac = k / max(1, remaining - 1)\n        radius = radius_start * (1 - frac) + radius_end * frac\n        step = rng.normal(scale=radius, size=dim) * span\n        x = center + step\n        x = clip(x)\n        y = objective_function(x)\n        if y < best_y:\n            best_x, best_y = x, y\n            center = x\n        evals_used += 1\n        if evals_used >= budget:\n            break\n\n    return best_x",
    "X": "1.0164748153034047 -0.1642324748032741"
}