{
    "score": -10.171464675969977,
    "Input": "McCourt09",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Black-box minimization with budgeted evaluations.\n\n    Hybrid strategy:\n    - Robust warm start from prev_best_x (if valid).\n    - Space-filling global exploration (Sobol-like / stratified fallback).\n    - Greedy selection of global samples to form a local candidate set.\n    - Focused local search around multiple promising points with adaptive radii.\n    - Coordinatewise local search plus opportunistic random refinements.\n    \"\"\"\n    rng = np.random.RandomState()\n\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    if budget <= 0:\n        return (low + high) / 2.0\n\n    def clip_to_bounds(x):\n        return np.minimum(high, np.maximum(low, x))\n\n    evals_used = 0\n    best_x = None\n    best_y = None\n\n    # Warm start from prev_best_x if valid\n    if prev_best_x is not None:\n        try:\n            x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n            if x0.size == dim:\n                x0 = clip_to_bounds(x0)\n                y0 = objective_function(x0)\n                evals_used += 1\n                best_x, best_y = x0, y0\n        except Exception:\n            best_x, best_y = None, None\n\n    # If no incumbent yet, use a random point (center-biased to reduce boundary pathologies)\n    if best_x is None and evals_used < budget:\n        center = (low + high) / 2.0\n        scale = 0.75  # shrink span to stay somewhat interior\n        x0 = clip_to_bounds(center + (rng.uniform(-0.5, 0.5, size=dim) * span * scale))\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Split budget: more global on tiny budgets, more local on larger ones\n    if budget < 40:\n        global_budget = max(1, int(0.7 * remaining))\n    else:\n        global_budget = max(3, int(0.45 * remaining))\n    if remaining > 1:\n        global_budget = min(global_budget, remaining - 1)\n    else:\n        global_budget = remaining\n    local_budget = remaining - global_budget\n\n    # Global exploration: Sobol-like / stratified low-discrepancy sampling\n    global_points = []\n    if global_budget > 0:\n        n = global_budget\n\n        def van_der_corput(i, base=2):\n            vdc, denom = 0.0, 1.0\n            while i:\n                i, remainder = divmod(i, base)\n                denom *= base\n                vdc += remainder / denom\n            return vdc\n\n        indices = np.arange(1, n + 1)\n        u = np.empty((n, dim), dtype=float)\n\n        for d in range(dim):\n            base = 2 + (d % 5)\n            for k, idx in enumerate(indices):\n                u[k, d] = van_der_corput(idx + d + 1, base=base)\n\n        X_global = low + u * span\n\n        # Jitter and clip to avoid grid-like patterns in high dim\n        if dim > 5:\n            jitter_scale = 0.02\n            X_global = clip_to_bounds(\n                X_global + rng.normal(0.0, jitter_scale, size=X_global.shape) * span\n            )\n\n        for i in range(n):\n            if evals_used >= budget:\n                break\n            xg = X_global[i]\n            yg = objective_function(xg)\n            evals_used += 1\n            global_points.append((yg, xg))\n            if best_y is None or yg < best_y:\n                best_x, best_y = xg, yg\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Select promising points for local search\n    local_starts = [best_x]\n    if global_points:\n        global_points.sort(key=lambda t: t[0])\n        for _, xg in global_points[:max(3, min(8, len(global_points)))]:\n            if len(local_starts) >= 8:\n                break\n            if not np.allclose(xg, best_x):\n                local_starts.append(xg)\n\n    m = len(local_starts)\n    if m == 0 or local_budget <= 0:\n        return best_x\n\n    # Distribute local_budget across starting points\n    per_start = max(1, local_budget // m)\n    extra = local_budget - per_start * m\n\n    # Radius scaling: slightly smaller default to favor fine local moves,\n    # but never below a small fraction of span to keep ability to move.\n    base_radius = 0.15 * np.maximum(span, 1e-8)\n    min_radius = 0.01 * np.maximum(span, 1e-8)\n    max_radius = 0.5 * np.maximum(span, 1e-8)\n\n    for i, x_center_init in enumerate(local_starts):\n        if evals_used >= budget:\n            break\n\n        steps_here = per_start + (1 if i < extra else 0)\n        if steps_here <= 0:\n            continue\n\n        x_center = x_center_init.astype(float).copy()\n        # Start with known value where available\n        if np.allclose(x_center, best_x):\n            y_center = float(best_y)\n        else:\n            y_center = None\n\n        radius = base_radius.copy()\n\n        for k in range(steps_here):\n            if evals_used >= budget:\n                break\n\n            # Ensure current value known\n            if y_center is None:\n                if evals_used >= budget:\n                    break\n                y_center = objective_function(x_center)\n                evals_used += 1\n                if best_y is None or y_center < best_y:\n                    best_x, best_y = x_center.copy(), float(y_center)\n\n            improved = False\n\n            # Coordinate-wise exploratory moves (randomized order to avoid bias)\n            coord_order = rng.permutation(dim)\n            for d in coord_order:\n                if evals_used >= budget:\n                    break\n\n                step_size = radius[d]\n                if step_size < min_radius[d]:\n                    continue\n\n                # Try positive direction\n                x_try = x_center.copy()\n                x_try[d] = np.clip(x_try[d] + step_size, low[d], high[d])\n                if x_try[d] != x_center[d] and evals_used < budget:\n                    y_try = objective_function(x_try)\n                    evals_used += 1\n                    if best_y is None or y_try < best_y:\n                        best_x, best_y = x_try.copy(), float(y_try)\n                    if y_try < y_center:\n                        x_center, y_center = x_try, float(y_try)\n                        improved = True\n                        continue  # move to next coordinate\n\n                if evals_used >= budget:\n                    break\n\n                # Try negative direction\n                x_try = x_center.copy()\n                x_try[d] = np.clip(x_try[d] - step_size, low[d], high[d])\n                if x_try[d] != x_center[d] and evals_used < budget:\n                    y_try = objective_function(x_try)\n                    evals_used += 1\n                    if best_y is None or y_try < best_y:\n                        best_x, best_y = x_try.copy(), float(y_try)\n                    if y_try < y_center:\n                        x_center, y_center = x_try, float(y_try)\n                        improved = True\n\n            # Adaptive radius: shrink if no coord improved, mildly expand otherwise\n            if improved:\n                radius = np.minimum(np.maximum(radius * 1.1, min_radius), max_radius)\n            else:\n                radius = np.maximum(radius * 0.5, min_radius)\n\n            # Opportunistic random refinement within current radius\n            if evals_used < budget:\n                # Slightly biased to stay closer to center while exploring\n                jitter = rng.normal(0.0, 0.25, size=dim) * radius\n                x_try = clip_to_bounds(x_center + jitter)\n                y_try = objective_function(x_try)\n                evals_used += 1\n                if best_y is None or y_try < best_y:\n                    best_x, best_y = x_try.copy(), float(y_try)\n                if y_try < y_center:\n                    x_center, y_center = x_try, float(y_try)\n\n    return np.asarray(best_x, dtype=float).reshape(dim,)",
    "X": "0.5941931445453564 1.0 0.20500799776697587"
}