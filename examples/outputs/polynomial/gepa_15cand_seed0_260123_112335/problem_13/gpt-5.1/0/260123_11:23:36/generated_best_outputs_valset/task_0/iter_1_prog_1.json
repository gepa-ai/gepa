{
    "score": 0.19180278955652644,
    "Input": "HelicalValley",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple black-box optimizer combining random search with local search\n    around the current best point.\n\n    Strategy:\n    - Use ~60% of budget for global random search in the box.\n    - Use remaining ~40% for Gaussian local search around best point.\n    - If prev_best_x is provided and feasible, start from it.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Ensure minimum sensible budget\n    if budget <= 0:\n        # Return middle of the box if no budget (shouldn't normally happen)\n        return (low + high) / 2.0\n\n    # Utility: clip into bounds\n    def clip_to_bounds(x):\n        return np.minimum(high, np.maximum(low, x))\n\n    evals_used = 0\n\n    # --- Initialization: use prev_best_x if available and valid ---\n    best_x = None\n    best_y = None\n\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n        if x0.size == dim:\n            x0 = clip_to_bounds(x0)\n            best_x = x0\n            best_y = objective_function(best_x)\n            evals_used += 1\n\n    # If no warm start, start from random point\n    if best_x is None:\n        best_x = np.random.uniform(low, high)\n        best_y = objective_function(best_x)\n        evals_used += 1\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Split budget: global then local\n    global_budget = max(1, int(0.6 * remaining))\n    local_budget = remaining - global_budget\n\n    # --- Global random search ---\n    # Sample points uniformly; keep the best\n    for _ in range(global_budget):\n        x = np.random.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = x, y\n\n    remaining = budget - evals_used\n    if remaining <= 0 or local_budget <= 0:\n        return best_x\n\n    # --- Local search around best_x ---\n    # Adaptive Gaussian search in shrinking neighborhoods\n    # Initial step size proportional to box size\n    base_sigma = 0.2 * span  # 20% of range per dimension\n    base_sigma[base_sigma == 0] = 1.0  # fallback if any zero-span (degenerate) dim\n\n    # Use a simple schedule: larger steps first, then smaller\n    # Split local_budget into 3 phases\n    phases = 3\n    steps_per_phase = max(1, local_budget // phases)\n    sigmas = [base_sigma,\n              0.5 * base_sigma,\n              0.25 * base_sigma]\n\n    for phase in range(phases):\n        if evals_used >= budget:\n            break\n        sigma = sigmas[phase]\n        # Number of steps in this phase, but do not exceed budget\n        steps = min(steps_per_phase, budget - evals_used)\n        for _ in range(steps):\n            # Propose candidate\n            noise = np.random.normal(loc=0.0, scale=sigma)\n            x = best_x + noise\n            x = clip_to_bounds(x)\n            y = objective_function(x)\n            evals_used += 1\n            if y < best_y:\n                best_x, best_y = x, y\n            if evals_used >= budget:\n                break\n\n    return best_x",
    "X": "0.9792464468122337 0.15890342490086523 0.2880493630332476"
}