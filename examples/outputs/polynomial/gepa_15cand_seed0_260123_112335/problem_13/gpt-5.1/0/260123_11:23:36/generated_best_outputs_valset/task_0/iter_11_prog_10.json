{
    "score": 3.465842746186667e-05,
    "Input": "HelicalValley",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Budget-aware hybrid black-box optimizer with warm start support.\n\n    Strategy:\n    1. Warm start evaluation (if any) + at least one random evaluation.\n    2. Global exploration via quasi-random low-discrepancy-style sampling with\n       an early, very-small-population local refinement if a strong point is seen.\n    3. Multiple short local search \"trust-region\" phases around the best.\n    4. Uses full evaluation budget and is robust on small/large budgets.\n    \"\"\"\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    if budget <= 0:\n        return (low + high) / 2.0\n\n    def clip_to_bounds(x):\n        return np.minimum(high, np.maximum(low, x))\n\n    rng = np.random.default_rng()\n    evals_used = 0\n\n    # Initialize best point\n    best_x = (low + high) / 2.0\n    best_y = None\n\n    # --- Safe evaluation helper (no exception propagation) ---\n    def safe_eval(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        try:\n            y = objective_function(x)\n        except Exception:\n            # In case of objective errors, skip this point but count it\n            evals_used += 1\n            return None\n        evals_used += 1\n        if best_y is None or y < best_y:\n            best_x, best_y = x.copy(), y\n        return y\n\n    # --- Warm start if available and valid ---\n    if prev_best_x is not None and evals_used < budget:\n        try:\n            x0 = np.asarray(prev_best_x, dtype=float).reshape(-1)\n            if x0.size == dim:\n                x0 = clip_to_bounds(x0)\n                y0 = safe_eval(x0)\n        except Exception:\n            pass\n\n    # --- Always at least one random sample to avoid bad warm start ---\n    if evals_used < budget:\n        x_rand = rng.uniform(low, high)\n        safe_eval(x_rand)\n\n    if best_y is None:  # Fallback if all previous attempts failed\n        if evals_used < budget:\n            x0 = (low + high) / 2.0\n            safe_eval(x0)\n        if best_y is None:\n            return clip_to_bounds((low + high) / 2.0)\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # --- Helper: quasi-random (low-discrepancy\u2013like) sampler in the box ---\n    def quasi_random_sequence(n_points, base=None, step_vec=None):\n        if n_points <= 0:\n            return np.empty((0, dim), dtype=float)\n        if base is None:\n            base_local = rng.random(dim)\n        else:\n            base_local = base\n        if step_vec is None:\n            phi = (np.sqrt(5.0) - 1.0) / 2.0\n            step = ((phi * (np.arange(1, dim + 1))) % 1.0)\n            rng.shuffle(step)\n        else:\n            step = step_vec\n        us = (base_local + np.arange(n_points)[:, None] * step[None, :]) % 1.0\n        return low + us * span\n\n    # --- Local search: derivative-free trust-region steps with coordinate bias ---\n    def local_search(center_x, center_y, budget_local, init_radius):\n        nonlocal evals_used, best_x, best_y\n\n        if budget_local <= 0 or evals_used >= budget:\n            return center_x, center_y\n\n        x_best = center_x.copy()\n        y_best = center_y\n        radius = init_radius\n\n        # Minimum radius to consider; relative to span\n        min_radius = 1e-4 * (span + 1e-12)\n        min_radius = np.maximum(min_radius, 1e-8)\n\n        # Number of proposals per iteration scales mildly with dim\n        proposals_per_iter = max(4, min(10 + dim, budget_local))\n\n        used_local = 0\n        no_improve_iters = 0\n\n        while used_local < budget_local and evals_used < budget:\n            lam = min(proposals_per_iter,\n                      budget_local - used_local,\n                      budget - evals_used)\n            if lam <= 0:\n                break\n\n            # Mixture of full-dimensional Gaussian steps and axis-aligned steps\n            n_axis = max(1, lam // 3)\n            n_full = lam - n_axis\n\n            xs = np.empty((lam, dim), dtype=float)\n\n            # Full-dimensional Gaussian proposals\n            if n_full > 0:\n                steps_full = rng.normal(size=(n_full, dim)) * radius\n                xs[:n_full] = clip_to_bounds(x_best + steps_full)\n\n            # Axis-aligned proposals (one or two coordinates perturbed)\n            if n_axis > 0:\n                xs_axis = np.repeat(x_best[None, :], n_axis, axis=0)\n                # choose 1 or 2 coords per axis step\n                for i in range(n_axis):\n                    k = 1 if dim == 1 else (2 if dim <= 10 else 3)\n                    idx = rng.choice(dim, size=k, replace=False)\n                    step = rng.normal(size=k) * radius[idx]\n                    xs_axis[i, idx] += step\n                xs_axis = clip_to_bounds(xs_axis)\n                xs[n_full:] = xs_axis\n\n            ys = []\n            for i in range(lam):\n                if evals_used >= budget:\n                    break\n                y = safe_eval(xs[i])\n                used_local += 1\n                if y is None:\n                    continue\n                ys.append(y)\n                if y < y_best:\n                    x_best, y_best = xs[i].copy(), y\n\n            if not ys:\n                break\n\n            ys = np.array(ys)\n            best_iter = np.min(ys)\n\n            if best_iter + 1e-12 < y_best:\n                no_improve_iters = 0\n                radius *= 1.5\n            else:\n                no_improve_iters += 1\n                radius *= 0.5\n\n            radius = np.maximum(radius, min_radius)\n\n            if no_improve_iters >= 6:\n                # Reset radius to moderate fraction of box\n                radius = 0.15 * (span + 1e-12) / np.sqrt(max(1, dim))\n                no_improve_iters = 0\n\n            if used_local >= budget_local or evals_used >= budget:\n                break\n\n        return x_best, y_best\n\n    # --- Global exploration phase ---\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    if remaining < 20:\n        global_budget = remaining\n    elif remaining < 60:\n        global_budget = int(0.6 * remaining)\n    elif remaining < 200:\n        global_budget = int(0.5 * remaining)\n    else:\n        global_budget = int(0.4 * remaining)\n\n    # Ensure at least 1 eval left for possible local work\n    if remaining >= 5:\n        global_budget = max(3, min(global_budget, remaining - 2))\n    else:\n        global_budget = remaining\n\n    local_budget_total = remaining - global_budget\n    if local_budget_total < 0:\n        local_budget_total = 0\n\n    # Use quasi-random sequence for global search\n    base = rng.random(dim)\n    phi = (np.sqrt(5.0) - 1.0) / 2.0\n    step_vec = ((phi * (np.arange(1, dim + 1))) % 1.0)\n    rng.shuffle(step_vec)\n\n    g_evals = min(global_budget, budget - evals_used)\n    xs_global = quasi_random_sequence(g_evals, base=base, step_vec=step_vec)\n\n    # Early small local refinement trigger threshold\n    # If we see significant improvement over current best, we do a tiny local search\n    early_local_done = False\n\n    for i in range(g_evals):\n        if evals_used >= budget:\n            break\n        x = xs_global[i]\n        prev_best_y = best_y\n        y = safe_eval(x)\n        if y is None:\n            continue\n\n        # Early local search: use a very small budget to refine promising region\n        if (not early_local_done and local_budget_total > 0 and\n                prev_best_y is not None and y < prev_best_y - abs(prev_best_y) * 1e-3):\n            tiny_budget = max(3, min(local_budget_total // 6, 8))\n            if tiny_budget > 0 and evals_used < budget:\n                init_radius = 0.1 * (span + 1e-12) / np.sqrt(max(1, dim))\n                _, _ = local_search(x, y, tiny_budget, init_radius)\n                early_local_done = True\n                local_budget_total = max(0, local_budget_total - tiny_budget)\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # If we have no local budget, spend everything remaining globally\n    if local_budget_total <= 0 or remaining <= 2:\n        xs_tail = quasi_random_sequence(remaining)\n        for i in range(xs_tail.shape[0]):\n            if evals_used >= budget:\n                break\n            safe_eval(xs_tail[i])\n        return best_x\n\n    # --- Multi-start local search around best_x ---\n    remaining = budget - evals_used\n    local_budget_total = min(local_budget_total, remaining)\n    if local_budget_total <= 0:\n        return best_x\n\n    n_phases = 3 if local_budget_total >= 60 else (2 if local_budget_total >= 20 else 1)\n    base_phase_budget = max(4, local_budget_total // n_phases)\n    allocated = 0\n\n    # Initial radius proportional to box size and dimension\n    base_radius = 0.2 * (span + 1e-12) / np.sqrt(max(1, dim))\n\n    for p in range(n_phases):\n        remaining = budget - evals_used\n        if remaining <= 0 or allocated >= local_budget_total:\n            break\n        phase_budget = min(base_phase_budget, local_budget_total - allocated, remaining)\n        if phase_budget <= 0:\n            break\n\n        center_x = best_x.copy()\n        center_y = best_y\n\n        init_radius = base_radius * (0.7 + 0.6 * rng.random())\n        center_x, center_y = local_search(center_x, center_y, phase_budget, init_radius)\n\n        if center_y < best_y:\n            best_x, best_y = center_x.copy(), center_y\n\n        allocated += phase_budget\n\n    # --- Tail: spend any remaining evaluations on additional global exploration ---\n    remaining = budget - evals_used\n    if remaining > 0:\n        xs_tail = quasi_random_sequence(remaining)\n        for i in range(xs_tail.shape[0]):\n            if evals_used >= budget:\n                break\n            safe_eval(xs_tail[i])\n\n    return best_x",
    "X": "0.9996835426354074 -0.002269966249170108 -0.003235223208271873"
}