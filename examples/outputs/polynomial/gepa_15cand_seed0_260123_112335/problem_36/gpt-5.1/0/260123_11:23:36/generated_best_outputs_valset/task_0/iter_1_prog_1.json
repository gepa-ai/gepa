{
    "score": -3.4,
    "Input": "Michalewicz",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Blackbox minimization with budget-aware hybrid search:\n    - Global search via low-discrepancy sampling (Sobol-like fallback) + local perturbations\n    - Local refinement around best-so-far using adaptive step sizes\n    - Supports warm-start from prev_best_x\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG to avoid side effects\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Clip a point to bounds\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # Evaluate and track best\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    def eval_point(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y = y\n            best_x = x.copy()\n        return y\n\n    if budget <= 0:\n        # Return a valid point even if no budget\n        if prev_best_x is not None:\n            return clip(np.asarray(prev_best_x, dtype=float)).reshape(dim)\n        return clip((low + high) * 0.5)\n\n    # Initialize from prev_best_x if provided\n    if prev_best_x is not None:\n        x0 = clip(np.asarray(prev_best_x, dtype=float).reshape(dim))\n        eval_point(x0)\n\n    # Always ensure at least one valid random start\n    if best_x is None and evals_used < budget:\n        x0 = low + span * rng.rand(dim)\n        eval_point(x0)\n\n    # If budget very small, do only random / best-known sampling\n    if budget - evals_used <= 3:\n        while evals_used < budget:\n            x = low + span * rng.rand(dim)\n            eval_point(x)\n        return best_x\n\n    remaining = budget - evals_used\n\n    # Global sampling phase: quasi-random + random\n    # Allocate about 60% of remaining to global exploration\n    global_evals = max(3, int(0.6 * remaining))\n    global_evals = min(global_evals, remaining)\n\n    def halton_sequence(size, dim, base_primes=None):\n        \"\"\"Simple Halton-like sequence for [0,1]^dim.\"\"\"\n        if base_primes is None:\n            # First primes; sufficient for moderate dim\n            base_primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        bases = base_primes[:dim]\n\n        def van_der_corput(n, base):\n            vdc, denom = 0.0, 1.0\n            while n:\n                n, remainder = divmod(n, base)\n                denom *= base\n                vdc += remainder / denom\n            return vdc\n\n        seq = np.empty((size, dim), dtype=float)\n        # Start index offset so different calls vary\n        start = rng.randint(1, 1000000)\n        for i in range(size):\n            idx = start + i\n            for d in range(dim):\n                seq[i, d] = van_der_corput(idx, bases[d % len(bases)])\n        return seq\n\n    # Use Halton-like sampling; fall back to pure random if issues\n    try:\n        halton_samples = halton_sequence(global_evals, dim)\n        global_points = clip(low + span * halton_samples)\n    except Exception:\n        global_points = clip(low + span * rng.rand(global_evals, dim))\n\n    for i in range(global_evals):\n        if evals_used >= budget:\n            break\n        eval_point(global_points[i])\n\n    # Remaining budget for local refinement\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Local search: adaptive perturbation around best_x\n    # Start with step proportional to span; shrink over time\n    base_step = 0.25  # fraction of span\n    min_step = 1e-3\n\n    for k in range(remaining):\n        if evals_used >= budget:\n            break\n\n        frac = (k + 1) / remaining\n        step_scale = max(min_step, base_step * (1.0 - 0.8 * frac))\n        # Gaussian perturbation scaled per-dimension\n        perturb = rng.randn(dim) * span * step_scale\n        candidate = clip(best_x + perturb)\n        eval_point(candidate)\n\n    return best_x",
    "X": "2.243824297603022 1.5852446625796492 2.2397862495644745 1.0931925743067563"
}