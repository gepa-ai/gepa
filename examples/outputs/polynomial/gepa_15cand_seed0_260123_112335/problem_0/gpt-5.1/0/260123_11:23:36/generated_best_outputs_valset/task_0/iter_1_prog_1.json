{
    "score": 12.37598351327113,
    "Input": "Ackley",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Simple derivative-free optimizer using adaptive random search\n    with optional warm start and basic local refinement.\n\n    Strategy:\n    - Use a fraction of the budget for broad random sampling.\n    - Keep track of the current best.\n    - Use the remaining budget for local search with shrinking step size.\n    - Warm start from prev_best_x if provided (and inside bounds).\n    \"\"\"\n    rng = np.random.RandomState()  # local RNG\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    # Helper: project to bounds\n    def clip_to_bounds(x):\n        return np.clip(x, low, high)\n\n    evals_used = 0\n\n    # Initialize best solution\n    if prev_best_x is not None:\n        x_best = np.asarray(prev_best_x, dtype=float).copy()\n        if x_best.shape != (dim,):\n            x_best = x_best.reshape(dim)\n        x_best = clip_to_bounds(x_best)\n        y_best = objective_function(x_best)\n        evals_used += 1\n    else:\n        # pure random start if no warm start\n        x_best = rng.uniform(low, high)\n        y_best = objective_function(x_best)\n        evals_used += 1\n\n    if evals_used >= budget:\n        return x_best\n\n    # Global exploration: random sampling\n    # Use about 40% of budget for global search (including initial eval)\n    global_budget = max(0, int(0.4 * budget) - evals_used)\n\n    for _ in range(global_budget):\n        x = rng.uniform(low, high)\n        y = objective_function(x)\n        evals_used += 1\n        if y < y_best:\n            x_best, y_best = x, y\n        if evals_used >= budget:\n            return x_best\n\n    # Local search around current best\n    remaining_budget = budget - evals_used\n    if remaining_budget <= 0:\n        return x_best\n\n    # Initial step size proportional to bounds\n    step = span / 4.0\n    min_step = span / 1e4 + 1e-12\n\n    # Number of iterations: one candidate per iteration\n    for _ in range(remaining_budget):\n        # Propose a local perturbation with Gaussian noise scaled by step\n        noise = rng.normal(loc=0.0, scale=1.0, size=dim)\n        x_candidate = x_best + noise * step\n        x_candidate = clip_to_bounds(x_candidate)\n\n        y_candidate = objective_function(x_candidate)\n        evals_used += 1\n\n        if y_candidate < y_best:\n            # Improvement: move center and slightly increase step\n            x_best, y_best = x_candidate, y_candidate\n            step = np.minimum(step * 1.2, span)\n        else:\n            # No improvement: shrink step\n            step = np.maximum(step * 0.7, min_step)\n\n        if evals_used >= budget:\n            break\n\n    return x_best",
    "X": "7.91876241622822 7.9641746781559215 -6.952582923676397 1.882703881869085 1.9933525348401495 4.021117697669637 0.9141844265672344 -4.026829788731996 0.5985437187996228 -1.9609734026872805 0.9931249453186065"
}