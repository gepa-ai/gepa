{
    "score": -18.35000085936651,
    "Input": "McCourt23",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef _random_in_bounds(bounds, rng):\n    return rng.uniform(bounds[:, 0], bounds[:, 1])\n\n\ndef _clip_to_bounds(x, bounds):\n    return np.clip(x, bounds[:, 0], bounds[:, 1])\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Blackbox minimization using a simple hybrid global-local search:\n    - Global: random / low-discrepancy style sampling\n    - Local: iterative Gaussian perturbation around best-so-far\n    \"\"\"\n    rng = np.random.RandomState()  # independent randomness per call\n\n    bounds = np.array(config[\"bounds\"], dtype=float)\n    dim = int(config.get(\"dim\", bounds.shape[0]))\n    budget = int(config.get(\"budget\", 1))\n\n    # Safety checks\n    if bounds.shape[0] != dim:\n        bounds = bounds.reshape(dim, 2)\n\n    # Edge case: no budget\n    if budget <= 0:\n        # Return mid-point of bounds as a fallback\n        return (bounds[:, 0] + bounds[:, 1]) / 2.0\n\n    # Helper: evaluate x safely\n    def eval_x(x):\n        return objective_function(x)\n\n    # --- Initialization: use prev_best_x if available and valid ---\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    # Validate prev_best_x\n    if prev_best_x is not None:\n        try:\n            x0 = np.asarray(prev_best_x, dtype=float).reshape(dim)\n            x0 = _clip_to_bounds(x0, bounds)\n            y0 = eval_x(x0)\n            evals_used += 1\n            best_x, best_y = x0, y0\n        except Exception:\n            best_x, best_y = None, np.inf\n\n    # If still no best_x, sample a fresh random point\n    if best_x is None and evals_used < budget:\n        x = _random_in_bounds(bounds, rng)\n        y = eval_x(x)\n        evals_used += 1\n        best_x, best_y = x, y\n\n    # If budget exhausted by initialization, return best_x\n    if evals_used >= budget:\n        return np.asarray(best_x, dtype=float)\n\n    # --- Allocate remaining budget between global and local search ---\n    remaining = budget - evals_used\n\n    # Heuristic allocation: 40% global, 60% local (at least 1 each if possible)\n    global_evals = max(1, int(0.4 * remaining))\n    local_evals = remaining - global_evals\n    if local_evals <= 0:\n        local_evals = 0\n\n    # --- Global search: random sampling with mild spread ---\n    for _ in range(global_evals):\n        if evals_used >= budget:\n            break\n        x = _random_in_bounds(bounds, rng)\n        y = eval_x(x)\n        evals_used += 1\n        if y < best_y:\n            best_x, best_y = x, y\n\n    if evals_used >= budget or local_evals <= 0:\n        return np.asarray(best_x, dtype=float)\n\n    # --- Local search: adaptive Gaussian perturbations around best_x ---\n    # Initial step size: fraction of the box size\n    box_sizes = bounds[:, 1] - bounds[:, 0]\n    # Avoid zero-size dimensions\n    box_sizes[box_sizes == 0.0] = 1.0\n    step_size = 0.2 * box_sizes\n\n    # We will adapt step_size based on success rate\n    successes = 0\n    attempts = 0\n    adapt_interval = max(5, dim)  # how often to adapt step size\n\n    for i in range(local_evals):\n        if evals_used >= budget:\n            break\n\n        noise = rng.normal(loc=0.0, scale=step_size, size=dim)\n        cand = best_x + noise\n        cand = _clip_to_bounds(cand, bounds)\n        y = eval_x(cand)\n        evals_used += 1\n        attempts += 1\n\n        if y < best_y:\n            best_x, best_y = cand, y\n            successes += 1\n\n        # Adaptive step-size control\n        if attempts >= adapt_interval:\n            success_rate = successes / float(attempts)\n            # Target success rate ~ 0.25\n            if success_rate < 0.15:\n                step_size *= 0.7\n            elif success_rate > 0.35:\n                step_size *= 1.3\n            successes = 0\n            attempts = 0\n\n    return np.asarray(best_x, dtype=float)",
    "X": "0.707631428195188 0.3896062365122524 0.0 0.7076388970074953 0.4095118950264701 0.8676916836881122"
}