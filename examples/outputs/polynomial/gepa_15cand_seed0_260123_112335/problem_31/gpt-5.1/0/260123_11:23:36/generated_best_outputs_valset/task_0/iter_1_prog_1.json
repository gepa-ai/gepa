{
    "score": -6.2826873605974045,
    "Input": "McCourt20",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\n\ndef solve(objective_function, config, prev_best_x=None):\n    \"\"\"\n    Blackbox minimization with a simple hybrid global-local search.\n    Uses random sampling + local coordinate search, with optional warm start.\n    \"\"\"\n    bounds = np.asarray(config[\"bounds\"], dtype=float)\n    dim = int(config[\"dim\"])\n    budget = int(config[\"budget\"])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n    if budget <= 0:\n        # Fallback: return center of bounds\n        return (low + high) / 2.0\n\n    evals_used = 0\n\n    def clip(x):\n        return np.clip(x, low, high)\n\n    # Evaluate a point and track budget\n    def eval_point(x):\n        nonlocal evals_used, best_x, best_y\n        if evals_used >= budget:\n            return None\n        y = objective_function(x)\n        evals_used += 1\n        if y < best_y:\n            best_y = y\n            best_x = x.copy()\n        return y\n\n    # Initialization\n    best_x = None\n    best_y = np.inf\n\n    # Use prev_best_x if available and valid\n    if prev_best_x is not None:\n        x0 = np.asarray(prev_best_x, dtype=float)\n        if x0.shape == (dim,):\n            x0 = clip(x0)\n            eval_point(x0)\n\n    # If no valid prev_best_x or no evaluation yet, sample a random point\n    if best_x is None:\n        x0 = np.random.uniform(low, high)\n        eval_point(x0)\n\n    # Use remaining budget for search\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return best_x\n\n    # Allocate ~60% for global search, 40% for local refinement\n    global_budget = max(1, int(0.6 * remaining))\n    local_budget = remaining - global_budget\n\n    # --- Global search: random sampling around space and near best_x ---\n    # Split: half purely uniform, half around current best with shrinking radius\n    num_uniform = global_budget // 2\n    num_localized = global_budget - num_uniform\n\n    # Pure uniform random search\n    for _ in range(num_uniform):\n        if evals_used >= budget:\n            break\n        x = np.random.uniform(low, high)\n        eval_point(x)\n\n    # Localized random search around current best with adaptive radius\n    for i in range(num_localized):\n        if evals_used >= budget:\n            break\n        # radius shrinks over iterations\n        frac = (i + 1) / max(1, num_localized)\n        radius = (1.0 - frac * 0.8)  # from 1.0*span to 0.2*span\n        step = (np.random.randn(dim) * 0.25) * span * radius\n        x = clip(best_x + step)\n        eval_point(x)\n\n    # --- Local coordinate search around best_x ---\n    if local_budget <= 0 or evals_used >= budget:\n        return best_x\n\n    # Simple coordinate-wise hill climbing with geometric step size\n    max_iters = max(1, local_budget // (2 * dim))  # each iter \u2248 2*dim evals\n    step_sizes = 0.25 * span  # initial step = 25% of range\n\n    for _ in range(max_iters):\n        improved = False\n        for j in range(dim):\n            if evals_used >= budget:\n                break\n            # Try positive step\n            x_pos = best_x.copy()\n            x_pos[j] = np.clip(x_pos[j] + step_sizes[j], low[j], high[j])\n            y_pos = eval_point(x_pos)\n            if evals_used >= budget:\n                break\n            # Try negative step\n            x_neg = best_x.copy()\n            x_neg[j] = np.clip(x_neg[j] - step_sizes[j], low[j], high[j])\n            y_neg = eval_point(x_neg)\n\n            # Improvement check already handled in eval_point\n            if (y_pos is not None and y_pos < best_y) or (y_neg is not None and y_neg < best_y):\n                improved = True\n\n        # If no improvement across all coordinates, shrink steps\n        step_sizes *= 0.5\n        if not improved or np.all(step_sizes < 1e-9 * span):\n            break\n\n    return best_x",
    "X": "0.7078458249382614 0.09841520781853282"
}