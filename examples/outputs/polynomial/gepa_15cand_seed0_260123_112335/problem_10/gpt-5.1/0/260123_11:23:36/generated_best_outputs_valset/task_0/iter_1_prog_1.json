{
    "score": 9.459173755388406e-08,
    "Input": "Easom",
    "Prints": "",
    "Logs": "",
    "Error": "",
    "code": "import numpy as np\n\ndef solve(objective_function, config, prev_best_x=None):\n    bounds = np.array(config['bounds'], dtype=float)\n    dim = int(config['dim'])\n    budget = int(config['budget'])\n\n    low = bounds[:, 0]\n    high = bounds[:, 1]\n    span = high - low\n\n    def clip_to_bounds(x):\n        return np.minimum(np.maximum(x, low), high)\n\n    # Use up to a few evaluations to stabilize a starting point\n    evals_used = 0\n    best_x = None\n    best_y = np.inf\n\n    rng = np.random.RandomState()\n\n    # Start from prev_best_x if provided\n    if prev_best_x is not None:\n        x0 = clip_to_bounds(np.asarray(prev_best_x, dtype=float))\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    # If no warm start or still budget left, add a few random initial samples\n    n_initial = min(5, max(0, budget - evals_used))\n    for _ in range(n_initial):\n        x0 = rng.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        if y0 < best_y:\n            best_x, best_y = x0, y0\n\n    # If we still don't have a starting point (very small budget), create one\n    if best_x is None:\n        x0 = rng.uniform(low, high)\n        y0 = objective_function(x0)\n        evals_used += 1\n        best_x, best_y = x0, y0\n\n    remaining = budget - evals_used\n    if remaining <= 0:\n        return np.asarray(best_x, dtype=float)\n\n    # Simple derivative-free local search: adaptive coordinate-wise search\n    x = best_x.copy()\n    step = span * 0.2  # start with 20% of range per dimension\n\n    while remaining > 0 and np.any(step > 1e-12 * span):\n        improved = False\n        for i in range(dim):\n            if remaining <= 0:\n                break\n\n            # Try positive step\n            xp = x.copy()\n            xp[i] = np.clip(xp[i] + step[i], low[i], high[i])\n            yp = objective_function(xp)\n            remaining -= 1\n            if yp < best_y:\n                best_x, best_y = xp, yp\n                x = xp\n                improved = True\n                if remaining <= 0:\n                    break\n                continue  # keep direction if improvement\n\n            if remaining <= 0:\n                break\n\n            # Try negative step\n            xn = x.copy()\n            xn[i] = np.clip(xn[i] - step[i], low[i], high[i])\n            yn = objective_function(xn)\n            remaining -= 1\n            if yn < best_y:\n                best_x, best_y = xn, yn\n                x = xn\n                improved = True\n                if remaining <= 0:\n                    break\n\n        # If no improvement in this sweep, reduce step and random-restart occasionally\n        if not improved:\n            step *= 0.5\n            # Occasional random restart to escape local minima if budget allows\n            if remaining > dim * 2:\n                xr = rng.uniform(low, high)\n                yr = objective_function(xr)\n                remaining -= 1\n                if yr < best_y:\n                    best_x, best_y = xr, yr\n                    x = xr\n\n    return np.asarray(best_x, dtype=float)",
    "X": "2.3404908233715105e-08 -2.0027982827741653e-08 -7.797240186846466e-09 -1.7358303239234374e-08 -3.853705976553101e-08"
}