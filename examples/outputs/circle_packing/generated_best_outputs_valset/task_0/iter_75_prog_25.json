{
    "best_score": 2.635983362593453,
    "best_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    BREAKTHROUGH approach: Large-Neighborhood Sequential Linear Programming (LN-SLP)\n    with exact LP for radii. We optimize centers by repeatedly solving LPs over\n    subsets of centers with linearized pairwise constraints and boundary constraints.\n    Multi-start + global SLP + LNS refinement + dual-informed subset selection.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    time_budget = max(1.0, float(timeout) - 0.5)\n    rng = np.random.default_rng(2026)\n    eps = 1e-6\n    r_min = 1e-8\n    all_scores = []\n\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def clamp01(xy):\n        return np.clip(xy, eps, 1.0 - eps)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Projection-like repair (feasible radii)\n        b = boundary_limits(centers)\n        r = np.minimum(b, 0.5).copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 1500\n        tol = 1e-10\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n):\n                ri = r[i]\n                for j in range(i + 1, n):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        r[j] = r_min_local\n                        continue\n                    s = ri + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = ri + r[j]\n                        if total <= 1e-16:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (ri / total)\n                            dec_j = excess * (r[j] / total)\n                        ri = max(r_min_local, ri - dec_i)\n                        r[j] = max(r_min_local, r[j] - dec_j)\n                r[i] = ri\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True, None\n\n    def solve_radii_lp(centers, r_min_local):\n        try:\n            from scipy.optimize import linprog\n            x = centers[:, 0]; y = centers[:, 1]\n            D = pairwise_distances(centers)\n            A_rows = []\n            b_vals = []\n            # Boundary constraints\n            for i in range(n):\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(y[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - y[i])\n            # Pairwise constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n                    A_rows.append(row); b_vals.append(D[i, j])\n            A_ub = np.array(A_rows, dtype=float) if A_rows else None\n            b_ub = np.array(b_vals, dtype=float) if b_vals else None\n            bounds = [(r_min_local, None)] * n\n            c = -np.ones(n, dtype=float)\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if getattr(res, \"success\", False) and res.x is not None:\n                r = np.array(res.x, dtype=float)\n                b = boundary_limits(centers)\n                r = np.minimum(r, b)\n                r = np.maximum(r, r_min_local)\n                # Try to extract duals for guidance\n                weights = None\n                try:\n                    ine = getattr(res, \"ineqlin\", None)\n                    if ine is not None and hasattr(ine, \"marginals\"):\n                        y_dual = np.array(ine.marginals, dtype=float)\n                        weights = -y_dual\n                        weights = np.maximum(weights, 0.0)\n                except Exception:\n                    weights = None\n                return r, True, weights\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def build_slp_subset_lp(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog  # noqa: F401\n        except Exception:\n            return None\n        m = len(subset_idx)\n        var_dim = 2 * m + n\n        idx_map = {subset_idx[k]: k for k in range(m)}\n        A_rows = []\n        b_vals = []\n\n        x = centers[:, 0]; y = centers[:, 1]\n        # Boundary constraints\n        for i in range(n):\n            # r_i - dx_i <= x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = -1.0\n            A_rows.append(row); b_vals.append(x[i])\n            # r_i + dx_i <= 1 - x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - x[i])\n            # r_i - dy_i <= y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = -1.0\n            A_rows.append(row); b_vals.append(y[i])\n            # r_i + dy_i <= 1 - y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - y[i])\n\n        # Pairwise linearization at current centers\n        diff = centers[:, None, :] - centers[None, :, :]\n        Dij = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dij = Dij[i, j]\n                if dij <= 1e-12:\n                    ang = rng.uniform(0, 2 * np.pi)\n                    ux, uy = np.cos(ang), np.sin(ang)\n                else:\n                    u = diff[i, j] / dij\n                    ux, uy = float(u[0]), float(u[1])\n                row = np.zeros(var_dim)\n                if i in idx_map:\n                    ki = idx_map[i]\n                    row[2 * ki + 0] += -ux\n                    row[2 * ki + 1] += -uy\n                if j in idx_map:\n                    kj = idx_map[j]\n                    row[2 * kj + 0] += ux\n                    row[2 * kj + 1] += uy\n                row[2 * m + i] += 1.0\n                row[2 * m + j] += 1.0\n                A_rows.append(row); b_vals.append(dij)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        bounds = []\n        # Displacement bounds (trust region and box)\n        for k, i in enumerate(subset_idx):\n            xi, yi = centers[i]\n            dx_lo = max(-trust, eps - xi)\n            dx_hi = min(trust, 1.0 - eps - xi)\n            dy_lo = max(-trust, eps - yi)\n            dy_hi = min(trust, 1.0 - eps - yi)\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n        # Radii bounds\n        for _ in range(n):\n            bounds.append((r_min, None))\n\n        c = np.zeros(var_dim, dtype=float)\n        c[2 * m:] = -1.0\n        return c, A_ub, b_ub, bounds\n\n    def slp_subset_step(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return centers, None, False\n        built = build_slp_subset_lp(centers, subset_idx, trust)\n        if built is None:\n            return centers, None, False\n        c, A_ub, b_ub, bounds = built\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not (getattr(res, \"success\", False) and res.x is not None):\n                return centers, None, False\n            m = len(subset_idx)\n            sol = np.array(res.x, dtype=float)\n            dxy = sol[:2 * m].reshape(m, 2)\n            r_lin = sol[2 * m:]\n            centers_new = centers.copy()\n            for idx_local, i in enumerate(subset_idx):\n                centers_new[i] = centers_new[i] + dxy[idx_local]\n            centers_new = clamp01(centers_new)\n            return centers_new, r_lin, True\n        except Exception:\n            return centers, None, False\n\n    def refine_by_slp_iterative(centers_init, max_outer=8, init_trust=0.08):\n        centers = centers_init.copy()\n        r, ok, _ = solve_radii_lp(centers, r_min)\n        if not ok:\n            return centers, r, False\n        best_score = float(np.sum(r))\n        best_centers = centers.copy()\n        trust = init_trust\n        for _ in range(max_outer):\n            if time_left() < 0.15:\n                break\n            subset_idx = list(range(n))\n            centers_cand, _, ok_step = slp_subset_step(centers, subset_idx, trust)\n            if not ok_step:\n                trust *= 0.7\n                if trust < 1e-3:\n                    break\n                continue\n            r_rep, ok2, _ = solve_radii_lp(centers_cand, r_min)\n            if ok2:\n                sc = float(np.sum(r_rep))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_rep\n                    best_score = sc\n                    best_centers = centers.copy()\n                    trust = min(trust * 1.3, 0.2)\n                else:\n                    trust *= 0.6\n                    if trust < 1e-3:\n                        break\n            else:\n                trust *= 0.6\n                if trust < 1e-3:\n                    break\n        return best_centers, r, True\n\n    def dual_inform_weights(centers, r, duals):\n        w = np.zeros(n, dtype=float)\n        if duals is not None:\n            num_boundary = 4 * n\n            if duals.shape[0] >= num_boundary:\n                db = duals[:num_boundary].reshape(n, 4)\n                w += np.sum(db, axis=1)\n                dp = duals[num_boundary:]\n                idx = 0\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        if idx >= dp.shape[0]:\n                            break\n                        val = dp[idx]\n                        w[i] += val\n                        w[j] += val\n                        idx += 1\n        with np.errstate(divide='ignore'):\n            inv_r = 1.0 / np.maximum(r, 1e-6)\n        w += 0.2 * inv_r\n        s = np.sum(w)\n        if s <= 0:\n            w = np.ones(n) / n\n        else:\n            w = w / s\n        return w\n\n    def init_hex_grid():\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        xs = np.linspace(0.1, 0.9, cols)\n        ys = np.linspace(0.1, 0.9, rows)\n        pts = []\n        cnt = 0\n        for r_idx, yy in enumerate(ys):\n            off = 0.0 if (r_idx % 2 == 0) else (xs[1] - xs[0]) * 0.5 if len(xs) > 1 else 0.0\n            for xx in xs:\n                if cnt >= K:\n                    break\n                x = np.clip(xx + off, 0.06, 0.94)\n                x += rng.normal(0, 0.01)\n                y = yy + rng.normal(0, 0.01)\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        while pts.shape[0] < K:\n            pts = np.vstack([pts, rng.uniform(0.15, 0.85, size=(1, 2))])\n        return clamp01(pts[:n])\n\n    def init_edges():\n        pts = []\n        e = 1e-3\n        corners = [[e, e], [1 - e, e], [e, 1 - e], [1 - e, 1 - e]]\n        pts.extend(corners)\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, e]); pts.append([t, 1 - e])\n            pts.append([e, t]); pts.append([1 - e, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0: pts = np.vstack([pts, [t, e]])\n                elif edge == 1: pts = np.vstack([pts, [t, 1 - e]])\n                elif edge == 2: pts = np.vstack([pts, [e, t]])\n                else: pts = np.vstack([pts, [1 - e, t]])\n        return clamp01(pts[:n])\n\n    def init_center_biased():\n        pts = 0.75 * rng.uniform(0.05, 0.95, size=(n, 2)) + 0.25 * 0.5\n        pts += rng.normal(0, 0.03, size=(n, 2))\n        return clamp01(pts)\n\n    def init_uniform():\n        return clamp01(rng.uniform(0.1, 0.9, size=(n, 2)))\n\n    def evaluate_centers(centers):\n        centers = clamp01(centers)\n        r, ok, duals = solve_radii_lp(centers, r_min)\n        if not ok or r is None:\n            b = boundary_limits(centers)\n            r = np.maximum(np.minimum(b, 0.5), r_min)\n            duals = None\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r)), duals\n\n    # Seed centers\n    seed_centers_list = []\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = clamp01(cb[:, :2].astype(float))\n                seed_centers_list.append(centers_cb)\n                for _ in range(2):\n                    seed_centers_list.append(clamp01(centers_cb + rng.normal(0, 0.01, size=centers_cb.shape)))\n        except Exception:\n            pass\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n    seed_centers_list.append(init_uniform())\n    seed_centers_list.append(clamp01(init_hex_grid() + rng.normal(0, 0.02, size=(n, 2))))\n\n    # Deduplicate seeds with slight jitter on collisions\n    unique_seeds = []\n    seen = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen:\n            c = clamp01(c + rng.normal(0, 0.005, size=c.shape))\n        unique_seeds.append(c)\n        seen.add(h)\n    seed_centers_list = unique_seeds\n\n    best_circles = None\n    best_score = -1e18\n    best_duals = None\n\n    # Initial evaluation of seeds\n    for centers in seed_centers_list:\n        circles, score, duals = evaluate_centers(centers)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # Global SLP refine on seeds\n    per_seed_time = max(0.4, time_left() / max(1, len(seed_centers_list)))\n    for centers0 in seed_centers_list:\n        if time_left() < 0.4:\n            break\n        t_seed_start = time.time()\n\n        def time_left_seed():\n            return min(time_left(), per_seed_time - (time.time() - t_seed_start))\n\n        if time_left_seed() < 0.2:\n            continue\n        centers_ref, r_ref, _ = refine_by_slp_iterative(centers0, max_outer=8, init_trust=0.08)\n        circles, score, duals = evaluate_centers(centers_ref)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # LNS loop\n    if best_circles is None:\n        centers = init_edges()\n        r, _, _ = solve_radii_lp(centers, r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    centers = best_circles[:, :2].copy()\n    r, ok, duals = solve_radii_lp(centers, r_min)\n    if ok:\n        best_duals = duals\n\n    stagnation = 0\n    attempts = 0\n    max_attempts = 1000000\n    while time_left() > 0.25 and attempts < max_attempts:\n        attempts += 1\n        # Determine subset size\n        base_m = 8\n        if stagnation > 8:\n            base_m = 12\n        elif stagnation > 3:\n            base_m = 10\n        m = int(np.clip(base_m + rng.integers(-2, 3), 5, 14))\n        # Select subset indices\n        weights = dual_inform_weights(centers, r if r is not None else np.ones(n), best_duals)\n        try:\n            subset_idx = rng.choice(n, size=m, replace=False, p=weights)\n        except Exception:\n            subset_idx = rng.choice(n, size=m, replace=False)\n        trust = 0.08 * (0.9 ** (stagnation // 3))\n        trust = float(np.clip(trust, 0.01, 0.2))\n\n        improved_local = False\n        for _ in range(3):\n            if time_left() < 0.15:\n                break\n            centers_cand, _, ok_step = slp_subset_step(centers, list(subset_idx), trust)\n            if not ok_step:\n                trust *= 0.7\n                continue\n            r_cand, ok_rep, duals_cand = solve_radii_lp(centers_cand, r_min)\n            if ok_rep:\n                sc = float(np.sum(r_cand))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_cand\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_cand\n                    all_scores.append(best_score)\n                    improved_local = True\n                    stagnation = 0\n                    trust = min(trust * 1.3, 0.25)\n                else:\n                    trust *= 0.8\n            else:\n                trust *= 0.7\n        if not improved_local:\n            stagnation += 1\n            # Occasional global SLP to escape\n            if stagnation % 6 == 0 and time_left() > 0.25:\n                centers_glob, r_glob, _ = refine_by_slp_iterative(centers, max_outer=5, init_trust=0.06)\n                circles_glob, sc_glob, duals_glob = evaluate_centers(centers_glob)\n                if sc_glob > best_score + 1e-10:\n                    best_score = sc_glob\n                    best_circles = circles_glob\n                    centers = circles_glob[:, :2].copy()\n                    r = circles_glob[:, 2].copy()\n                    best_duals = duals_glob\n                    all_scores.append(best_score)\n                    stagnation = 0\n            # Occasional random shake of a few smallest-r circles\n            if stagnation % 4 == 0:\n                if r is None or not np.all(np.isfinite(r)):\n                    r = boundary_limits(centers)\n                kshake = max(3, n // 6)\n                idx_sorted = np.argsort(r)\n                picks = idx_sorted[:kshake]\n                perturb = rng.normal(0, 0.02 * (1 + 0.05 * stagnation), size=(len(picks), 2))\n                centers_shake = centers.copy()\n                centers_shake[picks] = clamp01(centers_shake[picks] + perturb)\n                r_shake, ok_sh, duals_sh = solve_radii_lp(centers_shake, r_min)\n                if ok_sh:\n                    sc = float(np.sum(r_shake))\n                    if sc > best_score + 1e-10:\n                        centers = centers_shake\n                        r = r_shake\n                        best_score = sc\n                        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                        best_duals = duals_sh\n                        all_scores.append(best_score)\n                        stagnation = 0\n\n        if stagnation > 18:\n            # Re-diversify by mixing with a new seed\n            seed = init_uniform() if rng.random() < 0.5 else init_hex_grid()\n            centers_mix = 0.5 * centers + 0.5 * seed\n            centers_mix = clamp01(centers_mix)\n            r_mix, ok_mix, duals_mix = solve_radii_lp(centers_mix, r_min)\n            if ok_mix:\n                sc = float(np.sum(r_mix))\n                if sc > best_score + 1e-10:\n                    centers = centers_mix\n                    r = r_mix\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_mix\n                    all_scores.append(best_score)\n                    stagnation = 0\n                else:\n                    stagnation = max(stagnation - 5, 0)\n\n    # Final feasibility and polish\n    try:\n        centers_final = best_circles[:, :2]\n        r_final, ok_fin, _ = solve_radii_lp(centers_final, r_min)\n        if ok_fin and r_final is not None:\n            best_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n            best_score = float(np.sum(r_final))\n            if not all_scores or best_score > all_scores[-1] + 1e-9:\n                all_scores.append(best_score)\n    except Exception:\n        pass\n\n    return {\n        'circles': best_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [float(best_score)]\n    }",
    "best_circles": [
        [
            0.11077901671966639,
            0.11077901671966639,
            0.11077901671966639
        ],
        [
            0.5153992163661161,
            0.10306053126393246,
            0.10306053126393246
        ],
        [
            0.613076499994525,
            0.29474605781968927,
            0.11207715950229302
        ],
        [
            0.7246573837586558,
            0.49553178427918265,
            0.11762968601506729
        ],
        [
            0.7252167313314248,
            0.10679014311934755,
            0.10679014311934755
        ],
        [
            0.9153604988662506,
            0.08463950113374943,
            0.0846395011337494
        ],
        [
            0.31674147297326405,
            0.09573232964633309,
            0.09573232964633309
        ],
        [
            0.4023652397448289,
            0.2716298589000858,
            0.09989838376443813
        ],
        [
            0.25795060646286533,
            0.5952196897821257,
            0.09601903358763698
        ],
        [
            0.9211396263668015,
            0.49728446230250795,
            0.07886037363319853
        ],
        [
            0.257582975859306,
            0.4033587729067609,
            0.09584232681509547
        ],
        [
            0.8697788899752384,
            0.2946094969862898,
            0.13022111002476155
        ],
        [
            0.09259207743290036,
            0.6859430542439497,
            0.09259207743290036
        ],
        [
            0.23632644078497028,
            0.23971052363714015,
            0.0691806708924314
        ],
        [
            0.2370411109101696,
            0.7593524040484768,
            0.06944019068441097
        ],
        [
            0.4700366231283937,
            0.49866812652825826,
            0.13701040839353817
        ],
        [
            0.8667414311838908,
            0.7023095390776545,
            0.1332585688161092
        ],
        [
            0.6183341874734786,
            0.70260957331053,
            0.11514890577961769
        ],
        [
            0.09239155118359361,
            0.31311581706328395,
            0.09239155118359361
        ],
        [
            0.09392735904404867,
            0.4994283974292702,
            0.09392735904404867
        ],
        [
            0.4039572935920608,
            0.7269057474529772,
            0.10060038554761887
        ],
        [
            0.5174044298012489,
            0.8965327469632001,
            0.10346725303679993
        ],
        [
            0.7260471808912048,
            0.8948173963249862,
            0.10518260367501375
        ],
        [
            0.9150737202275089,
            0.9150737202275089,
            0.08492627977249112
        ],
        [
            0.11115617258096631,
            0.8888438274190337,
            0.11115617258096631
        ],
        [
            0.3179199547328567,
            0.9038486594716071,
            0.09615134052839291
        ]
    ],
    "code_candidate": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Breakthrough optimizer: Global and Large-Neighborhood CCCP (LP) for centers,\n    exact LP for radii. Iteratively linearizes pairwise distance constraints and\n    solves a linear program to move centers within trust regions, with periodic\n    re-optimization of radii. Augmented by neighborhood re-optimizations to escape\n    local minima. Multi-start with diverse inits.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    time_budget = max(1.0, float(timeout) - 0.5)\n    rng = np.random.default_rng(12345)\n\n    eps = 1e-6\n    r_min = 1e-10\n    all_scores = []\n\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    pairs = [(i, j) for i in range(n) for j in range(i + 1, n)]\n\n    def clamp_centers(centers):\n        return np.clip(centers, eps, 1.0 - eps)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        return np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n\n    def build_lp_matrices_radii(centers):\n        # Build A_ub r <= b_ub for LP optimizing radii with centers fixed\n        x = centers[:, 0]\n        y = centers[:, 1]\n        D = pairwise_distances(centers)\n        A_rows = []\n        b_vals = []\n        for i in range(n):\n            row = np.zeros(n, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row); b_vals.append(x[i])\n            row = np.zeros(n, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - x[i])\n            row = np.zeros(n, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row); b_vals.append(y[i])\n            row = np.zeros(n, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - y[i])\n        for (i, j) in pairs:\n            row = np.zeros(n, dtype=float)\n            row[i] = 1.0; row[j] = 1.0\n            A_rows.append(row); b_vals.append(D[i, j])\n        if A_rows:\n            A_ub = np.vstack(A_rows)\n            b_ub = np.array(b_vals, dtype=float)\n        else:\n            A_ub, b_ub = None, None\n        return A_ub, b_ub\n\n    def solve_radii_lp(centers, r_min_local=r_min):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            # Fallback to simple projection if scipy is unavailable\n            b = boundary_limits(centers)\n            r = np.minimum(b, 0.5)\n            r = np.maximum(r, r_min_local)\n            # Simple pairwise projection to remove overlaps\n            D = pairwise_distances(centers)\n            for _ in range(1000):\n                changed = False\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        s = r[i] + r[j]\n                        dij = D[i, j]\n                        if s > dij:\n                            excess = s - dij\n                            dec = 0.5 * excess\n                            r[i] = max(r_min_local, r[i] - dec)\n                            r[j] = max(r_min_local, r[j] - dec)\n                            changed = True\n                if not changed:\n                    break\n            r = np.minimum(r, b)\n            r = np.maximum(r, r_min_local)\n            return r, True\n\n        A_ub, b_ub = build_lp_matrices_radii(centers)\n        bounds = [(r_min_local, None)] * n\n        c = -np.ones(n, dtype=float)\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if hasattr(res, \"success\") and res.success and res.x is not None:\n                r = np.array(res.x, dtype=float)\n                b = boundary_limits(centers)\n                r = np.minimum(r, b)\n                r = np.maximum(r, r_min_local)\n                return r, True\n        except Exception:\n            pass\n        # Fallback feasible\n        b = boundary_limits(centers)\n        r = np.maximum(np.minimum(b, 0.5), r_min_local)\n        return r, False\n\n    def score_from_radii(r):\n        return float(np.sum(r))\n\n    def cccp_lp_step(centers0, move_mask, radii_fixed, delta):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return None, None, False\n        centers0 = centers0.copy()\n        move_idx = np.where(move_mask)[0]\n        m = len(move_idx)\n        if m == 0:\n            return None, None, False\n\n        # Variable order: [x_i for moving], [y_i for moving], [r_i for moving]\n        idx_map = {idx: k for k, idx in enumerate(move_idx)}\n        m_vars = 3 * m\n\n        def ix(i): return idx_map[i]\n        def iy(i): return m + idx_map[i]\n        def ir(i): return 2 * m + idx_map[i]\n\n        A_rows = []\n        b_vals = []\n\n        # Boundary constraints: r_i <= x_i; r_i + x_i <= 1; r_i <= y_i; r_i + y_i <= 1\n        for i in move_idx:\n            row = np.zeros(m_vars, dtype=float); row[ir(i)] = 1.0; row[ix(i)] = -1.0\n            A_rows.append(row); b_vals.append(0.0)\n            row = np.zeros(m_vars, dtype=float); row[ir(i)] = 1.0; row[ix(i)] = 1.0\n            A_rows.append(row); b_vals.append(1.0)\n            row = np.zeros(m_vars, dtype=float); row[ir(i)] = 1.0; row[iy(i)] = -1.0\n            A_rows.append(row); b_vals.append(0.0)\n            row = np.zeros(m_vars, dtype=float); row[ir(i)] = 1.0; row[iy(i)] = 1.0\n            A_rows.append(row); b_vals.append(1.0)\n\n        # Trust-region bounds incorporated as variable bounds below\n\n        # Pairwise constraints: linearized at centers0 (first-order Taylor)\n        # r_i + r_j - v\u00b7c_i + v\u00b7c_j <= d0 - v\u00b7c_i0 + v\u00b7c_j0\n        # If one is fixed, move its term to RHS and subtract fixed radius\n        D0 = pairwise_distances(centers0)\n        for (i, j) in pairs:\n            ci0 = centers0[i]; cj0 = centers0[j]\n            d0 = D0[i, j]\n            if d0 <= 1e-12:\n                ang = rng.uniform(0, 2 * np.pi)\n                v = np.array([np.cos(ang), np.sin(ang)], dtype=float)\n                d0 = 0.0\n            else:\n                v = (ci0 - cj0) / d0\n\n            i_m = move_mask[i]\n            j_m = move_mask[j]\n\n            if i_m and j_m:\n                row = np.zeros(m_vars, dtype=float)\n                row[ir(i)] += 1.0\n                row[ir(j)] += 1.0\n                row[ix(i)] += -v[0]; row[iy(i)] += -v[1]\n                row[ix(j)] += v[0];  row[iy(j)] += v[1]\n                b = d0 - float(v @ ci0) + float(v @ cj0)\n                A_rows.append(row); b_vals.append(b)\n            elif i_m and (not j_m):\n                row = np.zeros(m_vars, dtype=float)\n                row[ir(i)] += 1.0\n                row[ix(i)] += -v[0]; row[iy(i)] += -v[1]\n                rj = radii_fixed[j] if radii_fixed is not None and j < len(radii_fixed) else 0.0\n                b = d0 - float(v @ ci0) + float(v @ cj0) - rj\n                A_rows.append(row); b_vals.append(b)\n            elif (not i_m) and j_m:\n                row = np.zeros(m_vars, dtype=float)\n                row[ir(j)] += 1.0\n                row[ix(j)] += v[0]; row[iy(j)] += v[1]\n                ri = radii_fixed[i] if radii_fixed is not None and i < len(radii_fixed) else 0.0\n                b = d0 - float(v @ ci0) + float(v @ cj0) - ri\n                A_rows.append(row); b_vals.append(b)\n            else:\n                # both fixed: ignore\n                pass\n\n        A_ub = np.vstack(A_rows) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        # Variable bounds with trust region around centers0\n        bounds = []\n        for i in move_idx:\n            if delta is None:\n                lx = eps; ux = 1.0 - eps\n                ly = eps; uy = 1.0 - eps\n            else:\n                lx = max(eps, float(centers0[i, 0] - delta))\n                ux = min(1.0 - eps, float(centers0[i, 0] + delta))\n                ly = max(eps, float(centers0[i, 1] - delta))\n                uy = min(1.0 - eps, float(centers0[i, 1] + delta))\n            bounds.append((lx, ux))\n        for i in move_idx:\n            if delta is None:\n                ly = eps; uy = 1.0 - eps\n            else:\n                ly = max(eps, float(centers0[i, 1] - delta))\n                uy = min(1.0 - eps, float(centers0[i, 1] + delta))\n            bounds.append((ly, uy))\n        for i in move_idx:\n            bounds.append((r_min, None))\n\n        c = np.zeros(m_vars, dtype=float)\n        c[2 * m: 3 * m] = -1.0\n\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not (hasattr(res, \"success\") and res.success and res.x is not None):\n                return None, None, False\n            sol = np.array(res.x, dtype=float)\n            centers_new = centers0.copy()\n            rx = sol[0:m]; ry = sol[m:2 * m]; rr = sol[2 * m:3 * m]\n            for k, i in enumerate(move_idx):\n                centers_new[i, 0] = rx[k]\n                centers_new[i, 1] = ry[k]\n            rr = np.maximum(rr, r_min)\n            return clamp_centers(centers_new), rr, True\n        except Exception:\n            return None, None, False\n\n    def run_cccp_global(centers_init, max_iters=20, delta0=0.18):\n        centers = centers_init.copy()\n        r, ok = solve_radii_lp(centers)\n        if not ok:\n            r, _ = solve_radii_lp(centers)\n        best_local_centers = centers.copy()\n        best_local_r = r.copy()\n        best_local_score = score_from_radii(r)\n\n        delta = float(delta0)\n        move_mask_all = np.ones(n, dtype=bool)\n        no_improve = 0\n\n        for it in range(max_iters):\n            if time_left() < 0.1:\n                break\n            centers_new, _, ok_lp = cccp_lp_step(centers, move_mask_all, r, delta)\n            if not ok_lp or centers_new is None:\n                delta *= 0.6\n                no_improve += 1\n                if no_improve > 5:\n                    break\n                continue\n            r_new, ok_r = solve_radii_lp(centers_new)\n            if not ok_r:\n                r_new, _ = solve_radii_lp(centers_new)\n            sc_new = score_from_radii(r_new)\n            if sc_new > best_local_score + 1e-12:\n                centers = centers_new\n                r = r_new\n                best_local_centers = centers_new.copy()\n                best_local_r = r_new.copy()\n                best_local_score = sc_new\n                delta = min(0.5, delta * 1.2)\n                no_improve = max(no_improve - 1, 0)\n            else:\n                delta *= 0.7\n                no_improve += 1\n                if no_improve > 8:\n                    break\n        return best_local_centers, best_local_r, best_local_score\n\n    def run_lns(centers_start, r_start, rounds=200):\n        centers = centers_start.copy()\n        r = r_start.copy()\n        best_c = centers.copy()\n        best_r = r.copy()\n        best_score = score_from_radii(r)\n\n        for t in range(rounds):\n            if time_left() < 0.12:\n                break\n            # Random subset size\n            k = int(rng.integers(6, 12))\n            move_idx = rng.choice(n, size=k, replace=False)\n            move_mask = np.zeros(n, dtype=bool)\n            move_mask[move_idx] = True\n            delta = float(rng.uniform(0.10, 0.28))\n\n            # Do a few CCCP steps on this neighborhood\n            local_centers = centers.copy()\n            local_r = r.copy()\n            local_best_centers = centers.copy()\n            local_best_r = r.copy()\n            local_best_score = best_score\n            success_any = False\n            for step in range(3):\n                c_new, _, ok_lp = cccp_lp_step(local_centers, move_mask, local_r, delta)\n                if not ok_lp or c_new is None:\n                    delta *= 0.7\n                    continue\n                r_new, ok_r = solve_radii_lp(c_new)\n                if not ok_r:\n                    r_new, _ = solve_radii_lp(c_new)\n                sc_new = score_from_radii(r_new)\n                if sc_new > local_best_score + 1e-12:\n                    local_centers = c_new\n                    local_r = r_new\n                    local_best_centers = c_new.copy()\n                    local_best_r = r_new.copy()\n                    local_best_score = sc_new\n                    success_any = True\n                    delta = min(0.5, delta * 1.15)\n                else:\n                    delta *= 0.75\n            # Accept neighborhood move if improved\n            if success_any and local_best_score > best_score + 1e-12:\n                centers = local_best_centers\n                r = local_best_r\n                best_c = centers.copy()\n                best_r = r.copy()\n                best_score = local_best_score\n\n            # Occasional random shake to escape stagnation\n            if (t + 1) % 15 == 0:\n                idxs = rng.choice(n, size=rng.integers(2, 6), replace=False)\n                shake = np.zeros_like(centers)\n                shake[idxs] = rng.normal(0, 0.015, size=(len(idxs), 2))\n                c_try = clamp_centers(centers + shake)\n                r_try, _ = solve_radii_lp(c_try)\n                sc_try = score_from_radii(r_try)\n                if sc_try > best_score + 1e-12:\n                    centers = c_try\n                    r = r_try\n                    best_c = centers.copy()\n                    best_r = r.copy()\n                    best_score = sc_try\n\n        return best_c, best_r, best_score\n\n    # Initializations\n    def hex_jitter_init(N):\n        rows = int(np.floor(np.sqrt(N)))\n        cols = int(np.ceil(N / rows))\n        xs = np.linspace(0.12, 0.88, cols)\n        ys = np.linspace(0.12, 0.88, rows)\n        centers = []\n        idx = 0\n        for ri, yy in enumerate(ys):\n            offset = (xs[1] - xs[0]) * 0.5 if (ri % 2 == 1 and len(xs) > 1) else 0.0\n            for xx in xs:\n                if idx >= N:\n                    break\n                xi = np.clip(xx + offset, 0.05, 0.95)\n                jitter = 0.02\n                centers.append([xi + rng.normal(0, jitter), yy + rng.normal(0, jitter)])\n                idx += 1\n            if idx >= N:\n                break\n        centers = np.array(centers, dtype=float)\n        while centers.shape[0] < N:\n            centers = np.vstack([centers, rng.uniform(0.1, 0.9, size=(1, 2))])\n        return clamp_centers(centers)\n\n    def uniform_init(N):\n        return clamp_centers(rng.uniform(0.1, 0.9, size=(N, 2)))\n\n    def edge_bias_init(N):\n        k_edge = N // 3\n        k_int = N - k_edge\n        centers = [rng.uniform(0.18, 0.82, size=(k_int, 2))]\n        for _ in range(k_edge):\n            edge = rng.integers(0, 4)\n            t = rng.uniform(0.08, 0.92)\n            if edge == 0:\n                pt = [t, 0.06 + 0.02 * rng.random()]\n            elif edge == 1:\n                pt = [t, 0.94 - 0.02 * rng.random()]\n            elif edge == 2:\n                pt = [0.06 + 0.02 * rng.random(), t]\n            else:\n                pt = [0.94 - 0.02 * rng.random(), t]\n            centers.append(pt)\n        centers = np.vstack(centers)\n        return clamp_centers(centers[:N])\n\n    def corner_spokes_init(N):\n        corners = np.array([[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]], dtype=float)\n        centers = []\n        k = N // 4\n        rem = N - 4 * k\n        for c in corners:\n            for _ in range(k):\n                ang = rng.uniform(0, 2 * np.pi)\n                rad = rng.uniform(0.0, 0.25)\n                pt = c + rad * np.array([np.cos(ang), np.sin(ang)])\n                centers.append(pt)\n        for _ in range(rem):\n            centers.append(rng.uniform(0.2, 0.8, size=2))\n        centers = np.array(centers, dtype=float)\n        return clamp_centers(centers)\n\n    init_candidates = []\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = clamp_centers(cb[:, :2].astype(float))\n                init_candidates.append(centers_cb)\n                for _ in range(2):\n                    init_candidates.append(clamp_centers(centers_cb + rng.normal(0, 0.01, size=centers_cb.shape)))\n        except Exception:\n            pass\n\n    init_candidates.append(hex_jitter_init(n))\n    init_candidates.append(uniform_init(n))\n    init_candidates.append(edge_bias_init(n))\n    init_candidates.append(corner_spokes_init(n))\n    for _ in range(2):\n        init_candidates.append(uniform_init(n))\n\n    best_circles = None\n    best_score = -1e18\n\n    def try_update_best(centers, r):\n        nonlocal best_circles, best_score, all_scores\n        score = score_from_radii(r)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n            all_scores.append(best_score)\n            return True\n        return False\n\n    # Multi-start global CCCP\n    for init_centers in init_candidates:\n        if time_left() < 0.5:\n            break\n        c0 = init_centers.copy()\n        r0, _ = solve_radii_lp(c0)\n        try_update_best(c0, r0)\n        c1, r1, sc1 = run_cccp_global(c0, max_iters=18, delta0=0.18)\n        try_update_best(c1, r1)\n\n    # Large Neighborhood Search from best\n    if best_circles is None or not np.all(np.isfinite(best_circles)):\n        centers = clamp_centers(rng.uniform(0.1, 0.9, size=(n, 2)))\n        r, _ = solve_radii_lp(centers)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = score_from_radii(r)\n        all_scores.append(best_score)\n\n    centers = best_circles[:, :2]\n    r = best_circles[:, 2]\n    remaining = max(0.0, time_left())\n    if remaining > 0.25:\n        rounds = int(200 * min(1.0, remaining / (time_budget + 1e-9)))\n        c2, r2, sc2 = run_lns(centers, r, rounds=rounds)\n        try_update_best(c2, r2)\n\n    # Final radii optimization to ensure feasibility and tighten\n    try:\n        centers_final = best_circles[:, :2]\n        r_final, _ = solve_radii_lp(centers_final)\n        best_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n        best_score = score_from_radii(r_final)\n        if not all_scores or best_score > max(all_scores) + 1e-12:\n            all_scores.append(best_score)\n    except Exception:\n        pass\n\n    return {\n        'circles': best_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [float(best_score)]\n    }",
    "code_score": 2.6359833304154066,
    "refiner_prompt": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    BREAKTHROUGH approach: Large-Neighborhood Sequential Linear Programming (LN-SLP)\n    with exact LP for radii. We optimize centers by repeatedly solving LPs over\n    subsets of centers with linearized pairwise constraints and boundary constraints.\n    Multi-start + global SLP + LNS refinement + dual-informed subset selection.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    time_budget = max(1.0, float(timeout) - 0.5)\n    rng = np.random.default_rng(2026)\n    eps = 1e-6\n    r_min = 1e-8\n    all_scores = []\n\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def clamp01(xy):\n        return np.clip(xy, eps, 1.0 - eps)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Projection-like repair (feasible radii)\n        b = boundary_limits(centers)\n        r = np.minimum(b, 0.5).copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 3000\n        tol = 1e-11\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        r[j] = r_min_local\n                        continue\n                    s = r[i] + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = r[i] + r[j]\n                        if total <= 1e-16:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (r[i] / total)\n                            dec_j = excess * (r[j] / total)\n                        r[i] = max(r_min_local, r[i] - dec_i)\n                        r[j] = max(r_min_local, r[j] - dec_j)\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True, None\n\n    def solve_radii_lp(centers, r_min_local):\n        try:\n            from scipy.optimize import linprog\n            x = centers[:, 0]; y = centers[:, 1]\n            D = pairwise_distances(centers)\n            A_rows = []\n            b_vals = []\n            # Boundary constraints\n            for i in range(n):\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(y[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - y[i])\n            # Pairwise constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n                    A_rows.append(row); b_vals.append(D[i, j])\n            A_ub = np.array(A_rows, dtype=float) if A_rows else None\n            b_ub = np.array(b_vals, dtype=float) if b_vals else None\n            bounds = [(r_min_local, None)] * n\n            c = -np.ones(n, dtype=float)\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if getattr(res, \"success\", False) and res.x is not None:\n                r = np.array(res.x, dtype=float)\n                b = boundary_limits(centers)\n                r = np.minimum(r, b)\n                r = np.maximum(r, r_min_local)\n                # Try to extract duals for guidance\n                weights = None\n                try:\n                    ine = getattr(res, \"ineqlin\", None)\n                    if ine is not None and hasattr(ine, \"marginals\"):\n                        y_dual = np.array(ine.marginals, dtype=float)\n                        # Our primal is maximize sum r; linprog solves minimize -sum r\n                        # Dual marginals correspond to d(min obj)/d b; for max, negate:\n                        weights = -y_dual\n                        weights = np.maximum(weights, 0.0)\n                except Exception:\n                    weights = None\n                return r, True, weights\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    # SLP builder for subset\n    def build_slp_subset_lp(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog  # noqa: F401\n        except Exception:\n            return None\n        m = len(subset_idx)\n        # Variable order: [dx_0, dy_0, dx_1, dy_1, ..., for subset order] then [r_0..r_{n-1}]\n        var_dim = 2 * m + n\n        idx_map = {subset_idx[k]: k for k in range(m)}\n        A_rows = []\n        b_vals = []\n\n        x = centers[:, 0]; y = centers[:, 1]\n        # Boundary constraints: r_i <= x_i + dx_i ; r_i + dx_i <= 1 - x_i ; r_i <= y_i + dy_i ; r_i + dy_i <= 1 - y_i\n        for i in range(n):\n            # r_i - dx_i <= x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = -1.0\n            A_rows.append(row); b_vals.append(x[i])\n            # r_i + dx_i <= 1 - x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - x[i])\n            # r_i - dy_i <= y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = -1.0\n            A_rows.append(row); b_vals.append(y[i])\n            # r_i + dy_i <= 1 - y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - y[i])\n\n        # Pairwise linearization at current centers\n        diff = centers[:, None, :] - centers[None, :, :]\n        Dij = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dij = Dij[i, j]\n                if dij <= 1e-12:\n                    # Random direction to avoid singularity\n                    ang = rng.uniform(0, 2 * np.pi)\n                    ux, uy = np.cos(ang), np.sin(ang)\n                else:\n                    u = diff[i, j] / dij\n                    ux, uy = float(u[0]), float(u[1])\n                # Constraint: (-u\u00b7dx_i) + (u\u00b7dx_j) + r_i + r_j <= dij\n                row = np.zeros(var_dim)\n                if i in idx_map:\n                    ki = idx_map[i]\n                    row[2 * ki + 0] += -ux\n                    row[2 * ki + 1] += -uy\n                if j in idx_map:\n                    kj = idx_map[j]\n                    row[2 * kj + 0] += ux\n                    row[2 * kj + 1] += uy\n                row[2 * m + i] += 1.0\n                row[2 * m + j] += 1.0\n                A_rows.append(row); b_vals.append(dij)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        bounds = []\n        # Displacement bounds (trust region and box)\n        for k, i in enumerate(subset_idx):\n            xi, yi = centers[i]\n            dx_lo = max(-trust, eps - xi)\n            dx_hi = min(trust, 1.0 - eps - xi)\n            dy_lo = max(-trust, eps - yi)\n            dy_hi = min(trust, 1.0 - eps - yi)\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n        # Radii bounds\n        for _ in range(n):\n            bounds.append((r_min, None))\n\n        # Objective: maximize sum r => minimize -sum r\n        c = np.zeros(var_dim, dtype=float)\n        c[2 * m:] = -1.0\n        return c, A_ub, b_ub, bounds\n\n    def slp_subset_step(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return centers, None, False\n        built = build_slp_subset_lp(centers, subset_idx, trust)\n        if built is None:\n            return centers, None, False\n        c, A_ub, b_ub, bounds = built\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not (getattr(res, \"success\", False) and res.x is not None):\n                return centers, None, False\n            m = len(subset_idx)\n            sol = np.array(res.x, dtype=float)\n            dxy = sol[:2 * m].reshape(m, 2)\n            r_lin = sol[2 * m:]\n            centers_new = centers.copy()\n            for idx_local, i in enumerate(subset_idx):\n                centers_new[i] = centers_new[i] + dxy[idx_local]\n            centers_new = clamp01(centers_new)\n            return centers_new, r_lin, True\n        except Exception:\n            return centers, None, False\n\n    def refine_by_slp_iterative(centers_init, max_outer=8, init_trust=0.08):\n        centers = centers_init.copy()\n        r, ok, _ = solve_radii_lp(centers, r_min)\n        if not ok:\n            return centers, r, False\n        best_score = float(np.sum(r))\n        best_centers = centers.copy()\n        trust = init_trust\n        for _ in range(max_outer):\n            if time_left() < 0.15:\n                break\n            subset_idx = list(range(n))\n            centers_cand, _, ok_step = slp_subset_step(centers, subset_idx, trust)\n            if not ok_step:\n                trust *= 0.7\n                if trust < 1e-3:\n                    break\n                continue\n            r_rep, ok2, _ = solve_radii_lp(centers_cand, r_min)\n            if ok2:\n                sc = float(np.sum(r_rep))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_rep\n                    best_score = sc\n                    best_centers = centers.copy()\n                    trust = min(trust * 1.3, 0.2)\n                else:\n                    trust *= 0.6\n                    if trust < 1e-3:\n                        break\n            else:\n                trust *= 0.6\n                if trust < 1e-3:\n                    break\n        return best_centers, r, True\n\n    def dual_inform_weights(centers, r, duals):\n        # Compute per-circle \"tightness\" weights for subset selection\n        w = np.zeros(n, dtype=float)\n        if duals is not None:\n            num_boundary = 4 * n\n            db = duals[:num_boundary].reshape(n, 4)\n            dp = duals[num_boundary:]\n            w += np.sum(db, axis=1)\n            # pairwise aggregation\n            idx = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    val = dp[idx]\n                    w[i] += val\n                    w[j] += val\n                    idx += 1\n        # Add inverse-radius bias\n        with np.errstate(divide='ignore'):\n            inv_r = 1.0 / np.maximum(r, 1e-6)\n        w += 0.2 * inv_r\n        # Normalize\n        s = np.sum(w)\n        if s <= 0:\n            w = np.ones(n) / n\n        else:\n            w = w / s\n        return w\n\n    # Initializations\n    def init_hex_grid():\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        xs = np.linspace(0.1, 0.9, cols)\n        ys = np.linspace(0.1, 0.9, rows)\n        pts = []\n        cnt = 0\n        for r_idx, yy in enumerate(ys):\n            off = 0.0 if (r_idx % 2 == 0) else (xs[1] - xs[0]) * 0.5 if len(xs) > 1 else 0.0\n            for xx in xs:\n                if cnt >= K:\n                    break\n                x = np.clip(xx + off, 0.06, 0.94)\n                x += rng.normal(0, 0.01)\n                y = yy + rng.normal(0, 0.01)\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        while pts.shape[0] < K:\n            pts = np.vstack([pts, rng.uniform(0.15, 0.85, size=(1, 2))])\n        return clamp01(pts[:n])\n\n    def init_edges():\n        pts = []\n        e = 1e-3\n        corners = [[e, e], [1 - e, e], [e, 1 - e], [1 - e, 1 - e]]\n        pts.extend(corners)\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, e]); pts.append([t, 1 - e])\n            pts.append([e, t]); pts.append([1 - e, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0: pts = np.vstack([pts, [t, e]])\n                elif edge == 1: pts = np.vstack([pts, [t, 1 - e]])\n                elif edge == 2: pts = np.vstack([pts, [e, t]])\n                else: pts = np.vstack([pts, [1 - e, t]])\n        return clamp01(pts[:n])\n\n    def init_center_biased():\n        pts = 0.75 * rng.uniform(0.05, 0.95, size=(n, 2)) + 0.25 * 0.5\n        pts += rng.normal(0, 0.03, size=(n, 2))\n        return clamp01(pts)\n\n    def init_uniform():\n        return clamp01(rng.uniform(0.1, 0.9, size=(n, 2)))\n\n    # Evaluate centers to circles\n    def evaluate_centers(centers):\n        centers = clamp01(centers)\n        r, ok, duals = solve_radii_lp(centers, r_min)\n        if not ok or r is None:\n            b = boundary_limits(centers)\n            r = np.maximum(np.minimum(b, 0.5), r_min)\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r)), duals\n\n    # Seed centers\n    seed_centers_list = []\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = clamp01(cb[:, :2].astype(float))\n                seed_centers_list.append(centers_cb)\n                # jittered variants\n                for _ in range(2):\n                    seed_centers_list.append(clamp01(centers_cb + rng.normal(0, 0.01, size=centers_cb.shape)))\n        except Exception:\n            pass\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n    seed_centers_list.append(init_uniform())\n    seed_centers_list.append(clamp01(init_hex_grid() + rng.normal(0, 0.02, size=(n, 2))))\n\n    # Deduplicate\n    unique_seeds = []\n    seen = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen:\n            c = clamp01(c + rng.normal(0, 0.005, size=c.shape))\n        unique_seeds.append(c)\n        seen.add(h)\n    seed_centers_list = unique_seeds\n\n    best_circles = None\n    best_score = -1e18\n    best_duals = None\n\n    # Initial evaluation of seeds\n    for centers in seed_centers_list:\n        circles, score, duals = evaluate_centers(centers)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # Global SLP refine on seeds\n    per_seed_time = max(0.5, time_left() / max(1, len(seed_centers_list)))\n    for centers0 in seed_centers_list:\n        if time_left() < 0.5:\n            break\n        t_seed_start = time.time()\n        def time_left_seed():\n            return min(time_left(), per_seed_time - (time.time() - t_seed_start))\n\n        if time_left_seed() < 0.2:\n            continue\n        centers_ref, r_ref, _ = refine_by_slp_iterative(centers0, max_outer=8, init_trust=0.08)\n        circles, score, duals = evaluate_centers(centers_ref)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # LNS loop\n    if best_circles is None:\n        centers = init_edges()\n        r, _, _ = solve_radii_lp(centers, r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    centers = best_circles[:, :2].copy()\n    r, ok, duals = solve_radii_lp(centers, r_min)\n    if ok:\n        best_duals = duals\n\n    stagnation = 0\n    attempts = 0\n    max_attempts = 1000000\n    while time_left() > 0.25 and attempts < max_attempts:\n        attempts += 1\n        # Determine subset size\n        base_m = 8\n        if stagnation > 8:\n            base_m = 12\n        elif stagnation > 3:\n            base_m = 10\n        m = int(np.clip(base_m + rng.integers(-2, 3), 5, 14))\n        # Select subset indices\n        weights = dual_inform_weights(centers, r if r is not None else np.ones(n), best_duals)\n        try:\n            subset_idx = rng.choice(n, size=m, replace=False, p=weights)\n        except Exception:\n            subset_idx = rng.choice(n, size=m, replace=False)\n        trust = 0.08 * (0.9 ** (stagnation // 3))\n        trust = float(np.clip(trust, 0.01, 0.2))\n        # Perform a few SLP updates for this subset\n        improved_local = False\n        for _ in range(3):\n            if time_left() < 0.15:\n                break\n            centers_cand, _, ok_step = slp_subset_step(centers, list(subset_idx), trust)\n            if not ok_step:\n                trust *= 0.7\n                continue\n            r_cand, ok_rep, duals_cand = solve_radii_lp(centers_cand, r_min)\n            if ok_rep:\n                sc = float(np.sum(r_cand))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_cand\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_cand\n                    all_scores.append(best_score)\n                    improved_local = True\n                    stagnation = 0\n                    trust = min(trust * 1.3, 0.25)\n                else:\n                    trust *= 0.8\n            else:\n                trust *= 0.7\n        if not improved_local:\n            stagnation += 1\n            # Occasional global SLP to escape\n            if stagnation % 6 == 0 and time_left() > 0.25:\n                centers_glob, r_glob, _ = refine_by_slp_iterative(centers, max_outer=5, init_trust=0.06)\n                circles_glob, sc_glob, duals_glob = evaluate_centers(centers_glob)\n                if sc_glob > best_score + 1e-10:\n                    best_score = sc_glob\n                    best_circles = circles_glob\n                    centers = circles_glob[:, :2].copy()\n                    r = circles_glob[:, 2].copy()\n                    best_duals = duals_glob\n                    all_scores.append(best_score)\n                    stagnation = 0\n            # Occasional random shake of a few smallest-r circles\n            if stagnation % 4 == 0:\n                if r is None or not np.all(np.isfinite(r)):\n                    r = boundary_limits(centers)\n                kshake = max(3, n // 6)\n                idx_sorted = np.argsort(r)\n                picks = idx_sorted[:kshake]\n                perturb = rng.normal(0, 0.02 * (1 + 0.05 * stagnation), size=(len(picks), 2))\n                centers_shake = centers.copy()\n                centers_shake[picks] = clamp01(centers_shake[picks] + perturb)\n                r_shake, ok_sh, duals_sh = solve_radii_lp(centers_shake, r_min)\n                if ok_sh:\n                    sc = float(np.sum(r_shake))\n                    if sc > best_score + 1e-10:\n                        centers = centers_shake\n                        r = r_shake\n                        best_score = sc\n                        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                        best_duals = duals_sh\n                        all_scores.append(best_score)\n                        stagnation = 0\n\n        if stagnation > 18:\n            # Re-diversify by mixing with a new seed\n            seed = init_uniform() if rng.random() < 0.5 else init_hex_grid()\n            centers_mix = 0.5 * centers + 0.5 * seed\n            centers_mix = clamp01(centers_mix)\n            r_mix, ok_mix, duals_mix = solve_radii_lp(centers_mix, r_min)\n            if ok_mix:\n                sc = float(np.sum(r_mix))\n                if sc > best_score + 1e-10:\n                    centers = centers_mix\n                    r = r_mix\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_mix\n                    all_scores.append(best_score)\n                    stagnation = 0\n                else:\n                    stagnation = max(stagnation - 5, 0)\n\n    # Final feasibility and polish\n    try:\n        centers_final = best_circles[:, :2]\n        r_final, ok_fin, _ = solve_radii_lp(centers_final, r_min)\n        if ok_fin and r_final is not None:\n            best_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n            best_score = float(np.sum(r_final))\n            if not all_scores or best_score > all_scores[-1] + 1e-9:\n                all_scores.append(best_score)\n    except Exception:\n        pass\n\n    return {\n        'circles': best_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [float(best_score)]\n    }",
    "refiner_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    BREAKTHROUGH approach: Large-Neighborhood Sequential Linear Programming (LN-SLP)\n    with exact LP for radii. We optimize centers by repeatedly solving LPs over\n    subsets of centers with linearized pairwise constraints and boundary constraints.\n    Multi-start + global SLP + LNS refinement + dual-informed subset selection.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    time_budget = max(1.0, float(timeout) - 0.5)\n    rng = np.random.default_rng(2026)\n    eps = 1e-6\n    r_min = 1e-8\n    all_scores = []\n\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def clamp01(xy):\n        return np.clip(xy, eps, 1.0 - eps)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Projection-like repair (feasible radii)\n        b = boundary_limits(centers)\n        r = np.minimum(b, 0.5).copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 1500\n        tol = 1e-10\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n):\n                ri = r[i]\n                for j in range(i + 1, n):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        r[j] = r_min_local\n                        continue\n                    s = ri + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = ri + r[j]\n                        if total <= 1e-16:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (ri / total)\n                            dec_j = excess * (r[j] / total)\n                        ri = max(r_min_local, ri - dec_i)\n                        r[j] = max(r_min_local, r[j] - dec_j)\n                r[i] = ri\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True, None\n\n    def solve_radii_lp(centers, r_min_local):\n        try:\n            from scipy.optimize import linprog\n            x = centers[:, 0]; y = centers[:, 1]\n            D = pairwise_distances(centers)\n            A_rows = []\n            b_vals = []\n            # Boundary constraints\n            for i in range(n):\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - x[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(y[i])\n                row = np.zeros(n); row[i] = 1.0; A_rows.append(row); b_vals.append(1.0 - y[i])\n            # Pairwise constraints\n            for i in range(n):\n                for j in range(i + 1, n):\n                    row = np.zeros(n); row[i] = 1.0; row[j] = 1.0\n                    A_rows.append(row); b_vals.append(D[i, j])\n            A_ub = np.array(A_rows, dtype=float) if A_rows else None\n            b_ub = np.array(b_vals, dtype=float) if b_vals else None\n            bounds = [(r_min_local, None)] * n\n            c = -np.ones(n, dtype=float)\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if getattr(res, \"success\", False) and res.x is not None:\n                r = np.array(res.x, dtype=float)\n                b = boundary_limits(centers)\n                r = np.minimum(r, b)\n                r = np.maximum(r, r_min_local)\n                # Try to extract duals for guidance\n                weights = None\n                try:\n                    ine = getattr(res, \"ineqlin\", None)\n                    if ine is not None and hasattr(ine, \"marginals\"):\n                        y_dual = np.array(ine.marginals, dtype=float)\n                        weights = -y_dual\n                        weights = np.maximum(weights, 0.0)\n                except Exception:\n                    weights = None\n                return r, True, weights\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def build_slp_subset_lp(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog  # noqa: F401\n        except Exception:\n            return None\n        m = len(subset_idx)\n        var_dim = 2 * m + n\n        idx_map = {subset_idx[k]: k for k in range(m)}\n        A_rows = []\n        b_vals = []\n\n        x = centers[:, 0]; y = centers[:, 1]\n        # Boundary constraints\n        for i in range(n):\n            # r_i - dx_i <= x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = -1.0\n            A_rows.append(row); b_vals.append(x[i])\n            # r_i + dx_i <= 1 - x_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 0] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - x[i])\n            # r_i - dy_i <= y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = -1.0\n            A_rows.append(row); b_vals.append(y[i])\n            # r_i + dy_i <= 1 - y_i\n            row = np.zeros(var_dim)\n            row[2 * m + i] = 1.0\n            if i in idx_map:\n                k = idx_map[i]\n                row[2 * k + 1] = 1.0\n            A_rows.append(row); b_vals.append(1.0 - y[i])\n\n        # Pairwise linearization at current centers\n        diff = centers[:, None, :] - centers[None, :, :]\n        Dij = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        for i in range(n):\n            for j in range(i + 1, n):\n                dij = Dij[i, j]\n                if dij <= 1e-12:\n                    ang = rng.uniform(0, 2 * np.pi)\n                    ux, uy = np.cos(ang), np.sin(ang)\n                else:\n                    u = diff[i, j] / dij\n                    ux, uy = float(u[0]), float(u[1])\n                row = np.zeros(var_dim)\n                if i in idx_map:\n                    ki = idx_map[i]\n                    row[2 * ki + 0] += -ux\n                    row[2 * ki + 1] += -uy\n                if j in idx_map:\n                    kj = idx_map[j]\n                    row[2 * kj + 0] += ux\n                    row[2 * kj + 1] += uy\n                row[2 * m + i] += 1.0\n                row[2 * m + j] += 1.0\n                A_rows.append(row); b_vals.append(dij)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        bounds = []\n        # Displacement bounds (trust region and box)\n        for k, i in enumerate(subset_idx):\n            xi, yi = centers[i]\n            dx_lo = max(-trust, eps - xi)\n            dx_hi = min(trust, 1.0 - eps - xi)\n            dy_lo = max(-trust, eps - yi)\n            dy_hi = min(trust, 1.0 - eps - yi)\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n        # Radii bounds\n        for _ in range(n):\n            bounds.append((r_min, None))\n\n        c = np.zeros(var_dim, dtype=float)\n        c[2 * m:] = -1.0\n        return c, A_ub, b_ub, bounds\n\n    def slp_subset_step(centers, subset_idx, trust):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return centers, None, False\n        built = build_slp_subset_lp(centers, subset_idx, trust)\n        if built is None:\n            return centers, None, False\n        c, A_ub, b_ub, bounds = built\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not (getattr(res, \"success\", False) and res.x is not None):\n                return centers, None, False\n            m = len(subset_idx)\n            sol = np.array(res.x, dtype=float)\n            dxy = sol[:2 * m].reshape(m, 2)\n            r_lin = sol[2 * m:]\n            centers_new = centers.copy()\n            for idx_local, i in enumerate(subset_idx):\n                centers_new[i] = centers_new[i] + dxy[idx_local]\n            centers_new = clamp01(centers_new)\n            return centers_new, r_lin, True\n        except Exception:\n            return centers, None, False\n\n    def refine_by_slp_iterative(centers_init, max_outer=8, init_trust=0.08):\n        centers = centers_init.copy()\n        r, ok, _ = solve_radii_lp(centers, r_min)\n        if not ok:\n            return centers, r, False\n        best_score = float(np.sum(r))\n        best_centers = centers.copy()\n        trust = init_trust\n        for _ in range(max_outer):\n            if time_left() < 0.15:\n                break\n            subset_idx = list(range(n))\n            centers_cand, _, ok_step = slp_subset_step(centers, subset_idx, trust)\n            if not ok_step:\n                trust *= 0.7\n                if trust < 1e-3:\n                    break\n                continue\n            r_rep, ok2, _ = solve_radii_lp(centers_cand, r_min)\n            if ok2:\n                sc = float(np.sum(r_rep))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_rep\n                    best_score = sc\n                    best_centers = centers.copy()\n                    trust = min(trust * 1.3, 0.2)\n                else:\n                    trust *= 0.6\n                    if trust < 1e-3:\n                        break\n            else:\n                trust *= 0.6\n                if trust < 1e-3:\n                    break\n        return best_centers, r, True\n\n    def dual_inform_weights(centers, r, duals):\n        w = np.zeros(n, dtype=float)\n        if duals is not None:\n            num_boundary = 4 * n\n            if duals.shape[0] >= num_boundary:\n                db = duals[:num_boundary].reshape(n, 4)\n                w += np.sum(db, axis=1)\n                dp = duals[num_boundary:]\n                idx = 0\n                for i in range(n):\n                    for j in range(i + 1, n):\n                        if idx >= dp.shape[0]:\n                            break\n                        val = dp[idx]\n                        w[i] += val\n                        w[j] += val\n                        idx += 1\n        with np.errstate(divide='ignore'):\n            inv_r = 1.0 / np.maximum(r, 1e-6)\n        w += 0.2 * inv_r\n        s = np.sum(w)\n        if s <= 0:\n            w = np.ones(n) / n\n        else:\n            w = w / s\n        return w\n\n    def init_hex_grid():\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        xs = np.linspace(0.1, 0.9, cols)\n        ys = np.linspace(0.1, 0.9, rows)\n        pts = []\n        cnt = 0\n        for r_idx, yy in enumerate(ys):\n            off = 0.0 if (r_idx % 2 == 0) else (xs[1] - xs[0]) * 0.5 if len(xs) > 1 else 0.0\n            for xx in xs:\n                if cnt >= K:\n                    break\n                x = np.clip(xx + off, 0.06, 0.94)\n                x += rng.normal(0, 0.01)\n                y = yy + rng.normal(0, 0.01)\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        while pts.shape[0] < K:\n            pts = np.vstack([pts, rng.uniform(0.15, 0.85, size=(1, 2))])\n        return clamp01(pts[:n])\n\n    def init_edges():\n        pts = []\n        e = 1e-3\n        corners = [[e, e], [1 - e, e], [e, 1 - e], [1 - e, 1 - e]]\n        pts.extend(corners)\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, e]); pts.append([t, 1 - e])\n            pts.append([e, t]); pts.append([1 - e, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0: pts = np.vstack([pts, [t, e]])\n                elif edge == 1: pts = np.vstack([pts, [t, 1 - e]])\n                elif edge == 2: pts = np.vstack([pts, [e, t]])\n                else: pts = np.vstack([pts, [1 - e, t]])\n        return clamp01(pts[:n])\n\n    def init_center_biased():\n        pts = 0.75 * rng.uniform(0.05, 0.95, size=(n, 2)) + 0.25 * 0.5\n        pts += rng.normal(0, 0.03, size=(n, 2))\n        return clamp01(pts)\n\n    def init_uniform():\n        return clamp01(rng.uniform(0.1, 0.9, size=(n, 2)))\n\n    def evaluate_centers(centers):\n        centers = clamp01(centers)\n        r, ok, duals = solve_radii_lp(centers, r_min)\n        if not ok or r is None:\n            b = boundary_limits(centers)\n            r = np.maximum(np.minimum(b, 0.5), r_min)\n            duals = None\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r)), duals\n\n    # Seed centers\n    seed_centers_list = []\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = clamp01(cb[:, :2].astype(float))\n                seed_centers_list.append(centers_cb)\n                for _ in range(2):\n                    seed_centers_list.append(clamp01(centers_cb + rng.normal(0, 0.01, size=centers_cb.shape)))\n        except Exception:\n            pass\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n    seed_centers_list.append(init_uniform())\n    seed_centers_list.append(clamp01(init_hex_grid() + rng.normal(0, 0.02, size=(n, 2))))\n\n    # Deduplicate seeds with slight jitter on collisions\n    unique_seeds = []\n    seen = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen:\n            c = clamp01(c + rng.normal(0, 0.005, size=c.shape))\n        unique_seeds.append(c)\n        seen.add(h)\n    seed_centers_list = unique_seeds\n\n    best_circles = None\n    best_score = -1e18\n    best_duals = None\n\n    # Initial evaluation of seeds\n    for centers in seed_centers_list:\n        circles, score, duals = evaluate_centers(centers)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # Global SLP refine on seeds\n    per_seed_time = max(0.4, time_left() / max(1, len(seed_centers_list)))\n    for centers0 in seed_centers_list:\n        if time_left() < 0.4:\n            break\n        t_seed_start = time.time()\n\n        def time_left_seed():\n            return min(time_left(), per_seed_time - (time.time() - t_seed_start))\n\n        if time_left_seed() < 0.2:\n            continue\n        centers_ref, r_ref, _ = refine_by_slp_iterative(centers0, max_outer=8, init_trust=0.08)\n        circles, score, duals = evaluate_centers(centers_ref)\n        if score > best_score + 1e-12:\n            best_score = score\n            best_circles = circles\n            best_duals = duals\n            all_scores.append(best_score)\n\n    # LNS loop\n    if best_circles is None:\n        centers = init_edges()\n        r, _, _ = solve_radii_lp(centers, r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    centers = best_circles[:, :2].copy()\n    r, ok, duals = solve_radii_lp(centers, r_min)\n    if ok:\n        best_duals = duals\n\n    stagnation = 0\n    attempts = 0\n    max_attempts = 1000000\n    while time_left() > 0.25 and attempts < max_attempts:\n        attempts += 1\n        # Determine subset size\n        base_m = 8\n        if stagnation > 8:\n            base_m = 12\n        elif stagnation > 3:\n            base_m = 10\n        m = int(np.clip(base_m + rng.integers(-2, 3), 5, 14))\n        # Select subset indices\n        weights = dual_inform_weights(centers, r if r is not None else np.ones(n), best_duals)\n        try:\n            subset_idx = rng.choice(n, size=m, replace=False, p=weights)\n        except Exception:\n            subset_idx = rng.choice(n, size=m, replace=False)\n        trust = 0.08 * (0.9 ** (stagnation // 3))\n        trust = float(np.clip(trust, 0.01, 0.2))\n\n        improved_local = False\n        for _ in range(3):\n            if time_left() < 0.15:\n                break\n            centers_cand, _, ok_step = slp_subset_step(centers, list(subset_idx), trust)\n            if not ok_step:\n                trust *= 0.7\n                continue\n            r_cand, ok_rep, duals_cand = solve_radii_lp(centers_cand, r_min)\n            if ok_rep:\n                sc = float(np.sum(r_cand))\n                if sc > best_score + 1e-10:\n                    centers = centers_cand\n                    r = r_cand\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_cand\n                    all_scores.append(best_score)\n                    improved_local = True\n                    stagnation = 0\n                    trust = min(trust * 1.3, 0.25)\n                else:\n                    trust *= 0.8\n            else:\n                trust *= 0.7\n        if not improved_local:\n            stagnation += 1\n            # Occasional global SLP to escape\n            if stagnation % 6 == 0 and time_left() > 0.25:\n                centers_glob, r_glob, _ = refine_by_slp_iterative(centers, max_outer=5, init_trust=0.06)\n                circles_glob, sc_glob, duals_glob = evaluate_centers(centers_glob)\n                if sc_glob > best_score + 1e-10:\n                    best_score = sc_glob\n                    best_circles = circles_glob\n                    centers = circles_glob[:, :2].copy()\n                    r = circles_glob[:, 2].copy()\n                    best_duals = duals_glob\n                    all_scores.append(best_score)\n                    stagnation = 0\n            # Occasional random shake of a few smallest-r circles\n            if stagnation % 4 == 0:\n                if r is None or not np.all(np.isfinite(r)):\n                    r = boundary_limits(centers)\n                kshake = max(3, n // 6)\n                idx_sorted = np.argsort(r)\n                picks = idx_sorted[:kshake]\n                perturb = rng.normal(0, 0.02 * (1 + 0.05 * stagnation), size=(len(picks), 2))\n                centers_shake = centers.copy()\n                centers_shake[picks] = clamp01(centers_shake[picks] + perturb)\n                r_shake, ok_sh, duals_sh = solve_radii_lp(centers_shake, r_min)\n                if ok_sh:\n                    sc = float(np.sum(r_shake))\n                    if sc > best_score + 1e-10:\n                        centers = centers_shake\n                        r = r_shake\n                        best_score = sc\n                        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                        best_duals = duals_sh\n                        all_scores.append(best_score)\n                        stagnation = 0\n\n        if stagnation > 18:\n            # Re-diversify by mixing with a new seed\n            seed = init_uniform() if rng.random() < 0.5 else init_hex_grid()\n            centers_mix = 0.5 * centers + 0.5 * seed\n            centers_mix = clamp01(centers_mix)\n            r_mix, ok_mix, duals_mix = solve_radii_lp(centers_mix, r_min)\n            if ok_mix:\n                sc = float(np.sum(r_mix))\n                if sc > best_score + 1e-10:\n                    centers = centers_mix\n                    r = r_mix\n                    best_score = sc\n                    best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                    best_duals = duals_mix\n                    all_scores.append(best_score)\n                    stagnation = 0\n                else:\n                    stagnation = max(stagnation - 5, 0)\n\n    # Final feasibility and polish\n    try:\n        centers_final = best_circles[:, :2]\n        r_final, ok_fin, _ = solve_radii_lp(centers_final, r_min)\n        if ok_fin and r_final is not None:\n            best_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n            best_score = float(np.sum(r_final))\n            if not all_scores or best_score > all_scores[-1] + 1e-9:\n                all_scores.append(best_score)\n    except Exception:\n        pass\n\n    return {\n        'circles': best_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [float(best_score)]\n    }",
    "refiner_score": 2.635983362593453
}