{
    "best_score": 1.9258784076439925,
    "best_code": "import numpy as np\nimport time\n\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radii that don't overlap and stay in unit square.\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Limit by distance to other circles (simple equal-shrink heuristic)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist <= 0:\n                # Coincident centers: enforce tiny separation via radius shrink\n                radii[i] *= 0.5\n                radii[j] *= 0.5\n            else:\n                if radii[i] + radii[j] > dist:\n                    scale = dist / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n\n    # Ensure strictly positive\n    radii = np.maximum(radii, 1e-4)\n    return radii\n\n\ndef project_inside_square(centers, radii):\n    \"\"\"\n    Project centers so that all circles remain inside [0,1]x[0,1] given radii.\n    \"\"\"\n    x = centers[:, 0]\n    y = centers[:, 1]\n    x = np.clip(x, radii, 1.0 - radii)\n    y = np.clip(y, radii, 1.0 - radii)\n    return np.stack([x, y], axis=1)\n\n\ndef local_optimize(centers, radii, time_budget):\n    \"\"\"\n    Simple force-based local optimization on centers with fixed radii.\n    Tries to reduce overlaps and push circles toward free space.\n    \"\"\"\n    start_time = time.time()\n    n = centers.shape[0]\n    centers = centers.copy()\n    radii = radii.copy()\n\n    # Basic parameters, chosen to be very cheap\n    max_iters = 500\n    base_step = 0.02\n    min_step = 1e-4\n    damping = 0.9\n\n    step = base_step\n    velocities = np.zeros_like(centers)\n\n    for it in range(max_iters):\n        if time.time() - start_time > time_budget:\n            break\n\n        forces = np.zeros_like(centers)\n\n        # Pairwise repulsion for overlapping or near-overlapping circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                delta = centers[j] - centers[i]\n                dist = np.linalg.norm(delta)\n                min_dist = radii[i] + radii[j]\n                if dist < 1e-8:\n                    # Same point: random small push\n                    direction = np.random.randn(2)\n                    direction /= np.linalg.norm(direction) + 1e-8\n                    f = 0.5 * min_dist * direction\n                    forces[i] -= f\n                    forces[j] += f\n                elif dist < 1.2 * min_dist:\n                    # Soft repulsive force when too close\n                    direction = delta / dist\n                    penetration = max(min_dist - dist, 0.0)\n                    strength = penetration / min_dist\n                    f = direction * strength\n                    forces[i] -= f\n                    forces[j] += f\n\n        # Weak attraction to center to avoid sticking to borders too much\n        center_point = np.array([0.5, 0.5])\n        forces += 0.01 * (center_point - centers)\n\n        # Update velocities and positions\n        velocities = damping * velocities + step * forces\n        centers += velocities\n\n        # Keep inside square with current radii\n        centers = project_inside_square(centers, radii)\n\n        # Slightly reduce step over time\n        step = max(step * 0.98, min_step)\n\n    return centers, radii\n\n\ndef random_perturbation(centers, scale=0.02):\n    \"\"\"Apply a small random perturbation to centers.\"\"\"\n    noise = np.random.randn(*centers.shape) * scale\n    new_centers = centers + noise\n    # Rough clipping to keep in [0,1]; radii-dependent clipping is applied later\n    new_centers = np.clip(new_centers, 0.0, 1.0)\n    return new_centers\n\n\ndef build_initial_centers(n):\n    \"\"\"\n    Construct a deterministic-ish initial layout: center, inner ring, outer frame.\n    \"\"\"\n    centers = np.zeros((n, 2))\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring of up to 8 around center\n    ring_count = min(8, n - 1)\n    inner_radius = 0.28\n    for i in range(ring_count):\n        angle = 2 * np.pi * i / ring_count\n        centers[i + 1] = [\n            0.5 + inner_radius * np.cos(angle),\n            0.5 + inner_radius * np.sin(angle),\n        ]\n\n    # For remaining, distribute roughly along a square frame, not too close to corners\n    idx = 1 + ring_count\n    remaining = n - idx\n    if remaining > 0:\n        # Use a simple pattern: four sides, place points uniformly avoiding corners\n        per_side = max(1, remaining // 4)\n        margin = 0.1\n        t_vals = np.linspace(margin, 1 - margin, per_side, endpoint=True)\n        coords = []\n        # Top (y close to 1 - margin)\n        for t in t_vals:\n            coords.append([t, 1 - margin])\n        # Bottom\n        for t in t_vals:\n            coords.append([t, margin])\n        # Left\n        for t in t_vals:\n            coords.append([margin, t])\n        # Right\n        for t in t_vals:\n            coords.append([1 - margin, t])\n        coords = np.array(coords)\n        # Fill remaining slots with first \"remaining\" points\n        centers[idx:] = coords[:remaining]\n\n    # Clip just in case\n    centers = np.clip(centers, 0.01, 0.99)\n    return centers\n\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization with simple local refinement.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    all_scores = []\n\n    # If we have a current best solution, start from it but also try to improve\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        best_circles = current_best_solution.copy()\n        best_score = float(np.sum(best_circles[:, 2]))\n    else:\n        # Deterministic initial placement\n        centers = build_initial_centers(n)\n        radii = compute_max_radii(centers)\n        best_circles = np.hstack([centers, radii.reshape(-1, 1)])\n        best_score = float(np.sum(best_circles[:, 2]))\n\n    all_scores.append(best_score)\n\n    # Use a fraction of the timeout for local search; keep a safety margin\n    remaining_time = max(timeout - 0.01, 0.0)\n    if remaining_time <= 0:\n        return {\"circles\": best_circles, \"all_scores\": all_scores}\n\n    # We perform multiple lightweight restarts with small random perturbations\n    # around the best solution to possibly escape local minima.\n    num_restarts = 8\n    per_restart_time = remaining_time / max(num_restarts, 1)\n\n    for _ in range(num_restarts):\n        if time.time() - start_time > timeout:\n            break\n\n        # Warm start from best configuration so far, with small random jitter\n        centers = random_perturbation(best_circles[:, :2], scale=0.01)\n        # Recompute radii for the perturbed centers\n        radii = compute_max_radii(centers)\n        centers = project_inside_square(centers, radii)\n\n        # Local optimization with fixed radii\n        centers_opt, radii_opt = local_optimize(centers, radii, per_restart_time * 0.7)\n\n        # After moving centers, try to slightly increase radii again\n        radii_opt = compute_max_radii(centers_opt)\n        centers_opt = project_inside_square(centers_opt, radii_opt)\n\n        circles_candidate = np.hstack([centers_opt, radii_opt.reshape(-1, 1)])\n\n        score = float(np.sum(circles_candidate[:, 2]))\n        all_scores.append(score)\n\n        if score > best_score:\n            best_score = score\n            best_circles = circles_candidate\n\n    return {\"circles\": best_circles, \"all_scores\": all_scores}",
    "best_circles": [
        [
            0.4881782591758563,
            0.5114896543609908,
            0.013883682836200005
        ],
        [
            0.7579095242135617,
            0.507925676098499,
            0.03448398875672969
        ],
        [
            0.6652129288703184,
            0.6424949403283094,
            0.06859843939165974
        ],
        [
            0.5043583581670693,
            0.748316554972442,
            0.06409472667358222
        ],
        [
            0.33041938692884426,
            0.6790335940921569,
            0.07022253291914454
        ],
        [
            0.2719503410594471,
            0.5003374764806121,
            0.05700169952680092
        ],
        [
            0.29519720200559374,
            0.32470236569664757,
            0.06304393169971585
        ],
        [
            0.4682255456200225,
            0.268904064530178,
            0.08962561977298823
        ],
        [
            0.6945955225426242,
            0.3490603720660026,
            0.11349611315872919
        ],
        [
            0.9228756467553897,
            0.5038857260804591,
            0.07712435324461031
        ],
        [
            0.9198087108537621,
            0.685704178077005,
            0.08019128914623785
        ],
        [
            0.9126676847122653,
            0.874419682973887,
            0.07775572058083102
        ],
        [
            0.7389197774020894,
            0.8912696376310536,
            0.0968073232360493
        ],
        [
            0.5415601932487982,
            0.8980140212308607,
            0.09015606890828365
        ],
        [
            0.33240150951743275,
            0.905888345777437,
            0.0766003108623206
        ],
        [
            0.18045567972744223,
            0.9074205010507472,
            0.05417030977575739
        ],
        [
            0.10713360166165357,
            0.7986367145846186,
            0.07701672971288216
        ],
        [
            0.09171700333497991,
            0.6016564199054699,
            0.09171700333497991
        ],
        [
            0.1086169335771595,
            0.3933310791398224,
            0.09723764356346483
        ],
        [
            0.10962200333678007,
            0.197958603940721,
            0.05396905306655032
        ],
        [
            0.14805106038865865,
            0.09748007434555023,
            0.05360755840408556
        ],
        [
            0.31491069337439964,
            0.10722064541418626,
            0.10722064541418626
        ],
        [
            0.5419544020484729,
            0.10841969003281547,
            0.08698462547925287
        ],
        [
            0.7518299611214196,
            0.11865087830197717,
            0.07540299920541926
        ],
        [
            0.8959727776949301,
            0.12289781218518876,
            0.06421158002100438
        ],
        [
            0.8936850894135137,
            0.2783470185403404,
            0.09125445895252657
        ]
    ],
    "code_candidate": "\nimport numpy as np\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    n = 26\n\n    # Use current_best_solution if provided, otherwise start fresh\n    if current_best_solution is not None:\n        circles = current_best_solution.copy()\n    else:\n        # Simple initial placement\n        centers = np.zeros((n, 2))\n\n        # Center circle\n        centers[0] = [0.5, 0.5]\n\n        # Ring of 8 around center\n        for i in range(min(8, n - 1)):\n            angle = 2 * np.pi * i / 8\n            centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n        # Outer ring for remaining\n        if n > 9:\n            remaining = n - 9\n            for i in range(remaining):\n                angle = 2 * np.pi * i / remaining\n                centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n        centers = np.clip(centers, 0.01, 0.99)\n        radii = compute_max_radii(centers)\n        circles = np.hstack([centers, radii.reshape(-1, 1)])\n\n    score = float(np.sum(circles[:, 2]))\n    return {'circles': circles, 'all_scores': [score]}\n\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radii that don't overlap and stay in unit square.\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n",
    "code_score": 0.9797642169962063,
    "refiner_prompt": "You are an expert mathematician and computational geometry specialist.\n\nYOUR TASK: Given the current code and its execution results (provided in `code_results`), generate improved code that fixes errors and increases the score.\n\nDOMAIN KNOWLEDGE FOR CIRCLE PACKING:\n1. **Optimization strategies**: Multiple restarts, better initialization, adaptive step sizes, hybrid local+global search\n2. **Geometric improvements**: Better initial layouts, exploit symmetry, special corner/edge placement strategies\n3. **Circle size tuning**: Variable vs uniform radii, size gradients (larger center vs edges or vice versa)\n4. **Algorithm switching**: If physics-based fails, try optimization-based. If greedy fails, try force simulation\n5. **Constraint handling**: Penalty methods, projection methods, constrained optimization (scipy.optimize.minimize with bounds)\n6. **Hyperparameter tuning**: Use optuna/hyperopt for algorithmic parameters (force constants, step sizes, iterations)\n\nCRITICAL CONSTRAINTS (must be preserved):\n- Function MUST be `def main(timeout, current_best_solution):`\n- All circles fully inside [0,1]\u00d7[0,1]: 0 \u2264 x-r, x+r \u2264 1 and 0 \u2264 y-r, y+r \u2264 1\n- No overlaps: distance between centers \u2265 sum of radii\n- All radii positive, return exactly N circles with shape (N, 3)\n- Return a dict with 'circles' and 'all_scores' keys.\n\nREFINER SHOULD:\n- Build on what worked in the initial code (don't throw away good ideas)\n- Carefully analyze `code_results` (stdout, stderr, errors) to identify why the previous attempt failed or scored poorly.\n- Use `current_best_solution` (passed as argument) to warm-start if it helps.\n- Make targeted improvements rather than complete rewrites (unless necessary)\n- Return the whole refined code in executable format.\n",
    "refiner_code": "import numpy as np\nimport time\n\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radii that don't overlap and stay in unit square.\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Limit by distance to other circles (simple equal-shrink heuristic)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist <= 0:\n                # Coincident centers: enforce tiny separation via radius shrink\n                radii[i] *= 0.5\n                radii[j] *= 0.5\n            else:\n                if radii[i] + radii[j] > dist:\n                    scale = dist / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n\n    # Ensure strictly positive\n    radii = np.maximum(radii, 1e-4)\n    return radii\n\n\ndef project_inside_square(centers, radii):\n    \"\"\"\n    Project centers so that all circles remain inside [0,1]x[0,1] given radii.\n    \"\"\"\n    x = centers[:, 0]\n    y = centers[:, 1]\n    x = np.clip(x, radii, 1.0 - radii)\n    y = np.clip(y, radii, 1.0 - radii)\n    return np.stack([x, y], axis=1)\n\n\ndef local_optimize(centers, radii, time_budget):\n    \"\"\"\n    Simple force-based local optimization on centers with fixed radii.\n    Tries to reduce overlaps and push circles toward free space.\n    \"\"\"\n    start_time = time.time()\n    n = centers.shape[0]\n    centers = centers.copy()\n    radii = radii.copy()\n\n    # Basic parameters, chosen to be very cheap\n    max_iters = 500\n    base_step = 0.02\n    min_step = 1e-4\n    damping = 0.9\n\n    step = base_step\n    velocities = np.zeros_like(centers)\n\n    for it in range(max_iters):\n        if time.time() - start_time > time_budget:\n            break\n\n        forces = np.zeros_like(centers)\n\n        # Pairwise repulsion for overlapping or near-overlapping circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                delta = centers[j] - centers[i]\n                dist = np.linalg.norm(delta)\n                min_dist = radii[i] + radii[j]\n                if dist < 1e-8:\n                    # Same point: random small push\n                    direction = np.random.randn(2)\n                    direction /= np.linalg.norm(direction) + 1e-8\n                    f = 0.5 * min_dist * direction\n                    forces[i] -= f\n                    forces[j] += f\n                elif dist < 1.2 * min_dist:\n                    # Soft repulsive force when too close\n                    direction = delta / dist\n                    penetration = max(min_dist - dist, 0.0)\n                    strength = penetration / min_dist\n                    f = direction * strength\n                    forces[i] -= f\n                    forces[j] += f\n\n        # Weak attraction to center to avoid sticking to borders too much\n        center_point = np.array([0.5, 0.5])\n        forces += 0.01 * (center_point - centers)\n\n        # Update velocities and positions\n        velocities = damping * velocities + step * forces\n        centers += velocities\n\n        # Keep inside square with current radii\n        centers = project_inside_square(centers, radii)\n\n        # Slightly reduce step over time\n        step = max(step * 0.98, min_step)\n\n    return centers, radii\n\n\ndef random_perturbation(centers, scale=0.02):\n    \"\"\"Apply a small random perturbation to centers.\"\"\"\n    noise = np.random.randn(*centers.shape) * scale\n    new_centers = centers + noise\n    # Rough clipping to keep in [0,1]; radii-dependent clipping is applied later\n    new_centers = np.clip(new_centers, 0.0, 1.0)\n    return new_centers\n\n\ndef build_initial_centers(n):\n    \"\"\"\n    Construct a deterministic-ish initial layout: center, inner ring, outer frame.\n    \"\"\"\n    centers = np.zeros((n, 2))\n\n    # Center circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring of up to 8 around center\n    ring_count = min(8, n - 1)\n    inner_radius = 0.28\n    for i in range(ring_count):\n        angle = 2 * np.pi * i / ring_count\n        centers[i + 1] = [\n            0.5 + inner_radius * np.cos(angle),\n            0.5 + inner_radius * np.sin(angle),\n        ]\n\n    # For remaining, distribute roughly along a square frame, not too close to corners\n    idx = 1 + ring_count\n    remaining = n - idx\n    if remaining > 0:\n        # Use a simple pattern: four sides, place points uniformly avoiding corners\n        per_side = max(1, remaining // 4)\n        margin = 0.1\n        t_vals = np.linspace(margin, 1 - margin, per_side, endpoint=True)\n        coords = []\n        # Top (y close to 1 - margin)\n        for t in t_vals:\n            coords.append([t, 1 - margin])\n        # Bottom\n        for t in t_vals:\n            coords.append([t, margin])\n        # Left\n        for t in t_vals:\n            coords.append([margin, t])\n        # Right\n        for t in t_vals:\n            coords.append([1 - margin, t])\n        coords = np.array(coords)\n        # Fill remaining slots with first \"remaining\" points\n        centers[idx:] = coords[:remaining]\n\n    # Clip just in case\n    centers = np.clip(centers, 0.01, 0.99)\n    return centers\n\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization with simple local refinement.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    all_scores = []\n\n    # If we have a current best solution, start from it but also try to improve\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        best_circles = current_best_solution.copy()\n        best_score = float(np.sum(best_circles[:, 2]))\n    else:\n        # Deterministic initial placement\n        centers = build_initial_centers(n)\n        radii = compute_max_radii(centers)\n        best_circles = np.hstack([centers, radii.reshape(-1, 1)])\n        best_score = float(np.sum(best_circles[:, 2]))\n\n    all_scores.append(best_score)\n\n    # Use a fraction of the timeout for local search; keep a safety margin\n    remaining_time = max(timeout - 0.01, 0.0)\n    if remaining_time <= 0:\n        return {\"circles\": best_circles, \"all_scores\": all_scores}\n\n    # We perform multiple lightweight restarts with small random perturbations\n    # around the best solution to possibly escape local minima.\n    num_restarts = 8\n    per_restart_time = remaining_time / max(num_restarts, 1)\n\n    for _ in range(num_restarts):\n        if time.time() - start_time > timeout:\n            break\n\n        # Warm start from best configuration so far, with small random jitter\n        centers = random_perturbation(best_circles[:, :2], scale=0.01)\n        # Recompute radii for the perturbed centers\n        radii = compute_max_radii(centers)\n        centers = project_inside_square(centers, radii)\n\n        # Local optimization with fixed radii\n        centers_opt, radii_opt = local_optimize(centers, radii, per_restart_time * 0.7)\n\n        # After moving centers, try to slightly increase radii again\n        radii_opt = compute_max_radii(centers_opt)\n        centers_opt = project_inside_square(centers_opt, radii_opt)\n\n        circles_candidate = np.hstack([centers_opt, radii_opt.reshape(-1, 1)])\n\n        score = float(np.sum(circles_candidate[:, 2]))\n        all_scores.append(score)\n\n        if score > best_score:\n            best_score = score\n            best_circles = circles_candidate\n\n    return {\"circles\": best_circles, \"all_scores\": all_scores}",
    "refiner_score": 1.9258784076439925
}