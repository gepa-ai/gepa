{
    "best_score": 2.6299143763990855,
    "best_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Breakthrough circle packing via Sequential Linear Programming (SLP) on centers and radii.\n    Maximize sum of radii for N=26 circles inside unit square with non-overlap constraints.\n\n    Strategy:\n    - Multi-start initialization (grids, edge-biased, warm-start from current_best_solution).\n    - Iteratively solve LP on increments (dx, dy, dr) with linearized non-overlap constraints and boundary constraints.\n    - Adaptive trust region for stable improvements.\n    - Final feasibility repair via LP on radii given centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    # Slight safety margin for overhead\n    time_budget = max(1.0, float(timeout) - 0.3)\n    rng = np.random.default_rng(12345)\n\n    r_min = 1e-6\n    all_scores = []\n\n    # Helpers\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    # --- Radii LP (with numeric-fallback) ------------------------------------\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Carefully balanced feasibility projection heuristic\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        # Start reasonably large but within box\n        r = b.copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 4000\n        tol = 1e-10\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n_local):\n                for j in range(i + 1, n_local):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        # Collapse one of them minimally\n                        r[j] = r_min_local\n                        continue\n                    s = r[i] + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = r[i] + r[j]\n                        if total <= 0:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (r[i] / total)\n                            dec_j = excess * (r[j] / total)\n                        new_ri = max(r_min_local, r[i] - dec_i)\n                        new_rj = max(r_min_local, r[j] - dec_j)\n                        remaining = excess - ((r[i] - new_ri) + (r[j] - new_rj))\n                        if remaining > 1e-15:\n                            if new_ri > new_rj and new_ri - remaining >= r_min_local:\n                                new_ri -= remaining\n                            elif new_rj - remaining >= r_min_local:\n                                new_rj -= remaining\n                        r[i] = new_ri\n                        r[j] = new_rj\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True\n\n    def solve_radii_lp(centers, r_min_local):\n        # Maximize sum r subject to box and pairwise non-overlap\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        D = pairwise_distances(centers)\n\n        A_rows = []\n        b_vals = []\n\n        # r_i <= b_i\n        for i in range(n_local):\n            row = np.zeros(n_local, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row)\n            b_vals.append(b[i])\n\n        # r_i + r_j <= d_ij\n        for i in range(n_local):\n            for j in range(i + 1, n_local):\n                row = np.zeros(n_local, dtype=float)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_rows.append(row)\n                b_vals.append(D[i, j])\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n        bounds = [(r_min_local, None)] * n_local\n        c = -np.ones(n_local, dtype=float)\n\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n            if res.success and res.x is not None:\n                r = np.asarray(res.x, dtype=float)\n                r = np.maximum(r, r_min_local)\n                r = np.minimum(r, b)\n                return r, True\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def feasible_from_centers(centers):\n        r, _ = solve_radii_lp(centers, r_min)\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r))\n\n    # --- Initializations -----------------------------------------------------\n    def init_hex_grid():\n        # Jittered hex-like grid inside [0,1]^2\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        sx = 1.0 / (cols + 1)\n        sy = 1.0 / (rows + 1)\n        pts = []\n        cnt = 0\n        for r_idx in range(rows):\n            x_off = 0.0 if (r_idx % 2 == 0) else 0.5 * sx\n            for c_idx in range(cols):\n                if cnt >= K:\n                    break\n                x = (c_idx + 1) * sx + x_off\n                y = (r_idx + 1) * sy\n                jx = rng.normal(0, 0.07 * sx)\n                jy = rng.normal(0, 0.07 * sy)\n                x = float(np.clip(x + jx, 0.02, 0.98))\n                y = float(np.clip(y + jy, 0.02, 0.98))\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        if pts.shape[0] < n:\n            for _ in range(n - pts.shape[0]):\n                x = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                y = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                pts = np.vstack([pts, [x, y]])\n        return pts[:n]\n\n    def init_edges():\n        # Emphasize corners and edges\n        pts = []\n        eps = 1e-3\n        corners = [\n            [eps, eps], [1 - eps, eps], [eps, 1 - eps], [1 - eps, 1 - eps]\n        ]\n        pts.extend(corners)\n        # Edge midpoints\n        pts.extend([[0.5, eps], [0.5, 1 - eps], [eps, 0.5], [1 - eps, 0.5]])\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, eps])\n            pts.append([t, 1 - eps])\n            pts.append([eps, t])\n            pts.append([1 - eps, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0:\n                    pts = np.vstack([pts, [t, eps]])\n                elif edge == 1:\n                    pts = np.vstack([pts, [t, 1 - eps]])\n                elif edge == 2:\n                    pts = np.vstack([pts, [eps, t]])\n                else:\n                    pts = np.vstack([pts, [1 - eps, t]])\n        return pts[:n]\n\n    def init_center_biased():\n        pts = []\n        for _ in range(n):\n            x = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            y = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            pts.append([float(x), float(y)])\n        return np.array(pts, dtype=float)\n\n    # --- SLP step LP ---------------------------------------------------------\n    def build_slp_lp(centers, radii, s_pos, s_r_up, s_r_down):\n        \"\"\"\n        Build linear program: maximize sum \u0394r\n        Variables: [\u0394x_0, \u0394y_0, \u0394r_0, \u0394x_1, \u0394y_1, \u0394r_1, ...]\n        \"\"\"\n        try:\n            from scipy.optimize import linprog  # noqa: F401\n        except Exception:\n            return None\n\n        N = centers.shape[0]\n        var_dim = 3 * N\n\n        A_rows = []\n        b_vals = []\n\n        # Boundary constraints per circle i\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            # x_i + dx_i - (r_i + dr_i) >= 0  -> -dx_i + dr_i <= x_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(xi - ri)\n            # x_i + dx_i + (r_i + dr_i) <= 1  -> dx_i + dr_i <= 1 - x_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - xi - ri)\n            # y_i + dy_i - (r_i + dr_i) >= 0  -> -dy_i + dr_i <= y_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(yi - ri)\n            # y_i + dy_i + (r_i + dr_i) <= 1  -> dy_i + dr_i <= 1 - y_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - yi - ri)\n\n        # Pairwise linearized non-overlap\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        for i in range(N):\n            for j in range(i + 1, N):\n                dij = D[i, j]\n                if dij <= 1e-12:\n                    u = np.array([1.0, 0.0])\n                    dij = 0.0\n                else:\n                    u = diff[i, j] / dij\n                row = np.zeros(var_dim)\n                # -u\u00b7\u0394c_i\n                row[3 * i + 0] += -u[0]\n                row[3 * i + 1] += -u[1]\n                # +u\u00b7\u0394c_j\n                row[3 * j + 0] += u[0]\n                row[3 * j + 1] += u[1]\n                # +\u0394ri + \u0394rj\n                row[3 * i + 2] += 1.0\n                row[3 * j + 2] += 1.0\n                rhs = dij - (radii[i] + radii[j])\n                A_rows.append(row)\n                b_vals.append(rhs)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        # Bounds: trust region and minimum radius\n        bounds = []\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            dx_lo = max(-s_pos, -xi)\n            dx_hi = min(s_pos, 1.0 - xi)\n            dy_lo = max(-s_pos, -yi)\n            dy_hi = min(s_pos, 1.0 - yi)\n            dr_lo = max(-s_r_down, r_min - ri)\n            dr_hi = s_r_up\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n            bounds.append((dr_lo, dr_hi))\n\n        c = np.zeros(var_dim, dtype=float)\n        for i in range(N):\n            c[3 * i + 2] = -1.0\n\n        return c, A_ub, b_ub, bounds\n\n    def slp_optimize(centers_init, time_left_func):\n        \"\"\"\n        Run SLP with adaptive trust region. Track best feasible solution via full radii LP.\n        \"\"\"\n        centers = centers_init.copy()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        s_pos = 0.06\n        s_r_up = 0.03\n        s_r_down = 0.05\n        s_min = 1e-4\n        s_max = 0.15\n        stagnation = 0\n        max_iters = 2000\n\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return best_centers, best_r, best_score, local_scores\n\n        for _ in range(max_iters):\n            if time_left_func() < 0.08:\n                break\n\n            built = build_slp_lp(centers, r, s_pos, s_r_up, s_r_down)\n            if built is None:\n                break\n            c, A_ub, b_ub, bounds = built\n\n            try:\n                res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n            except Exception:\n                break\n\n            if not (res.success and res.x is not None):\n                s_pos *= 0.6\n                s_r_up *= 0.6\n                s_r_down *= 0.6\n                if s_pos < s_min:\n                    break\n                continue\n\n            delta = res.x.reshape(-1, 3)\n            approx_impr = -res.fun\n\n            centers += delta[:, :2]\n            r += delta[:, 2]\n\n            # Conservative box projection\n            b = boundary_limits(centers)\n            r = np.minimum(r, b)\n            r = np.maximum(r, r_min)\n\n            # Full LP repair\n            r_rep, _ = solve_radii_lp(centers, r_min)\n            score = float(np.sum(r_rep))\n\n            if score > best_score + 1e-9:\n                best_score = score\n                best_centers = centers.copy()\n                best_r = r_rep.copy()\n                local_scores.append(best_score)\n                stagnation = 0\n                s_pos = min(s_max, s_pos * 1.08)\n                s_r_up = min(s_max, s_r_up * 1.08)\n                s_r_down = min(s_max, s_r_down * 1.02)\n            else:\n                stagnation += 1\n                if approx_impr < 1e-6:\n                    s_pos *= 0.7\n                    s_r_up *= 0.7\n                    s_r_down *= 0.7\n                if stagnation % 7 == 0:\n                    idxs = rng.choice(n, size=max(3, n // 6), replace=False)\n                    jitter = rng.normal(scale=0.02, size=(len(idxs), 2))\n                    centers[idxs] = np.clip(centers[idxs] + jitter, 0.0, 1.0)\n                    r_rep2, _ = solve_radii_lp(centers, r_min)\n                    if float(np.sum(r_rep2)) > score + 1e-9:\n                        r = r_rep2\n                    else:\n                        centers = 0.7 * centers + 0.3 * best_centers\n                        r = r_rep2\n\n            if s_pos < s_min and s_r_up < s_min and s_r_down < s_min:\n                break\n\n        return best_centers, best_r, best_score, local_scores\n\n    # Lightweight physics fallback if LP for SLP is unavailable\n    def physics_optimize(centers_init, time_left_func):\n        centers = centers_init.copy()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        dt = 0.15\n        damping = 0.9\n        vel = np.zeros_like(centers)\n        max_iters = 1500\n        for _ in range(max_iters):\n            if time_left_func() < 0.05:\n                break\n            forces = np.zeros_like(centers)\n            # Mild pull toward center to counter boundary crowding\n            to_center = (0.5 - centers)\n            forces += 0.02 * to_center / (np.linalg.norm(to_center, axis=1, keepdims=True) + 1e-9)\n\n            diff = centers[:, None, :] - centers[None, :, :]\n            D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0)) + 1e-12\n            for i in range(n):\n                for j in range(i + 1, n):\n                    overlap = (r[i] + r[j]) - D[i, j]\n                    if overlap > 0:\n                        dir_ij = diff[i, j] / D[i, j]\n                        f = 0.2 * overlap\n                        forces[i] += f * dir_ij\n                        forces[j] -= f * dir_ij\n\n            vel = damping * vel + dt * forces\n            step = np.clip(vel, -0.05, 0.05)\n            centers = np.clip(centers + step, 0.0, 1.0)\n            r_new, _ = solve_radii_lp(centers, r_min)\n            score = float(np.sum(r_new))\n            if score > best_score + 1e-9:\n                best_score = score\n                best_centers = centers.copy()\n                best_r = r_new.copy()\n                local_scores.append(best_score)\n        return best_centers, best_r, best_score, local_scores\n\n    # --- Seeding -------------------------------------------------------------\n    seed_centers_list = []\n\n    # Warm start from current_best_solution\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = cb[:, :2].astype(float)\n                seed_centers_list.append(centers_cb)\n                # Two small jitters around existing best\n                for _ in range(2):\n                    seed_centers_list.append(\n                        np.clip(\n                            centers_cb + rng.normal(0, 0.01, size=centers_cb.shape),\n                            0.0,\n                            1.0,\n                        )\n                    )\n        except Exception:\n            pass\n\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n\n    rng2 = np.random.default_rng(777)\n    jitter_hex = init_hex_grid() + rng2.normal(0, 0.02, size=(n, 2))\n    seed_centers_list.append(np.clip(jitter_hex, 0.0, 1.0))\n\n    # Ensure uniqueness (up to coarse rounding) with small jitter if duplicate\n    unique_seeds = []\n    seen_hashes = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen_hashes:\n            c2 = np.clip(c + rng.normal(0, 0.005, size=c.shape), 0.0, 1.0)\n            unique_seeds.append(c2)\n        else:\n            unique_seeds.append(c)\n            seen_hashes.add(h)\n    seed_centers_list = unique_seeds\n\n    best_global_circles = None\n    best_global_score = -1e18\n\n    # Check whether we have linprog available for SLP; if not, use physics fallback\n    try:\n        from scipy.optimize import linprog  # noqa: F401\n        have_slp = True\n    except Exception:\n        have_slp = False\n\n    # Allocate time per seed adaptively\n    per_seed_time = max(0.2, time_left() / max(1, len(seed_centers_list)))\n\n    for centers0 in seed_centers_list:\n        if time_left() < 0.15:\n            break\n\n        circles0, score0 = feasible_from_centers(centers0)\n        if score0 > best_global_score:\n            best_global_score = score0\n            best_global_circles = circles0\n            all_scores.append(best_global_score)\n\n        t_seed_start = time.time()\n\n        def time_left_seed():\n            tl = time_left()\n            tl_seed = per_seed_time - (time.time() - t_seed_start)\n            return min(tl, tl_seed)\n\n        if have_slp:\n            centers_best, r_best, score_best, local_scores = slp_optimize(\n                centers0, time_left_seed\n            )\n        else:\n            centers_best, r_best, score_best, local_scores = physics_optimize(\n                centers0, time_left_seed\n            )\n\n        for s in local_scores:\n            if not all_scores or s > all_scores[-1] + 1e-9:\n                all_scores.append(s)\n\n        circles_seed = np.hstack([centers_best, r_best.reshape(-1, 1)])\n        centers_final = circles_seed[:, :2]\n        r_final, _ = solve_radii_lp(centers_final, r_min)\n        score_final = float(np.sum(r_final))\n        if score_final > best_global_score + 1e-9:\n            best_global_score = score_final\n            best_global_circles = np.hstack(\n                [centers_final, r_final.reshape(-1, 1)]\n            )\n            all_scores.append(best_global_score)\n\n    # Final safety fallback\n    if best_global_circles is None or not np.all(np.isfinite(best_global_circles)):\n        centers = init_edges()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_global_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_global_score = float(np.sum(r))\n        all_scores.append(best_global_score)\n\n    # One more feasibility polish on best centers\n    try:\n        centers_final = best_global_circles[:, :2]\n        r_final, _ = solve_radii_lp(centers_final, r_min)\n        best_global_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n        best_global_score = float(np.sum(r_final))\n    except Exception:\n        pass\n\n    return {\n        \"circles\": best_global_circles.astype(float),\n        \"all_scores\": [float(s) for s in all_scores] if all_scores else [best_global_score],\n    }",
    "best_circles": [
        [
            0.07896654972008654,
            0.07896654972008654,
            0.07896654972008654
        ],
        [
            0.2546674236336759,
            0.09773377842715367,
            0.09773377842715367
        ],
        [
            0.4532553108722105,
            0.10087901438104024,
            0.10087901438104024
        ],
        [
            0.5485760705633747,
            0.2736453412776943,
            0.09643862532069096
        ],
        [
            0.6592385973676681,
            0.10514851521845385,
            0.10514851521845385
        ],
        [
            0.8820086092380357,
            0.11799139076196427,
            0.11799139076196427
        ],
        [
            0.12399849877414754,
            0.2768729277746082,
            0.12399849877414754
        ],
        [
            0.3480653319337803,
            0.2721533033750112,
            0.10011803470042681
        ],
        [
            0.45043629210853353,
            0.41255907270560477,
            0.07364500379860715
        ],
        [
            0.6221854787076452,
            0.4609200408117226,
            0.10478303865441484
        ],
        [
            0.7476714942281025,
            0.29438835267663843,
            0.1037344504066261
        ],
        [
            0.9255306306493398,
            0.30546666335918743,
            0.07446936935066018
        ],
        [
            0.07141448401330765,
            0.46507801599892273,
            0.07141448401330765
        ],
        [
            0.2654154779903639,
            0.4795324651008279,
            0.12312424416934846
        ],
        [
            0.46068281277092465,
            0.5844374690120411,
            0.09853854449378106
        ],
        [
            0.6634356936394898,
            0.694008547359001,
            0.13192740073591688
        ],
        [
            0.8611017234820721,
            0.5088743038861223,
            0.13889827651792785
        ],
        [
            0.8941715937419589,
            0.7513563299076894,
            0.10582840625804113
        ],
        [
            0.10284393824167229,
            0.6364786785813703,
            0.10284393824167229
        ],
        [
            0.2977754942872893,
            0.703678422660541,
            0.10334557930631466
        ],
        [
            0.46714730305778357,
            0.757109170364975,
            0.07425412341428048
        ],
        [
            0.5625218879411149,
            0.9013407101125989,
            0.09865928988740114
        ],
        [
            0.7585348196986941,
            0.9026420384232163,
            0.09735796157678367
        ],
        [
            0.9270660874677373,
            0.9270660874677373,
            0.07293391253226267
        ],
        [
            0.13120079632700188,
            0.868799203672998,
            0.13120079632700188
        ],
        [
            0.3622042402332639,
            0.8983188505892261,
            0.10168114941077389
        ]
    ],
    "code_candidate": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Breakthrough optimizer for sum-of-radii circle packing in a unit square (N=26).\n    Core idea: Full-center optimization using LP for optimal radii and LP-dual-driven gradient ascent on centers.\n    Hybrid with adaptive restarts, line search, and slack-based dual approximations if LP duals unavailable.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    time_budget = max(1.0, float(timeout) - 0.5)\n    rng = np.random.default_rng()\n\n    # Global parameters\n    r_min = 1e-8\n    eps = 1e-6\n    all_scores = []\n\n    # Helper functions\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Feasibility projection to approximate optimal radii (no duals)\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        r = np.minimum(b, 0.5).copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 3000\n        tol = 1e-12\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n_local):\n                ri = r[i]\n                for j in range(i + 1, n_local):\n                    dij = D[i, j]\n                    s = ri + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        dec = 0.5 * excess\n                        if r[i] - dec < r_min_local:\n                            dec_i = r[i] - r_min_local\n                            dec_j = excess - dec_i\n                            r[i] = r_min_local\n                            r[j] = max(r_min_local, r[j] - dec_j)\n                        elif r[j] - dec < r_min_local:\n                            dec_j = r[j] - r_min_local\n                            dec_i = excess - dec_j\n                            r[j] = r_min_local\n                            r[i] = max(r_min_local, r[i] - dec_i)\n                        else:\n                            r[i] -= dec\n                            r[j] -= dec\n                        viol = max(viol, excess)\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, None, None, True\n\n    def solve_radii_lp_with_duals(centers, r_min_local):\n        # Solve LP maximize sum r subject to r_i <= b_i, r_i + r_j <= d_ij, r_i >= r_min\n        # Return radii and duals for constraints if available\n        try:\n            from scipy.optimize import linprog\n            n_local = centers.shape[0]\n            b = boundary_limits(centers)\n            D = pairwise_distances(centers)\n\n            # Build A_ub and b_ub\n            # First n constraints: r_i <= b_i\n            A_rows = []\n            b_vals = []\n            for i in range(n_local):\n                row = np.zeros(n_local, dtype=float)\n                row[i] = 1.0\n                A_rows.append(row)\n                b_vals.append(b[i])\n\n            # Next constraints: r_i + r_j <= d_ij for i<j\n            pair_indices = []\n            for i in range(n_local):\n                for j in range(i + 1, n_local):\n                    row = np.zeros(n_local, dtype=float)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_rows.append(row)\n                    b_vals.append(D[i, j])\n                    pair_indices.append((i, j))\n\n            if len(A_rows) == 0:\n                A_ub = None\n                b_ub = None\n            else:\n                A_ub = np.vstack(A_rows)\n                b_ub = np.array(b_vals, dtype=float)\n\n            bounds = [(r_min_local, None)] * n_local\n            c = -np.ones(n_local, dtype=float)\n\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not (hasattr(res, \"success\") and res.success and res.x is not None):\n                return solve_radii_lp_fallback(centers, r_min_local)\n            r = np.array(res.x, dtype=float)\n            r = np.maximum(r, r_min_local)\n            r = np.minimum(r, b)\n\n            # Extract duals if available\n            alpha = None\n            beta = None\n            try:\n                y = None\n                if hasattr(res, \"ineqlin\") and hasattr(res.ineqlin, \"marginals\"):\n                    y = np.array(res.ineqlin.marginals, dtype=float)\n                elif hasattr(res, \"slack\") and hasattr(res, \"lambda\"):\n                    # Legacy; unlikely\n                    y = np.array(res.lambda_, dtype=float)\n                if y is not None and y.size == (n_local + len(pair_indices)):\n                    y = np.maximum(y, 0.0)\n                    alpha = y[:n_local].copy()\n                    beta = np.zeros((n_local, n_local), dtype=float)\n                    k = n_local\n                    for (i, j) in pair_indices:\n                        bij = y[k]\n                        beta[i, j] = bij\n                        beta[j, i] = bij\n                        k += 1\n            except Exception:\n                alpha = None\n                beta = None\n\n            return r, alpha, beta, True\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def approx_duals_from_slacks(centers, r, tau_b=5e-3, tau_p=5e-3):\n        # Heuristic duals based on tightness of constraints\n        b = boundary_limits(centers)\n        D = pairwise_distances(centers)\n        slack_b = b - r\n        alpha = np.exp(-np.maximum(slack_b, 0.0) / tau_b)\n\n        # Pairwise\n        slack_p = D - (r[:, None] + r[None, :])\n        beta = np.exp(-np.maximum(slack_p, 0.0) / tau_p)\n        np.fill_diagonal(beta, 0.0)\n        # Only consider upper triangle\n        beta = np.triu(beta, 1)\n        beta = beta + beta.T\n        return alpha, beta\n\n    def compute_gradient_from_duals(centers, alpha, beta):\n        # Gradient of optimal LP value w.r.t centers via envelope theorem\n        n_local = centers.shape[0]\n        G = np.zeros_like(centers)\n        # Pairwise contributions: sum_j beta_ij * (c_i - c_j)/d_ij\n        if beta is not None:\n            D = pairwise_distances(centers)\n            with np.errstate(divide='ignore', invalid='ignore'):\n                for i in range(n_local):\n                    for j in range(i + 1, n_local):\n                        bij = beta[i, j]\n                        if bij <= 0.0:\n                            continue\n                        dij = D[i, j]\n                        if dij <= 1e-12:\n                            # jitter to avoid zero division\n                            v = rng.normal(size=2)\n                            v /= np.linalg.norm(v) + 1e-12\n                        else:\n                            v = (centers[i] - centers[j]) / dij\n                        G[i] += bij * v\n                        G[j] -= bij * v\n\n        # Boundary contributions: alpha_i * grad b_i\n        if alpha is not None:\n            x = centers[:, 0]\n            y = centers[:, 1]\n            dists = np.stack([x, 1 - x, y, 1 - y], axis=1)\n            mins = np.min(dists, axis=1)\n            tol = 1e-9\n            for i in range(n_local):\n                ai = alpha[i]\n                if ai <= 0.0:\n                    continue\n                # Active edges (subgradient of min)\n                active = []\n                if abs(dists[i, 0] - mins[i]) <= tol:\n                    active.append(np.array([1.0, 0.0]))\n                if abs(dists[i, 1] - mins[i]) <= tol:\n                    active.append(np.array([-1.0, 0.0]))\n                if abs(dists[i, 2] - mins[i]) <= tol:\n                    active.append(np.array([0.0, 1.0]))\n                if abs(dists[i, 3] - mins[i]) <= tol:\n                    active.append(np.array([0.0, -1.0]))\n                if not active:\n                    continue\n                gi = np.mean(active, axis=0)\n                G[i] += ai * gi\n        return G\n\n    def normalize_step(G):\n        # Normalize gradients to avoid huge steps; per-vector clip and global scaling\n        Gn = G.copy()\n        norms = np.linalg.norm(Gn, axis=1) + 1e-12\n        maxn = np.max(norms)\n        if maxn > 0.0:\n            Gn /= (maxn)\n        return Gn\n\n    def clamp_centers(centers):\n        return np.clip(centers, eps, 1.0 - eps)\n\n    def score_from_radii(r):\n        return float(np.sum(r))\n\n    def construct_solution(centers):\n        r, _, _, ok = solve_radii_lp_with_duals(centers, r_min)\n        if not ok or r is None:\n            r, _, _, _ = solve_radii_lp_fallback(centers, r_min)\n        circles = np.hstack([centers, r.reshape(-1, 1)])\n        return circles, score_from_radii(r)\n\n    # Initializations\n    def hex_jitter_init(N):\n        # Create approximately hexagonal grid inside [0,1]^2 with jitter\n        rows = int(np.floor(np.sqrt(N)))\n        cols = int(np.ceil(N / rows))\n        xs = np.linspace(0.1, 0.9, cols)\n        ys = np.linspace(0.1, 0.9, rows)\n        centers = []\n        idx = 0\n        for ri, y in enumerate(ys):\n            offset = 0.0 if (ri % 2 == 0) else (xs[1]-xs[0]) * 0.5 if len(xs) > 1 else 0.0\n            for ci, x in enumerate(xs):\n                if idx >= N:\n                    break\n                xx = np.clip(x + offset, 0.05, 0.95)\n                jitter = 0.02\n                centers.append([xx + rng.normal(0, jitter), y + rng.normal(0, jitter)])\n                idx += 1\n            if idx >= N:\n                break\n        centers = np.array(centers, dtype=float)\n        # If still not enough, random fill\n        while centers.shape[0] < N:\n            centers = np.vstack([centers, rng.uniform(0.1, 0.9, size=(1, 2))])\n        return clamp_centers(centers)\n\n    def uniform_init(N):\n        return clamp_centers(rng.uniform(0.05, 0.95, size=(N, 2)))\n\n    def edge_bias_init(N):\n        # Mix of interior and edge-skim positions\n        k_edge = N // 3\n        k_int = N - k_edge\n        centers = []\n        # Interior\n        centers.append(rng.uniform(0.2, 0.8, size=(k_int, 2)))\n        # Edge points\n        for _ in range(k_edge):\n            edge = rng.integers(0, 4)\n            t = rng.uniform(0.05, 0.95)\n            if edge == 0:\n                pt = [t, 0.05 + 0.02 * rng.random()]\n            elif edge == 1:\n                pt = [t, 0.95 - 0.02 * rng.random()]\n            elif edge == 2:\n                pt = [0.05 + 0.02 * rng.random(), t]\n            else:\n                pt = [0.95 - 0.02 * rng.random(), t]\n            centers.append(pt)\n        centers = np.vstack(centers)\n        return clamp_centers(centers[:N])\n\n    init_candidates = []\n\n    # Use current best centers if provided\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = cb[:, :2].astype(float)\n                init_candidates.append(clamp_centers(centers_cb))\n                # Slight jitters\n                for _ in range(2):\n                    init_candidates.append(clamp_centers(centers_cb + rng.normal(0, 0.01, size=centers_cb.shape)))\n        except Exception:\n            pass\n\n    init_candidates.append(hex_jitter_init(n))\n    init_candidates.append(uniform_init(n))\n    init_candidates.append(edge_bias_init(n))\n    for _ in range(3):\n        init_candidates.append(uniform_init(n))\n\n    best_circles = None\n    best_score = -1e18\n\n    # Main optimization loop over inits\n    for init_idx, init_centers in enumerate(init_candidates):\n        if time_left() < 0.15:\n            break\n        centers = init_centers.copy()\n        # Initial solve\n        r, alpha, beta, ok = solve_radii_lp_with_duals(centers, r_min)\n        if not ok or r is None:\n            r, _, _, _ = solve_radii_lp_fallback(centers, r_min)\n            alpha, beta = approx_duals_from_slacks(centers, r)\n        score = score_from_radii(r)\n\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n            all_scores.append(best_score)\n\n        # Gradient ascent with dual-driven gradients\n        max_iters = 4000\n        step = 0.15\n        step_min = 1e-4\n        step_max = 0.5\n        patience = 15\n        no_improve = 0\n        noise_scale = 0.02\n\n        iter_count = 0\n        while iter_count < max_iters and time_left() > 0.05:\n            iter_count += 1\n            # Compute gradient\n            if alpha is None or beta is None:\n                alpha, beta = approx_duals_from_slacks(centers, r)\n\n            G = compute_gradient_from_duals(centers, alpha, beta)\n            if not np.all(np.isfinite(G)):\n                G = np.nan_to_num(G, nan=0.0, posinf=0.0, neginf=0.0)\n\n            # Normalize gradient\n            Gn = normalize_step(G)\n\n            # Add exploration noise that decays\n            exploration = noise_scale * max(0.0, 1.0 - iter_count / max_iters)\n            prop_centers = clamp_centers(centers + step * Gn + rng.normal(0, exploration, size=centers.shape))\n\n            # Backtracking line search\n            accepted = False\n            ls_step = step\n            for _ in range(12):\n                rr, aa, bb, ok2 = solve_radii_lp_with_duals(prop_centers, r_min)\n                if not ok2 or rr is None:\n                    rr, _, _, _ = solve_radii_lp_fallback(prop_centers, r_min)\n                    aa, bb = approx_duals_from_slacks(prop_centers, rr)\n                new_score = score_from_radii(rr)\n                if new_score > score + 1e-9:\n                    centers = prop_centers\n                    r = rr\n                    alpha, beta = aa, bb\n                    score = new_score\n                    accepted = True\n                    break\n                else:\n                    ls_step *= 0.5\n                    prop_centers = clamp_centers(centers + ls_step * Gn)\n            if accepted:\n                # Increase step a bit on success\n                step = min(step_max, step * 1.05)\n                no_improve = 0\n            else:\n                step = max(step_min, step * 0.5)\n                no_improve += 1\n\n            # Occasional random relocation of a few centers to escape local traps\n            if no_improve >= patience:\n                idxs = rng.choice(n, size=max(1, n // 6), replace=False)\n                centers[idxs] = clamp_centers(centers[idxs] + rng.normal(0, 0.15, size=(len(idxs), 2)))\n                # Re-solve after shake\n                r, alpha, beta, ok = solve_radii_lp_with_duals(centers, r_min)\n                if not ok or r is None:\n                    r, _, _, _ = solve_radii_lp_fallback(centers, r_min)\n                    alpha, beta = approx_duals_from_slacks(centers, r)\n                score = score_from_radii(r)\n                no_improve = 0\n                step = min(step_max, step * 1.2)\n\n            # Update best\n            if score > best_score + 1e-12:\n                best_score = score\n                best_circles = np.hstack([centers, r.reshape(-1, 1)])\n                all_scores.append(best_score)\n\n            # Time check\n            if time_left() < 0.05:\n                break\n\n    # Final fallback if none\n    if best_circles is None or not np.all(np.isfinite(best_circles)):\n        centers = uniform_init(n)\n        r, _, _, ok = solve_radii_lp_with_duals(centers, r_min)\n        if not ok or r is None:\n            r, _, _, _ = solve_radii_lp_fallback(centers, r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = score_from_radii(r)\n        all_scores.append(best_score)\n\n    # Ensure feasibility via final LP solve on best centers\n    try:\n        centers_final = best_circles[:, :2]\n        r_final, _, _, ok = solve_radii_lp_with_duals(centers_final, r_min)\n        if not ok or r_final is None:\n            r_final, _, _, _ = solve_radii_lp_fallback(centers_final, r_min)\n        best_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n        best_score = score_from_radii(r_final)\n    except Exception:\n        pass\n\n    return {\n        'circles': best_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [float(best_score)]\n    }",
    "code_score": 2.6202801930138455,
    "refiner_prompt": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Breakthrough circle packing via Sequential Linear Programming (SLP) on centers and radii.\n    Maximize sum of radii for N=26 circles inside unit square with non-overlap constraints.\n\n    Strategy:\n    - Multi-start initialization (grids, edge-biased, warm-start from current_best_solution).\n    - Iteratively solve LP on increments (dx, dy, dr) with linearized non-overlap constraints and boundary constraints.\n    - Adaptive trust region for stable improvements.\n    - Final feasibility repair via LP on radii given centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    # Safety margin for overhead\n    time_budget = max(1.0, float(timeout) - 0.3)\n    rng = np.random.default_rng(42)\n\n    r_min = 1e-6\n\n    all_scores = []\n\n    # Helpers\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.sum(diff * diff, axis=2))\n        return D\n\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Iterative feasibility projection heuristic\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        r = b.copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 5000\n        tol = 1e-10\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n_local):\n                for j in range(i + 1, n_local):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        r[j] = r_min_local\n                        continue\n                    s = r[i] + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = r[i] + r[j]\n                        if total <= 0:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (r[i] / total)\n                            dec_j = excess * (r[j] / total)\n                        new_ri = max(r_min_local, r[i] - dec_i)\n                        new_rj = max(r_min_local, r[j] - dec_j)\n                        remaining = excess - ((r[i] - new_ri) + (r[j] - new_rj))\n                        if remaining > 0:\n                            if new_ri > new_rj and new_ri - remaining >= r_min_local:\n                                new_ri -= remaining\n                            elif new_rj - remaining >= r_min_local:\n                                new_rj -= remaining\n                        r[i] = new_ri\n                        r[j] = new_rj\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True\n\n    def solve_radii_lp(centers, r_min_local):\n        try:\n            from scipy.optimize import linprog\n            n_local = centers.shape[0]\n            b = boundary_limits(centers)\n            D = pairwise_distances(centers)\n\n            # Constraints: r_i <= b_i\n            A_rows = []\n            b_vals = []\n            for i in range(n_local):\n                row = np.zeros(n_local)\n                row[i] = 1.0\n                A_rows.append(row)\n                b_vals.append(b[i])\n\n            # Constraints: r_i + r_j <= d_ij\n            for i in range(n_local):\n                for j in range(i + 1, n_local):\n                    row = np.zeros(n_local)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_rows.append(row)\n                    b_vals.append(D[i, j])\n\n            A_ub = np.array(A_rows) if A_rows else None\n            b_ub = np.array(b_vals) if b_vals else None\n            bounds = [(r_min_local, None)] * n_local\n            c = -np.ones(n_local, dtype=float)\n\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                r = res.x.astype(float)\n                r = np.maximum(r, r_min_local)\n                r = np.minimum(r, b)\n                return r, True\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def feasible_from_centers(centers):\n        r, _ = solve_radii_lp(centers, r_min)\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r))\n\n    # Initializations\n    def init_hex_grid():\n        # Place points in a jittered hex-like grid inside [0,1]^2\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        sx = 1.0 / (cols + 1)\n        sy = 1.0 / (rows + 1)\n        pts = []\n        cnt = 0\n        for r_idx in range(rows):\n            x_off = 0.0 if (r_idx % 2 == 0) else 0.5 * sx\n            for c_idx in range(cols):\n                if cnt >= K:\n                    break\n                x = (c_idx + 1) * sx + x_off\n                y = (r_idx + 1) * sy\n                jx = rng.normal(0, 0.08 * sx)\n                jy = rng.normal(0, 0.08 * sy)\n                x = float(np.clip(x + jx, 0.02, 0.98))\n                y = float(np.clip(y + jy, 0.02, 0.98))\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        if pts.shape[0] < n:\n            # Fill random near center\n            for _ in range(n - pts.shape[0]):\n                x = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                y = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                pts = np.vstack([pts, [x, y]])\n        return pts[:n]\n\n    def init_edges():\n        # Emphasize corners and edges\n        pts = []\n        eps = 1e-3\n        corners = [\n            [eps, eps], [1 - eps, eps], [eps, 1 - eps], [1 - eps, 1 - eps]\n        ]\n        pts.extend(corners)\n        # Edge midpoints\n        pts.extend([[0.5, eps], [0.5, 1 - eps], [eps, 0.5], [1 - eps, 0.5]])\n        # Additional evenly spaced edge points\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, eps])\n        for t in ts:\n            pts.append([t, 1 - eps])\n        for t in ts:\n            pts.append([eps, t])\n        for t in ts:\n            pts.append([1 - eps, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0:\n                    pts = np.vstack([pts, [t, eps]])\n                elif edge == 1:\n                    pts = np.vstack([pts, [t, 1 - eps]])\n                elif edge == 2:\n                    pts = np.vstack([pts, [eps, t]])\n                else:\n                    pts = np.vstack([pts, [1 - eps, t]])\n        return pts[:n]\n\n    def init_center_biased():\n        # Random points biased toward center\n        pts = []\n        for _ in range(n):\n            x = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            y = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            pts.append([float(x), float(y)])\n        return np.array(pts, dtype=float)\n\n    # SLP step builder\n    def build_slp_lp(centers, radii, s_pos, s_r_up, s_r_down):\n        \"\"\"\n        Build linear program: maximize sum \u0394r\n        Variables: [\u0394x_0, \u0394y_0, \u0394r_0, \u0394x_1, \u0394y_1, \u0394r_1, ...]\n        Constraints:\n          - Boundary linearized\n          - Pairwise non-overlap linearized\n          - Trust region and bounds via variable bounds\n        \"\"\"\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return None  # signal no LP available\n\n        N = centers.shape[0]\n        var_dim = 3 * N\n\n        A_rows = []\n        b_vals = []\n\n        # Boundary constraints per circle i\n        # x_i + dx_i - (r_i + dr_i) >= 0  -> -dx_i + dr_i <= x_i - r_i\n        # x_i + dx_i + (r_i + dr_i) <= 1  -> dx_i + dr_i <= 1 - x_i - r_i\n        # y_i + dy_i - (r_i + dr_i) >= 0  -> -dy_i + dr_i <= y_i - r_i\n        # y_i + dy_i + (r_i + dr_i) <= 1  -> dy_i + dr_i <= 1 - y_i - r_i\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            # -dx_i + dr_i <= xi - ri\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(xi - ri)\n            # dx_i + dr_i <= 1 - xi - ri\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - xi - ri)\n            # -dy_i + dr_i <= yi - ri\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(yi - ri)\n            # dy_i + dr_i <= 1 - yi - ri\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - yi - ri)\n\n        # Pairwise constraints linearized:\n        # dnorm + u\u00b7(\u0394c_i - \u0394c_j) - (ri + rj) - (\u0394ri + \u0394rj) >= 0\n        # => -u\u00b7\u0394c_i + u\u00b7\u0394c_j + \u0394ri + \u0394rj <= dnorm - (ri + rj)\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.sum(diff * diff, axis=2))\n        for i in range(N):\n            for j in range(i + 1, N):\n                dij = D[i, j]\n                if dij <= 1e-12:\n                    u = np.array([1.0, 0.0])\n                    dij = 0.0\n                else:\n                    u = diff[i, j] / dij\n                # Build row\n                row = np.zeros(var_dim)\n                # -u\u00b7\u0394c_i\n                row[3 * i + 0] += -u[0]\n                row[3 * i + 1] += -u[1]\n                # +u\u00b7\u0394c_j\n                row[3 * j + 0] += u[0]\n                row[3 * j + 1] += u[1]\n                # +\u0394ri + \u0394rj\n                row[3 * i + 2] += 1.0\n                row[3 * j + 2] += 1.0\n                rhs = dij - (radii[i] + radii[j])\n                A_rows.append(row)\n                b_vals.append(rhs)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        # Bounds: trust region and minimum radius constraint\n        bounds = []\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            # \u0394x bounds: intersection of trust region and box [0,1]\n            dx_lo = max(-s_pos, -xi)\n            dx_hi = min(s_pos, 1.0 - xi)\n            dy_lo = max(-s_pos, -yi)\n            dy_hi = min(s_pos, 1.0 - yi)\n            # \u0394r bounds: allow asymmetry to permit shrink to resolve conflicts\n            dr_lo = max(-s_r_down, r_min - ri)\n            dr_hi = s_r_up\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n            bounds.append((dr_lo, dr_hi))\n\n        # Objective: maximize sum \u0394r -> minimize -sum \u0394r\n        c = np.zeros(var_dim, dtype=float)\n        for i in range(N):\n            c[3 * i + 2] = -1.0\n\n        return c, A_ub, b_ub, bounds\n\n    def slp_optimize(centers_init, time_left_func):\n        \"\"\"\n        Run SLP with adaptive trust region. Track best feasible solution via full radii LP.\n        \"\"\"\n        centers = centers_init.copy()\n        # Start with feasible radii for given centers\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        # Trust region parameters\n        s_pos = 0.06\n        s_r_up = 0.03\n        s_r_down = 0.05\n        s_min = 1e-4\n        s_max = 0.15\n        stagnation = 0\n        max_iters = 2000\n\n        for it in range(max_iters):\n            if time_left_func() < 0.08:\n                break\n\n            try:\n                built = build_slp_lp(centers, r, s_pos, s_r_up, s_r_down)\n                if built is None:\n                    # No LP available; break to fallback later\n                    break\n                c, A_ub, b_ub, bounds = built\n                from scipy.optimize import linprog\n                res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if not (res.success and res.x is not None):\n                    # Reduce trust region and continue\n                    s_pos *= 0.6\n                    s_r_up *= 0.6\n                    s_r_down *= 0.6\n                    if s_pos < s_min:\n                        break\n                    continue\n\n                delta = res.x\n                # Objective improvement on linear model:\n                approx_impr = -res.fun\n\n                # Apply step\n                delta = delta.reshape(-1, 3)\n                centers += delta[:, :2]\n                r += delta[:, 2]\n\n                # Project to ensure inside box (conservative)\n                b = boundary_limits(centers)\n                r = np.minimum(r, b)\n                r = np.maximum(r, r_min)\n\n                # Compute actual feasible radii with LP repair to ensure constraints\n                r_rep, _ok = solve_radii_lp(centers, r_min)\n                score = float(np.sum(r_rep))\n\n                if score > best_score + 1e-9:\n                    best_score = score\n                    best_centers = centers.copy()\n                    best_r = r_rep.copy()\n                    local_scores.append(best_score)\n                    stagnation = 0\n                    # Expand trust region slightly after success\n                    s_pos = min(s_max, s_pos * 1.08)\n                    s_r_up = min(s_max, s_r_up * 1.08)\n                    s_r_down = min(s_max, s_r_down * 1.02)\n                else:\n                    stagnation += 1\n                    # Contract trust region if LP step gives tiny approx improvement\n                    if approx_impr < 1e-6:\n                        s_pos *= 0.7\n                        s_r_up *= 0.7\n                        s_r_down *= 0.7\n                    # Occasional shake to escape flat regions\n                    if stagnation % 7 == 0:\n                        idxs = rng.choice(n, size=max(3, n // 6), replace=False)\n                        jitter = rng.normal(scale=0.02, size=(len(idxs), 2))\n                        centers[idxs] = np.clip(centers[idxs] + jitter, 0.0, 1.0)\n                        r_rep, _ok = solve_radii_lp(centers, r_min)\n                        if float(np.sum(r_rep)) > score + 1e-9:\n                            r = r_rep\n                        else:\n                            # revert small jitter by re-centering towards best\n                            centers = 0.7 * centers + 0.3 * best_centers\n                            r = r_rep\n\n                # If trust region becomes too small, stop\n                if s_pos < s_min and s_r_up < s_min and s_r_down < s_min:\n                    break\n\n            except Exception:\n                # On LP failure, break to fallback\n                break\n\n        return best_centers, best_r, best_score, local_scores\n\n    # Fallback physics-based local improvement (if linprog for SLP is unavailable)\n    def physics_optimize(centers_init, time_left_func):\n        centers = centers_init.copy()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        dt = 0.15\n        damping = 0.9\n        vel = np.zeros_like(centers)\n        max_iters = 2000\n        for it in range(max_iters):\n            if time_left_func() < 0.05:\n                break\n            forces = np.zeros_like(centers)\n            # Boundary forces push inward proportionally to attempting to grow\n            b = boundary_limits(centers)\n            # Encourage spreading based on current radii desire: push towards center if near boundary\n            to_center = (0.5 - centers)\n            forces += 0.02 * to_center / (np.linalg.norm(to_center, axis=1, keepdims=True) + 1e-9)\n\n            # Pairwise repulsion if too close relative to radii\n            diff = centers[:, None, :] - centers[None, :, :]\n            D = np.sqrt(np.sum(diff * diff, axis=2)) + 1e-12\n            for i in range(n):\n                for j in range(i + 1, n):\n                    overlap = (r[i] + r[j]) - D[i, j]\n                    if overlap > 0:\n                        dir_ij = diff[i, j] / D[i, j]\n                        f = 0.2 * overlap\n                        forces[i] += f * dir_ij\n                        forces[j] -= f * dir_ij\n\n            # Integrate\n            vel = damping * vel + dt * forces\n            step = np.clip(vel, -0.05, 0.05)\n            centers = np.clip(centers + step, 0.0, 1.0)\n            r_new, _ = solve_radii_lp(centers, r_min)\n            score = float(np.sum(r_new))\n            if score > best_score + 1e-9:\n                best_score = score\n                best_centers = centers.copy()\n                best_r = r_new.copy()\n                local_scores.append(best_score)\n        return best_centers, best_r, best_score, local_scores\n\n    # Warm start from current_best_solution if provided\n    seed_centers_list = []\n    if current_best_solution is not None and isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = cb[:, :2].astype(float)\n                seed_centers_list.append(centers_cb)\n        except Exception:\n            pass\n\n    # Add multiple diverse seeds\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n    # Slightly different hex seeds\n    rng2 = np.random.default_rng(123)\n    jitter_hex = init_hex_grid() + rng2.normal(0, 0.02, size=(n, 2))\n    seed_centers_list.append(np.clip(jitter_hex, 0.0, 1.0))\n\n    # Ensure uniqueness by slight jitter\n    unique_seeds = []\n    seen_hashes = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen_hashes:\n            c2 = np.clip(c + rng.normal(0, 0.005, size=c.shape), 0.0, 1.0)\n            unique_seeds.append(c2)\n        else:\n            unique_seeds.append(c)\n            seen_hashes.add(h)\n    seed_centers_list = unique_seeds\n\n    best_global_circles = None\n    best_global_score = -1e18\n\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    # Try SLP on each seed; if SLP unavailable, physics fallback\n    tried_slp = False\n    try:\n        from scipy.optimize import linprog  # noqa: F401\n        tried_slp = True\n    except Exception:\n        tried_slp = False\n\n    per_seed_time = max(0.2, time_left() / max(1, len(seed_centers_list)))\n\n    for idx_seed, centers0 in enumerate(seed_centers_list):\n        if time_left() < 0.15:\n            break\n        # Radii repair for initial seed\n        circles0, score0 = feasible_from_centers(centers0)\n        if score0 > best_global_score:\n            best_global_score = score0\n            best_global_circles = circles0\n            all_scores.append(best_global_score)\n\n        # Set a local time slice\n        t_seed_start = time.time()\n        def time_left_seed():\n            # Time remaining for the entire run\n            tl = time_left()\n            # Also limit per seed to per_seed_time\n            tl_seed = per_seed_time - (time.time() - t_seed_start)\n            return min(tl, tl_seed)\n\n        if tried_slp:\n            centers_best, r_best, score_best, local_scores = slp_optimize(centers0, time_left_seed)\n        else:\n            centers_best, r_best, score_best, local_scores = physics_optimize(centers0, time_left_seed)\n\n        # Append intermediate improvements\n        for s in local_scores:\n            if not all_scores or s > all_scores[-1] + 1e-9:\n                all_scores.append(s)\n\n        # Final feasibility repair with full radii LP\n        circles_seed = np.hstack([centers_best, r_best.reshape(-1, 1)])\n        centers_final = circles_seed[:, :2]\n        r_final, _ = solve_radii_lp(centers_final, r_min)\n        score_final = float(np.sum(r_final))\n        if score_final > best_global_score + 1e-9:\n            best_global_score = score_final\n            best_global_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n            all_scores.append(best_global_score)\n\n    # Safety fallback if no solution found for any reason\n    if best_global_circles is None:\n        centers = init_edges()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_global_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_global_score = float(np.sum(r))\n        all_scores.append(best_global_score)\n\n    return {\n        'circles': best_global_circles.astype(float),\n        'all_scores': [float(s) for s in all_scores] if all_scores else [best_global_score]\n    }",
    "refiner_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Breakthrough circle packing via Sequential Linear Programming (SLP) on centers and radii.\n    Maximize sum of radii for N=26 circles inside unit square with non-overlap constraints.\n\n    Strategy:\n    - Multi-start initialization (grids, edge-biased, warm-start from current_best_solution).\n    - Iteratively solve LP on increments (dx, dy, dr) with linearized non-overlap constraints and boundary constraints.\n    - Adaptive trust region for stable improvements.\n    - Final feasibility repair via LP on radii given centers.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    # Slight safety margin for overhead\n    time_budget = max(1.0, float(timeout) - 0.3)\n    rng = np.random.default_rng(12345)\n\n    r_min = 1e-6\n    all_scores = []\n\n    # Helpers\n    def time_left():\n        return time_budget - (time.time() - start_time)\n\n    def boundary_limits(centers):\n        x = centers[:, 0]\n        y = centers[:, 1]\n        return np.minimum(np.minimum(x, 1 - x), np.minimum(y, 1 - y))\n\n    def pairwise_distances(centers):\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        return D\n\n    # --- Radii LP (with numeric-fallback) ------------------------------------\n    def solve_radii_lp_fallback(centers, r_min_local):\n        # Carefully balanced feasibility projection heuristic\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        # Start reasonably large but within box\n        r = b.copy()\n        r = np.maximum(r, r_min_local)\n        D = pairwise_distances(centers)\n        max_iter = 4000\n        tol = 1e-10\n        for _ in range(max_iter):\n            r = np.minimum(r, b)\n            viol = 0.0\n            for i in range(n_local):\n                for j in range(i + 1, n_local):\n                    dij = D[i, j]\n                    if dij <= 0:\n                        # Collapse one of them minimally\n                        r[j] = r_min_local\n                        continue\n                    s = r[i] + r[j]\n                    if s > dij:\n                        excess = s - dij\n                        viol = max(viol, excess)\n                        total = r[i] + r[j]\n                        if total <= 0:\n                            dec_i = dec_j = 0.5 * excess\n                        else:\n                            dec_i = excess * (r[i] / total)\n                            dec_j = excess * (r[j] / total)\n                        new_ri = max(r_min_local, r[i] - dec_i)\n                        new_rj = max(r_min_local, r[j] - dec_j)\n                        remaining = excess - ((r[i] - new_ri) + (r[j] - new_rj))\n                        if remaining > 1e-15:\n                            if new_ri > new_rj and new_ri - remaining >= r_min_local:\n                                new_ri -= remaining\n                            elif new_rj - remaining >= r_min_local:\n                                new_rj -= remaining\n                        r[i] = new_ri\n                        r[j] = new_rj\n            if viol < tol:\n                break\n        r = np.minimum(r, b)\n        r = np.maximum(r, r_min_local)\n        return r, True\n\n    def solve_radii_lp(centers, r_min_local):\n        # Maximize sum r subject to box and pairwise non-overlap\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n        n_local = centers.shape[0]\n        b = boundary_limits(centers)\n        D = pairwise_distances(centers)\n\n        A_rows = []\n        b_vals = []\n\n        # r_i <= b_i\n        for i in range(n_local):\n            row = np.zeros(n_local, dtype=float)\n            row[i] = 1.0\n            A_rows.append(row)\n            b_vals.append(b[i])\n\n        # r_i + r_j <= d_ij\n        for i in range(n_local):\n            for j in range(i + 1, n_local):\n                row = np.zeros(n_local, dtype=float)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_rows.append(row)\n                b_vals.append(D[i, j])\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n        bounds = [(r_min_local, None)] * n_local\n        c = -np.ones(n_local, dtype=float)\n\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n            if res.success and res.x is not None:\n                r = np.asarray(res.x, dtype=float)\n                r = np.maximum(r, r_min_local)\n                r = np.minimum(r, b)\n                return r, True\n            else:\n                return solve_radii_lp_fallback(centers, r_min_local)\n        except Exception:\n            return solve_radii_lp_fallback(centers, r_min_local)\n\n    def feasible_from_centers(centers):\n        r, _ = solve_radii_lp(centers, r_min)\n        return np.hstack([centers, r.reshape(-1, 1)]), float(np.sum(r))\n\n    # --- Initializations -----------------------------------------------------\n    def init_hex_grid():\n        # Jittered hex-like grid inside [0,1]^2\n        K = n\n        cols = int(np.ceil(np.sqrt(K)))\n        rows = int(np.ceil(K / cols))\n        sx = 1.0 / (cols + 1)\n        sy = 1.0 / (rows + 1)\n        pts = []\n        cnt = 0\n        for r_idx in range(rows):\n            x_off = 0.0 if (r_idx % 2 == 0) else 0.5 * sx\n            for c_idx in range(cols):\n                if cnt >= K:\n                    break\n                x = (c_idx + 1) * sx + x_off\n                y = (r_idx + 1) * sy\n                jx = rng.normal(0, 0.07 * sx)\n                jy = rng.normal(0, 0.07 * sy)\n                x = float(np.clip(x + jx, 0.02, 0.98))\n                y = float(np.clip(y + jy, 0.02, 0.98))\n                pts.append([x, y])\n                cnt += 1\n            if cnt >= K:\n                break\n        pts = np.array(pts, dtype=float)\n        if pts.shape[0] < n:\n            for _ in range(n - pts.shape[0]):\n                x = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                y = 0.6 * rng.uniform(0.1, 0.9) + 0.4 * 0.5\n                pts = np.vstack([pts, [x, y]])\n        return pts[:n]\n\n    def init_edges():\n        # Emphasize corners and edges\n        pts = []\n        eps = 1e-3\n        corners = [\n            [eps, eps], [1 - eps, eps], [eps, 1 - eps], [1 - eps, 1 - eps]\n        ]\n        pts.extend(corners)\n        # Edge midpoints\n        pts.extend([[0.5, eps], [0.5, 1 - eps], [eps, 0.5], [1 - eps, 0.5]])\n        ts = np.linspace(0.15, 0.85, 6)\n        for t in ts:\n            pts.append([t, eps])\n            pts.append([t, 1 - eps])\n            pts.append([eps, t])\n            pts.append([1 - eps, t])\n        pts = np.array(pts[:n], dtype=float)\n        if pts.shape[0] < n:\n            while pts.shape[0] < n:\n                edge = rng.integers(0, 4)\n                t = rng.uniform(0.08, 0.92)\n                if edge == 0:\n                    pts = np.vstack([pts, [t, eps]])\n                elif edge == 1:\n                    pts = np.vstack([pts, [t, 1 - eps]])\n                elif edge == 2:\n                    pts = np.vstack([pts, [eps, t]])\n                else:\n                    pts = np.vstack([pts, [1 - eps, t]])\n        return pts[:n]\n\n    def init_center_biased():\n        pts = []\n        for _ in range(n):\n            x = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            y = 0.75 * rng.uniform(0.05, 0.95) + 0.25 * 0.5\n            pts.append([float(x), float(y)])\n        return np.array(pts, dtype=float)\n\n    # --- SLP step LP ---------------------------------------------------------\n    def build_slp_lp(centers, radii, s_pos, s_r_up, s_r_down):\n        \"\"\"\n        Build linear program: maximize sum \u0394r\n        Variables: [\u0394x_0, \u0394y_0, \u0394r_0, \u0394x_1, \u0394y_1, \u0394r_1, ...]\n        \"\"\"\n        try:\n            from scipy.optimize import linprog  # noqa: F401\n        except Exception:\n            return None\n\n        N = centers.shape[0]\n        var_dim = 3 * N\n\n        A_rows = []\n        b_vals = []\n\n        # Boundary constraints per circle i\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            # x_i + dx_i - (r_i + dr_i) >= 0  -> -dx_i + dr_i <= x_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(xi - ri)\n            # x_i + dx_i + (r_i + dr_i) <= 1  -> dx_i + dr_i <= 1 - x_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 0] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - xi - ri)\n            # y_i + dy_i - (r_i + dr_i) >= 0  -> -dy_i + dr_i <= y_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = -1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(yi - ri)\n            # y_i + dy_i + (r_i + dr_i) <= 1  -> dy_i + dr_i <= 1 - y_i - r_i\n            row = np.zeros(var_dim)\n            row[3 * i + 1] = 1.0\n            row[3 * i + 2] = 1.0\n            A_rows.append(row)\n            b_vals.append(1.0 - yi - ri)\n\n        # Pairwise linearized non-overlap\n        diff = centers[:, None, :] - centers[None, :, :]\n        D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0))\n        for i in range(N):\n            for j in range(i + 1, N):\n                dij = D[i, j]\n                if dij <= 1e-12:\n                    u = np.array([1.0, 0.0])\n                    dij = 0.0\n                else:\n                    u = diff[i, j] / dij\n                row = np.zeros(var_dim)\n                # -u\u00b7\u0394c_i\n                row[3 * i + 0] += -u[0]\n                row[3 * i + 1] += -u[1]\n                # +u\u00b7\u0394c_j\n                row[3 * j + 0] += u[0]\n                row[3 * j + 1] += u[1]\n                # +\u0394ri + \u0394rj\n                row[3 * i + 2] += 1.0\n                row[3 * j + 2] += 1.0\n                rhs = dij - (radii[i] + radii[j])\n                A_rows.append(row)\n                b_vals.append(rhs)\n\n        A_ub = np.array(A_rows, dtype=float) if A_rows else None\n        b_ub = np.array(b_vals, dtype=float) if b_vals else None\n\n        # Bounds: trust region and minimum radius\n        bounds = []\n        for i in range(N):\n            xi, yi = centers[i]\n            ri = radii[i]\n            dx_lo = max(-s_pos, -xi)\n            dx_hi = min(s_pos, 1.0 - xi)\n            dy_lo = max(-s_pos, -yi)\n            dy_hi = min(s_pos, 1.0 - yi)\n            dr_lo = max(-s_r_down, r_min - ri)\n            dr_hi = s_r_up\n            bounds.append((dx_lo, dx_hi))\n            bounds.append((dy_lo, dy_hi))\n            bounds.append((dr_lo, dr_hi))\n\n        c = np.zeros(var_dim, dtype=float)\n        for i in range(N):\n            c[3 * i + 2] = -1.0\n\n        return c, A_ub, b_ub, bounds\n\n    def slp_optimize(centers_init, time_left_func):\n        \"\"\"\n        Run SLP with adaptive trust region. Track best feasible solution via full radii LP.\n        \"\"\"\n        centers = centers_init.copy()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        s_pos = 0.06\n        s_r_up = 0.03\n        s_r_down = 0.05\n        s_min = 1e-4\n        s_max = 0.15\n        stagnation = 0\n        max_iters = 2000\n\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return best_centers, best_r, best_score, local_scores\n\n        for _ in range(max_iters):\n            if time_left_func() < 0.08:\n                break\n\n            built = build_slp_lp(centers, r, s_pos, s_r_up, s_r_down)\n            if built is None:\n                break\n            c, A_ub, b_ub, bounds = built\n\n            try:\n                res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n            except Exception:\n                break\n\n            if not (res.success and res.x is not None):\n                s_pos *= 0.6\n                s_r_up *= 0.6\n                s_r_down *= 0.6\n                if s_pos < s_min:\n                    break\n                continue\n\n            delta = res.x.reshape(-1, 3)\n            approx_impr = -res.fun\n\n            centers += delta[:, :2]\n            r += delta[:, 2]\n\n            # Conservative box projection\n            b = boundary_limits(centers)\n            r = np.minimum(r, b)\n            r = np.maximum(r, r_min)\n\n            # Full LP repair\n            r_rep, _ = solve_radii_lp(centers, r_min)\n            score = float(np.sum(r_rep))\n\n            if score > best_score + 1e-9:\n                best_score = score\n                best_centers = centers.copy()\n                best_r = r_rep.copy()\n                local_scores.append(best_score)\n                stagnation = 0\n                s_pos = min(s_max, s_pos * 1.08)\n                s_r_up = min(s_max, s_r_up * 1.08)\n                s_r_down = min(s_max, s_r_down * 1.02)\n            else:\n                stagnation += 1\n                if approx_impr < 1e-6:\n                    s_pos *= 0.7\n                    s_r_up *= 0.7\n                    s_r_down *= 0.7\n                if stagnation % 7 == 0:\n                    idxs = rng.choice(n, size=max(3, n // 6), replace=False)\n                    jitter = rng.normal(scale=0.02, size=(len(idxs), 2))\n                    centers[idxs] = np.clip(centers[idxs] + jitter, 0.0, 1.0)\n                    r_rep2, _ = solve_radii_lp(centers, r_min)\n                    if float(np.sum(r_rep2)) > score + 1e-9:\n                        r = r_rep2\n                    else:\n                        centers = 0.7 * centers + 0.3 * best_centers\n                        r = r_rep2\n\n            if s_pos < s_min and s_r_up < s_min and s_r_down < s_min:\n                break\n\n        return best_centers, best_r, best_score, local_scores\n\n    # Lightweight physics fallback if LP for SLP is unavailable\n    def physics_optimize(centers_init, time_left_func):\n        centers = centers_init.copy()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_score = float(np.sum(r))\n        local_scores = [best_score]\n\n        dt = 0.15\n        damping = 0.9\n        vel = np.zeros_like(centers)\n        max_iters = 1500\n        for _ in range(max_iters):\n            if time_left_func() < 0.05:\n                break\n            forces = np.zeros_like(centers)\n            # Mild pull toward center to counter boundary crowding\n            to_center = (0.5 - centers)\n            forces += 0.02 * to_center / (np.linalg.norm(to_center, axis=1, keepdims=True) + 1e-9)\n\n            diff = centers[:, None, :] - centers[None, :, :]\n            D = np.sqrt(np.maximum(np.sum(diff * diff, axis=2), 0.0)) + 1e-12\n            for i in range(n):\n                for j in range(i + 1, n):\n                    overlap = (r[i] + r[j]) - D[i, j]\n                    if overlap > 0:\n                        dir_ij = diff[i, j] / D[i, j]\n                        f = 0.2 * overlap\n                        forces[i] += f * dir_ij\n                        forces[j] -= f * dir_ij\n\n            vel = damping * vel + dt * forces\n            step = np.clip(vel, -0.05, 0.05)\n            centers = np.clip(centers + step, 0.0, 1.0)\n            r_new, _ = solve_radii_lp(centers, r_min)\n            score = float(np.sum(r_new))\n            if score > best_score + 1e-9:\n                best_score = score\n                best_centers = centers.copy()\n                best_r = r_new.copy()\n                local_scores.append(best_score)\n        return best_centers, best_r, best_score, local_scores\n\n    # --- Seeding -------------------------------------------------------------\n    seed_centers_list = []\n\n    # Warm start from current_best_solution\n    if isinstance(current_best_solution, np.ndarray):\n        try:\n            cb = current_best_solution\n            if cb.shape[0] == n and cb.shape[1] >= 2:\n                centers_cb = cb[:, :2].astype(float)\n                seed_centers_list.append(centers_cb)\n                # Two small jitters around existing best\n                for _ in range(2):\n                    seed_centers_list.append(\n                        np.clip(\n                            centers_cb + rng.normal(0, 0.01, size=centers_cb.shape),\n                            0.0,\n                            1.0,\n                        )\n                    )\n        except Exception:\n            pass\n\n    seed_centers_list.append(init_hex_grid())\n    seed_centers_list.append(init_edges())\n    seed_centers_list.append(init_center_biased())\n\n    rng2 = np.random.default_rng(777)\n    jitter_hex = init_hex_grid() + rng2.normal(0, 0.02, size=(n, 2))\n    seed_centers_list.append(np.clip(jitter_hex, 0.0, 1.0))\n\n    # Ensure uniqueness (up to coarse rounding) with small jitter if duplicate\n    unique_seeds = []\n    seen_hashes = set()\n    for c in seed_centers_list:\n        h = tuple(np.round(c.ravel(), 3))\n        if h in seen_hashes:\n            c2 = np.clip(c + rng.normal(0, 0.005, size=c.shape), 0.0, 1.0)\n            unique_seeds.append(c2)\n        else:\n            unique_seeds.append(c)\n            seen_hashes.add(h)\n    seed_centers_list = unique_seeds\n\n    best_global_circles = None\n    best_global_score = -1e18\n\n    # Check whether we have linprog available for SLP; if not, use physics fallback\n    try:\n        from scipy.optimize import linprog  # noqa: F401\n        have_slp = True\n    except Exception:\n        have_slp = False\n\n    # Allocate time per seed adaptively\n    per_seed_time = max(0.2, time_left() / max(1, len(seed_centers_list)))\n\n    for centers0 in seed_centers_list:\n        if time_left() < 0.15:\n            break\n\n        circles0, score0 = feasible_from_centers(centers0)\n        if score0 > best_global_score:\n            best_global_score = score0\n            best_global_circles = circles0\n            all_scores.append(best_global_score)\n\n        t_seed_start = time.time()\n\n        def time_left_seed():\n            tl = time_left()\n            tl_seed = per_seed_time - (time.time() - t_seed_start)\n            return min(tl, tl_seed)\n\n        if have_slp:\n            centers_best, r_best, score_best, local_scores = slp_optimize(\n                centers0, time_left_seed\n            )\n        else:\n            centers_best, r_best, score_best, local_scores = physics_optimize(\n                centers0, time_left_seed\n            )\n\n        for s in local_scores:\n            if not all_scores or s > all_scores[-1] + 1e-9:\n                all_scores.append(s)\n\n        circles_seed = np.hstack([centers_best, r_best.reshape(-1, 1)])\n        centers_final = circles_seed[:, :2]\n        r_final, _ = solve_radii_lp(centers_final, r_min)\n        score_final = float(np.sum(r_final))\n        if score_final > best_global_score + 1e-9:\n            best_global_score = score_final\n            best_global_circles = np.hstack(\n                [centers_final, r_final.reshape(-1, 1)]\n            )\n            all_scores.append(best_global_score)\n\n    # Final safety fallback\n    if best_global_circles is None or not np.all(np.isfinite(best_global_circles)):\n        centers = init_edges()\n        r, _ = solve_radii_lp(centers, r_min)\n        best_global_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_global_score = float(np.sum(r))\n        all_scores.append(best_global_score)\n\n    # One more feasibility polish on best centers\n    try:\n        centers_final = best_global_circles[:, :2]\n        r_final, _ = solve_radii_lp(centers_final, r_min)\n        best_global_circles = np.hstack([centers_final, r_final.reshape(-1, 1)])\n        best_global_score = float(np.sum(r_final))\n    except Exception:\n        pass\n\n    return {\n        \"circles\": best_global_circles.astype(float),\n        \"all_scores\": [float(s) for s in all_scores] if all_scores else [best_global_score],\n    }",
    "refiner_score": 2.6299143763990855
}