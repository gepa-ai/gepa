{
    "best_score": 2.6058366847328935,
    "best_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    n = 26\n    start_time = time.time()\n    deadline = start_time + float(timeout)\n\n    rng = np.random.default_rng(1234567 + int((start_time * 1e6) % 1e6))\n\n    def compute_radii_lp(centers):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n        N = centers.shape[0]\n        # Distances to borders\n        b = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        # Build constraints: r_i <= b_i and r_i + r_j <= d_ij\n        rows = []\n        rhs = []\n        # r_i <= b_i\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            rows.append(row)\n            rhs.append(b[i])\n        # r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i+1, N):\n                dij = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(N)\n                row[i] = 1.0\n                row[j] = 1.0\n                rows.append(row)\n                rhs.append(max(dij - 1e-9, 0.0))\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        c = -np.ones(N, dtype=float)  # maximize sum r -> minimize -sum r\n        bounds = [(1e-9, None)] * N\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return compute_radii_fallback(centers), False\n            r = np.maximum(res.x, 1e-9)\n            r *= 0.999\n            return r, True\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n    def compute_radii_fallback(centers):\n        N = centers.shape[0]\n        r = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        r = np.maximum(r, 1e-4)\n        for _ in range(12):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dij = np.linalg.norm(centers[i] - centers[j])\n                    s = r[i] + r[j]\n                    if s > dij:\n                        if s <= 1e-12:\n                            continue\n                        scale = max(dij / s, 0.5)\n                        r[i] *= scale\n                        r[j] *= scale\n            r = np.minimum(r, np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]]))\n            r = np.maximum(r, 1e-6)\n        r *= 0.999\n        return r\n\n    def ensure_valid_centers(centers, eps=1e-3):\n        centers = np.clip(centers, eps, 1.0 - eps)\n        centers += (rng.random(centers.shape) - 0.5) * 1e-6\n        centers = np.clip(centers, eps, 1.0 - eps)\n        return centers\n\n    def generate_hex_seeds(n, rng):\n        seeds = []\n        d = np.sqrt(2.0 / (np.sqrt(3.0) * n)) * 0.95\n        dx = d\n        dy = np.sqrt(3.0) * d / 2.0\n        ys = []\n        y = dy * 0.6\n        while y < 1.0 - dy * 0.6:\n            ys.append(y)\n            y += dy\n        centers = []\n        for row, y in enumerate(ys):\n            offset = (0.0 if row % 2 == 0 else dx * 0.5)\n            x = dx * 0.6 + offset\n            row_pts = []\n            while x < 1.0 - dx * 0.6:\n                row_pts.append([x, y])\n                x += dx\n            centers.extend(row_pts)\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        if centers.shape[0] > n:\n            idxs = farthest_point_sampling(centers, n, rng)\n            centers = centers[idxs]\n        seeds.append(centers.copy())\n        for _ in range(3):\n            c = centers.copy()\n            c += (rng.random(c.shape) - 0.5) * (0.12 * d)\n            c = np.clip(c, 1e-3, 1.0 - 1e-3)\n            seeds.append(c)\n        return seeds\n\n    def generate_random_seeds(n, rng):\n        seeds = []\n        for _ in range(3):\n            centers = rng.random((n, 2)) * 0.9 + 0.05\n            seeds.append(centers)\n        return seeds\n\n    def generate_edge_corner_seeds(n, rng):\n        seeds = []\n        centers = []\n        corners = np.array([[0.08,0.08],[0.92,0.08],[0.08,0.92],[0.92,0.92]])\n        centers.extend(corners.tolist())\n        edge_points = []\n        for t in np.linspace(0.12, 0.88, 7):\n            edge_points.append([t, 0.06])\n            edge_points.append([t, 0.94])\n            edge_points.append([0.06, t])\n            edge_points.append([0.94, t])\n        rng.shuffle(edge_points)\n        centers.extend(edge_points[:max(0, n - len(centers))])\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] > n:\n            centers = centers[:n]\n        elif centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        seeds.append(centers)\n        return seeds\n\n    def farthest_point_sampling(points, k, rng):\n        npts = points.shape[0]\n        if k >= npts:\n            return np.arange(npts)\n        idxs = []\n        idx = int(rng.integers(0, npts))\n        idxs.append(idx)\n        d2 = np.full(npts, np.inf)\n        for _ in range(1, k):\n            p = points[idxs[-1]]\n            diff = points - p\n            dist2 = np.einsum('ij,ij->i', diff, diff)\n            d2 = np.minimum(d2, dist2)\n            idx = int(np.argmax(d2))\n            if idx in idxs:\n                idx = int(rng.integers(0, npts))\n            idxs.append(idx)\n        return np.array(idxs, dtype=int)\n\n    def dual_like_push(centers, r, step, rng):\n        nloc = centers.shape[0]\n        disp = np.zeros_like(centers)\n        x = centers[:,0]; y = centers[:,1]\n        sl = x - r\n        sr = (1.0 - x) - r\n        sb = y - r\n        st = (1.0 - y) - r\n        tol = 1e-6\n        for i in range(nloc):\n            dl = sl[i]; dr = sr[i]; db = sb[i]; dt = st[i]\n            wsum = 0.0\n            vx, vy = 0.0, 0.0\n            if dl < 0.01:\n                w = 1.0 / (dl + tol)\n                vx += w\n                wsum += w\n            if dr < 0.01:\n                w = 1.0 / (dr + tol)\n                vx -= w\n                wsum += w\n            if db < 0.01:\n                w = 1.0 / (db + tol)\n                vy += w\n                wsum += w\n            if dt < 0.01:\n                w = 1.0 / (dt + tol)\n                vy -= w\n                wsum += w\n            if wsum > 0:\n                disp[i,0] += (vx / wsum) * step\n                disp[i,1] += (vy / wsum) * step\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = np.linalg.norm(diff)\n                if dij < 1e-12:\n                    v = (rng.random(2) - 0.5)\n                    v /= max(np.linalg.norm(v), 1e-9)\n                    disp[i] -= step * 0.5 * v\n                    disp[j] += step * 0.5 * v\n                    continue\n                s = dij - (r[i] + r[j])\n                if s < 0.01:\n                    w = 1.0 / (s + tol)\n                    v = diff / dij\n                    disp[i] -= v * (0.5 * step * w / (1.0 + w))\n                    disp[j] += v * (0.5 * step * w / (1.0 + w))\n        norms = np.linalg.norm(disp, axis=1)\n        mask = norms > 0\n        if np.any(mask):\n            scale = np.minimum(1.0, (step / (norms[mask] + 1e-12)))\n            disp[mask] = disp[mask] * scale[:,None]\n        new_centers = centers + disp\n        new_centers = np.clip(new_centers, 1e-3, 1.0 - 1e-3)\n        return new_centers\n\n    def slp_step(centers, tau):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return None, None, None, False\n        nloc = centers.shape[0]\n        x = centers[:,0].copy()\n        y = centers[:,1].copy()\n        eps = 1e-3\n        varN = 3*nloc\n        rows = []\n        rhs = []\n        def add_row(coeffs, b):\n            rows.append(coeffs)\n            rhs.append(b)\n        for i in range(nloc):\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = -1.0\n            add_row(coeff, x[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = 1.0\n            add_row(coeff, 1.0 - x[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = -1.0\n            add_row(coeff, y[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = 1.0\n            add_row(coeff, 1.0 - y[i])\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = float(np.linalg.norm(diff))\n                if dij < 1e-9:\n                    vx, vy = 0.0, 0.0\n                    dij = 0.0\n                else:\n                    vx = diff[0] / dij\n                    vy = diff[1] / dij\n                coeff = np.zeros(varN)\n                coeff[2*nloc + i] = 1.0\n                coeff[2*nloc + j] = 1.0\n                coeff[j] += -vx\n                coeff[i] += vx\n                coeff[nloc + j] += -vy\n                coeff[nloc + i] += vy\n                add_row(coeff, dij - 1e-6)\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        c = np.zeros(varN, dtype=float)\n        c[2*nloc:] = -1.0\n        bounds = []\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, x[i] - eps)), float(np.minimum(tau, 1.0 - eps - x[i]))))\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, y[i] - eps)), float(np.minimum(tau, 1.0 - eps - y[i]))))\n        for i in range(nloc):\n            bounds.append((1e-9, None))\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return None, None, None, False\n            vec = res.x\n            dx = vec[0:nloc]\n            dy = vec[nloc:2*nloc]\n            r_lin = vec[2*nloc:]\n            return dx, dy, r_lin, True\n        except Exception:\n            return None, None, None, False\n\n    def slp_optimize(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        tau = 0.12\n        min_tau = 0.002\n        no_improve = 0\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and tau >= min_tau:\n            dx, dy, r_lin, ok = slp_step(centers, tau)\n            if not ok:\n                tau *= 0.6\n                no_improve += 1\n                if no_improve % 3 == 0:\n                    centers = centers + (rng.random(centers.shape) - 0.5) * (2.0 * tau)\n                    centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                    r, ok2 = compute_radii_lp(centers)\n                    if ok2 and np.sum(r) > best_s - 1e-6:\n                        best_s = float(np.sum(r))\n                        best_centers = centers.copy()\n                        best_r = r.copy()\n                continue\n            cand = centers.copy()\n            cand[:,0] += dx\n            cand[:,1] += dy\n            cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n            r_exact, ok2 = compute_radii_lp(cand)\n            if not ok2:\n                tau *= 0.65\n                no_improve += 1\n            else:\n                s_new = float(np.sum(r_exact))\n                if s_new > best_s + 1e-9:\n                    centers = cand\n                    r = r_exact\n                    best_s = s_new\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    tau *= 1.25\n                    no_improve = 0\n                else:\n                    tau *= 0.82\n                    no_improve += 1\n                    if no_improve % 2 == 0:\n                        pushed = dual_like_push(centers, r, tau*0.6, rng)\n                        r_push, ok3 = compute_radii_lp(pushed)\n                        if ok3:\n                            s_push = float(np.sum(r_push))\n                            if s_push > best_s - 1e-7:\n                                centers = pushed\n                                r = r_push\n                                if s_push > best_s:\n                                    best_s = s_push\n                                    best_centers = centers.copy()\n                                    best_r = r.copy()\n            if no_improve >= 6:\n                centers = best_centers + (rng.random(best_centers.shape) - 0.5) * (2.0 * tau)\n                centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                r, ok2 = compute_radii_lp(centers)\n                if ok2 and np.sum(r) > best_s - 1e-6:\n                    best_s = float(np.sum(r))\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                no_improve = 0\n        return best_centers, best_r, best_s\n\n    def local_optimize_pattern(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        step = 0.1\n        min_step = 0.0015\n        dirs = []\n        for k in range(8):\n            ang = 2.0 * np.pi * k / 8\n            dirs.append(np.array([np.cos(ang), np.sin(ang)], dtype=float))\n        dirs = np.array(dirs)\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and step >= min_step:\n            improved = False\n            order = np.arange(centers.shape[0])\n            rng.shuffle(order)\n            for idx in order:\n                best_local = None\n                best_local_r = None\n                best_local_s = -1.0\n                rng.shuffle(dirs)\n                for d in dirs:\n                    cand = centers.copy()\n                    cand[idx] = cand[idx] + step * d\n                    cand[idx] = np.clip(cand[idx], 1e-3, 1.0 - 1e-3)\n                    r_cand, ok2 = compute_radii_lp(cand)\n                    if not ok2:\n                        continue\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_local_s + 1e-9:\n                        best_local_s = s_cand\n                        best_local = cand\n                        best_local_r = r_cand\n                    if time.time() > local_deadline - 0.005:\n                        break\n                if best_local is not None and best_local_s > best_s + 1e-9:\n                    centers = best_local\n                    r = best_local_r\n                    best_s = best_local_s\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    improved = True\n                if time.time() > local_deadline - 0.005:\n                    break\n            if not improved:\n                step *= 0.7\n                shake_count = max(1, int(centers.shape[0] * 0.18))\n                indices = rng.choice(centers.shape[0], shake_count, replace=False)\n                shake = (rng.random((shake_count, 2)) - 0.5) * (2.0 * step)\n                cand = centers.copy()\n                cand[indices] = cand[indices] + shake\n                cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n                r_cand, ok2 = compute_radii_lp(cand)\n                if ok2:\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_s - 2e-4:\n                        centers = cand\n                        r = r_cand\n                        if s_cand > best_s:\n                            best_s = s_cand\n                            best_centers = centers.copy()\n                            best_r = r.copy()\n        return best_centers, best_r, best_s\n\n    seeds = []\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        base_centers = current_best_solution[:, :2].copy()\n        base_centers = ensure_valid_centers(base_centers)\n        seeds.append(base_centers)\n        for _ in range(2):\n            c = base_centers + (rng.random(base_centers.shape) - 0.5) * 1e-3\n            c = ensure_valid_centers(c)\n            seeds.append(c)\n    seeds.extend(generate_hex_seeds(n, rng))\n    seeds.extend(generate_random_seeds(n, rng))\n    seeds.extend(generate_edge_corner_seeds(n, rng))\n\n    unique_seeds = []\n    seen = set()\n    for C in seeds:\n        key = tuple(np.round(C.flatten(), 3))\n        if key not in seen:\n            seen.add(key)\n            unique_seeds.append(C)\n\n    max_seeds = len(unique_seeds)\n    if timeout < 1.0:\n        max_seeds = min(max_seeds, 3)\n    elif timeout < 3.0:\n        max_seeds = min(max_seeds, 8)\n    elif timeout < 10.0:\n        max_seeds = min(max_seeds, 12)\n    best_circles = None\n    best_score = -1.0\n    all_scores = []\n\n    seed_idx = 0\n    while seed_idx < max_seeds and time.time() < deadline - 0.05:\n        time_left = max(0.0, deadline - time.time())\n        remaining = max_seeds - seed_idx\n        per_seed = max(0.4, time_left / remaining)\n        centers0 = ensure_valid_centers(unique_seeds[seed_idx])\n        slp_budget = per_seed * 0.7\n        pat_budget = per_seed * 0.3\n        c_slp, r_slp, s_slp = slp_optimize(centers0, slp_budget, rng, deadline)\n        c_pat, r_pat, s_pat = local_optimize_pattern(c_slp, pat_budget, rng, deadline)\n        if s_pat > best_score:\n            best_score = s_pat\n            best_circles = np.hstack([c_pat, r_pat.reshape(-1, 1)])\n        all_scores.append(best_score)\n        seed_idx += 1\n\n    if best_circles is None:\n        centers = np.clip(rng.random((n,2))*0.8 + 0.1, 1e-3, 1-1e-3)\n        r, _ = compute_radii_lp(centers)\n        best_circles = np.hstack([centers, r.reshape(-1,1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {'circles': best_circles, 'all_scores': all_scores}",
    "best_circles": [
        [
            0.4279982704418503,
            0.49082714743054184,
            0.1314313876407566
        ],
        [
            0.7744853206719818,
            0.4120276288314022,
            0.05229751273182027
        ],
        [
            0.6807654072229309,
            0.5735558554083876,
            0.1342636704755352
        ],
        [
            0.49636490455211735,
            0.7018059595437431,
            0.09012612726511537
        ],
        [
            0.2824355204919781,
            0.7005394064341821,
            0.12359307155087793
        ],
        [
            0.2245979485813819,
            0.5125261611516458,
            0.07291854412989315
        ],
        [
            0.2527114680948432,
            0.3462200246736329,
            0.09557843779886996
        ],
        [
            0.41654477488757125,
            0.27763647294626564,
            0.08185323090985791
        ],
        [
            0.621190941351857,
            0.3191592397823129,
            0.12675412443702308
        ],
        [
            0.9008714423706642,
            0.4955285979515658,
            0.09902942907170648
        ],
        [
            0.8882345428752926,
            0.7060446687942386,
            0.11165369166758271
        ],
        [
            0.9084042148939682,
            0.9084042148939682,
            0.0915041893209258
        ],
        [
            0.6770923701268721,
            0.8539651846358396,
            0.14588878054879625
        ],
        [
            0.4224252062989993,
            0.8889736497996705,
            0.11091532385012914
        ],
        [
            0.21972248632377084,
            0.9074814548086994,
            0.09242602664610935
        ],
        [
            0.06482920348852354,
            0.9351707965114765,
            0.06476437428503498
        ],
        [
            0.08796291180924466,
            0.7841391189667497,
            0.08787494889743541
        ],
        [
            0.09041363282519045,
            0.6057784102984994,
            0.09032321919236526
        ],
        [
            0.08797731777712665,
            0.42740309695747314,
            0.08788934045934953
        ],
        [
            0.09271132838126865,
            0.24677547566983277,
            0.09261861705288739
        ],
        [
            0.0773778529758596,
            0.0773778529758596,
            0.07730047512288374
        ],
        [
            0.27471854592287487,
            0.12582070039479384,
            0.12569487969439905
        ],
        [
            0.5100053390562755,
            0.10999661266175687,
            0.10988661604909511
        ],
        [
            0.729223332232667,
            0.10922174995048886,
            0.10911252820053838
        ],
        [
            0.9182313639825543,
            0.08176863601744568,
            0.08168686738142822
        ],
        [
            0.8814301598073301,
            0.27869902249657064,
            0.11845127035247725
        ]
    ],
    "code_candidate": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    n = 26\n    start_time = time.time()\n    deadline = start_time + float(timeout)\n\n    rng = np.random.default_rng(12345 + int((start_time * 1e6) % 1e6))\n\n    # Helper: compute radii via LP (SciPy Highs); fallback to conservative shrink if SciPy unavailable\n    def compute_radii_lp(centers):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n        N = centers.shape[0]\n        # Distances to borders\n        b = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        # Build constraints: r_i <= b_i and r_i + r_j <= d_ij\n        # A_ub x <= b_ub\n        rows = []\n        rhs = []\n        # r_i <= b_i\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            rows.append(row)\n            rhs.append(b[i])\n        # r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i+1, N):\n                dij = np.linalg.norm(centers[i] - centers[j])\n                # Avoid exact duplicates causing infeasibility by tiny epsilon slack\n                rows.append(_pair_row(N, i, j))\n                rhs.append(max(dij - 1e-9, 0.0))\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n\n        c = -np.ones(N, dtype=float)  # maximize sum r -> minimize -sum r\n        # Enforce strictly positive radii lower bound, very small to avoid infeasibility near touching pairs\n        bounds = [(1e-9, None)] * N\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return compute_radii_fallback(centers), False\n            r = np.maximum(res.x, 1e-9)\n            # shrink slightly to ensure numerical safety\n            r *= 0.999\n            return r, True\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n    def _pair_row(N, i, j):\n        row = np.zeros(N)\n        row[i] = 1.0\n        row[j] = 1.0\n        return row\n\n    # Fallback radii computation if LP solver unavailable: iterative projection (conservative)\n    def compute_radii_fallback(centers):\n        N = centers.shape[0]\n        r = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        r = np.maximum(r, 1e-4)\n        # Iteratively enforce pair constraints\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dij = np.linalg.norm(centers[i] - centers[j])\n                    s = r[i] + r[j]\n                    if s > dij:\n                        if s <= 1e-12:\n                            continue\n                        scale = max(dij / s, 0.5)\n                        r[i] *= scale\n                        r[j] *= scale\n            r = np.minimum(r, np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]]))\n            r = np.maximum(r, 1e-6)\n        r *= 0.999\n        return r\n\n    def score_radii(r):\n        return float(np.sum(r))\n\n    def ensure_valid_centers(centers, eps=1e-3):\n        centers = np.clip(centers, eps, 1.0 - eps)\n        # Tiny jitter to avoid identical centers\n        centers += (rng.random(centers.shape) - 0.5) * 1e-6\n        centers = np.clip(centers, eps, 1.0 - eps)\n        return centers\n\n    # Seeds\n    seeds = []\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        seeds.append(current_best_solution[:, :2].copy())\n\n    seeds.extend(generate_hex_seeds(n, rng))\n    seeds.extend(generate_random_seeds(n, rng))\n    seeds.extend(generate_edge_corner_seeds(n, rng))\n\n    # Deduplicate seeds\n    unique_seeds = []\n    seen = set()\n    for C in seeds:\n        key = tuple(np.round(C.flatten(), 3))\n        if key not in seen:\n            seen.add(key)\n            unique_seeds.append(C)\n\n    best_circles = None\n    best_score = -1.0\n    all_scores = []\n\n    # Optimization per seed\n    seed_idx = 0\n    while seed_idx < len(unique_seeds) and time.time() < deadline - 0.05:\n        time_left = max(0.0, deadline - time.time())\n        # Allocate dynamic time: give more to promising seeds, but ensure at least some time\n        budget = min(time_left, max(0.5, timeout / (len(unique_seeds) * 1.2)))\n        centers0 = ensure_valid_centers(unique_seeds[seed_idx])\n        centers_opt, r_opt, s_opt = local_optimize(centers0, budget, compute_radii_lp, rng, deadline)\n        if s_opt > best_score:\n            best_score = s_opt\n            best_circles = np.hstack([centers_opt, r_opt.reshape(-1,1)])\n            all_scores.append(best_score)\n        seed_idx += 1\n\n    if best_circles is None:\n        # Fallback trivial\n        centers = np.clip(rng.random((n,2))*0.8 + 0.1, 1e-3, 1-1e-3)\n        r, _ = compute_radii_lp(centers)\n        best_circles = np.hstack([centers, r.reshape(-1,1)])\n        best_score = score_radii(r)\n        all_scores.append(best_score)\n\n    return {'circles': best_circles, 'all_scores': all_scores}\n\n\ndef local_optimize(centers, budget, radii_solver, rng, global_deadline):\n    start = time.time()\n    deadline = min(start + budget, global_deadline)\n\n    centers = centers.copy()\n    centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n\n    r, ok = radii_solver(centers)\n    best_centers = centers.copy()\n    best_r = r.copy()\n    best_s = float(np.sum(r))\n\n    # Pattern search with adaptive step and occasional stochastic shakes\n    step = 0.15\n    min_step = 0.002\n    dir_count = 8\n    dirs = []\n    for k in range(dir_count):\n        ang = 2.0 * np.pi * k / dir_count\n        dirs.append(np.array([np.cos(ang), np.sin(ang)], dtype=float))\n    dirs = np.array(dirs)\n\n    no_improve_iters = 0\n    while time.time() < deadline - 0.01 and step >= min_step:\n        improved = False\n        order = np.arange(centers.shape[0])\n        rng.shuffle(order)\n\n        for idx in order:\n            # Try greedy improvement for this center along multiple directions\n            best_local = None\n            best_local_r = None\n            best_local_s = -1.0\n            rng.shuffle(dirs)\n            for d in dirs:\n                cand = centers.copy()\n                cand[idx] = cand[idx] + step * d\n                cand[idx] = np.clip(cand[idx], 1e-3, 1.0 - 1e-3)\n                r_cand, ok = radii_solver(cand)\n                if not ok:\n                    continue\n                s_cand = float(np.sum(r_cand))\n                if s_cand > best_local_s + 1e-9:\n                    best_local_s = s_cand\n                    best_local = cand\n                    best_local_r = r_cand\n                if time.time() > deadline - 0.005:\n                    break\n            if best_local is not None and best_local_s > best_s + 1e-9:\n                centers = best_local\n                r = best_local_r\n                best_s = best_local_s\n                best_centers = centers.copy()\n                best_r = r.copy()\n                improved = True\n            if time.time() > deadline - 0.005:\n                break\n\n        if not improved:\n            # Small random shake to escape local basin\n            no_improve_iters += 1\n            step *= 0.72\n            shake_count = max(1, int(centers.shape[0] * 0.15))\n            indices = rng.choice(centers.shape[0], shake_count, replace=False)\n            shake = (rng.random((shake_count, 2)) - 0.5) * (2.0 * step)\n            cand = centers.copy()\n            cand[indices] = cand[indices] + shake\n            cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n            r_cand, ok = radii_solver(cand)\n            if ok:\n                s_cand = float(np.sum(r_cand))\n                # Accept even if slightly worse to promote exploration\n                if s_cand > best_s - 1e-4:\n                    centers = cand\n                    r = r_cand\n                    if s_cand > best_s:\n                        best_s = s_cand\n                        best_centers = centers.copy()\n                        best_r = r.copy()\n                        no_improve_iters = 0\n        else:\n            no_improve_iters = 0\n\n        # Occasional \"constraint-push\" step to increase distances along tight constraints\n        if time.time() < deadline - 0.005:\n            centers = constraint_push_step(centers, r, step * 0.5, rng)\n            centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n            r_new, ok = radii_solver(centers)\n            if ok:\n                s_new = float(np.sum(r_new))\n                if s_new >= best_s - 1e-8:\n                    r = r_new\n                    if s_new > best_s:\n                        best_s = s_new\n                        best_centers = centers.copy()\n                        best_r = r.copy()\n                else:\n                    # revert if harmful\n                    centers = best_centers.copy()\n                    r = best_r.copy()\n\n    return best_centers, best_r, best_s\n\n\ndef constraint_push_step(centers, r, step, rng):\n    n = centers.shape[0]\n    disp = np.zeros_like(centers)\n\n    # Push from boundaries if tight\n    x = centers[:,0]; y = centers[:,1]\n    b = np.minimum.reduce([x, y, 1.0 - x, 1.0 - y])\n    tight = r >= b - 1e-6\n    if np.any(tight):\n        # For each tight center, push away from the closest wall\n        for i in np.where(tight)[0]:\n            # Compute gradient approximate from wall\n            dleft = x[i]\n            dright = 1.0 - x[i]\n            dbottom = y[i]\n            dtop = 1.0 - y[i]\n            m = min(dleft, dright, dbottom, dtop)\n            dx, dy = 0.0, 0.0\n            if abs(m - dleft) < 1e-9: dx += step\n            if abs(m - dright) < 1e-9: dx -= step\n            if abs(m - dbottom) < 1e-9: dy += step\n            if abs(m - dtop) < 1e-9: dy -= step\n            disp[i,0] += dx\n            disp[i,1] += dy\n\n    # Push apart pairs that are tight r_i + r_j ~ d_ij\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = centers[j] - centers[i]\n            dij = np.linalg.norm(diff)\n            if dij <= 1e-12:\n                # random tiny separation\n                v = (rng.random(2) - 0.5)\n                v /= max(np.linalg.norm(v), 1e-9)\n                disp[i] -= step * 0.5 * v\n                disp[j] += step * 0.5 * v\n                continue\n            if r[i] + r[j] > dij - 1e-6:\n                v = diff / dij\n                disp[i] -= v * (step * 0.5)\n                disp[j] += v * (step * 0.5)\n\n    # Normalize displacements to avoid too large steps\n    norms = np.linalg.norm(disp, axis=1)\n    mask = norms > 0\n    if np.any(mask):\n        scale = np.minimum(1.0, (step / (norms[mask] + 1e-12)))\n        disp[mask] = disp[mask] * scale[:,None]\n\n    new_centers = centers + disp\n    return new_centers\n\n\ndef generate_hex_seeds(n, rng):\n    seeds = []\n    # Estimate spacing for hex grid\n    d = np.sqrt(2.0 / (np.sqrt(3.0) * n))\n    dx = d\n    dy = np.sqrt(3.0) * d / 2.0\n    # Slightly reduce to fit comfortably\n    dx *= 0.95\n    dy *= 0.95\n    # Build grid\n    ys = []\n    y = dy * 0.6\n    while y < 1.0 - dy * 0.6:\n        ys.append(y)\n        y += dy\n    centers = []\n    for row, y in enumerate(ys):\n        offset = (0.0 if row % 2 == 0 else dx * 0.5)\n        x = dx * 0.6 + offset\n        row_pts = []\n        while x < 1.0 - dx * 0.6:\n            row_pts.append([x, y])\n            x += dx\n        centers.extend(row_pts)\n    centers = np.array(centers, dtype=float)\n    if centers.shape[0] < n:\n        # pad random if not enough\n        extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n        centers = np.vstack([centers, extra])\n    if centers.shape[0] > n:\n        # Select n via farthest point sampling for diversity\n        idxs = farthest_point_sampling(centers, n, rng)\n        centers = centers[idxs]\n    seeds.append(centers.copy())\n\n    # Additional jittered variants\n    for _ in range(2):\n        c = centers.copy()\n        c += (rng.random(c.shape) - 0.5) * (0.15 * d)\n        c = np.clip(c, 1e-3, 1.0 - 1e-3)\n        seeds.append(c)\n    return seeds\n\n\ndef generate_random_seeds(n, rng):\n    seeds = []\n    for _ in range(2):\n        centers = rng.random((n,2)) * 0.9 + 0.05\n        seeds.append(centers)\n    return seeds\n\n\ndef generate_edge_corner_seeds(n, rng):\n    seeds = []\n    centers = []\n    # Corners\n    corners = np.array([[0.1,0.1],[0.9,0.1],[0.1,0.9],[0.9,0.9]])\n    centers.extend(corners.tolist())\n    # Edge midpoints and around\n    edge_points = []\n    for t in np.linspace(0.15, 0.85, 6):\n        edge_points.append([t, 0.08])\n        edge_points.append([t, 0.92])\n        edge_points.append([0.08, t])\n        edge_points.append([0.92, t])\n    rng.shuffle(edge_points)\n    centers.extend(edge_points[:max(0, n - len(centers))])\n    centers = np.array(centers, dtype=float)\n    if centers.shape[0] > n:\n        centers = centers[:n]\n    elif centers.shape[0] < n:\n        extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n        centers = np.vstack([centers, extra])\n    seeds.append(centers)\n    return seeds\n\n\ndef farthest_point_sampling(points, k, rng):\n    n = points.shape[0]\n    if k >= n:\n        return np.arange(n)\n    idxs = []\n    # start from random point\n    idx = int(rng.integers(0, n))\n    idxs.append(idx)\n    d2 = np.full(n, np.inf)\n    for _ in range(1, k):\n        p = points[idxs[-1]]\n        diff = points - p\n        dist2 = np.einsum('ij,ij->i', diff, diff)\n        d2 = np.minimum(d2, dist2)\n        idx = int(np.argmax(d2))\n        if idx in idxs:\n            # fallback random\n            idx = int(rng.integers(0, n))\n        idxs.append(idx)\n    return np.array(idxs, dtype=int)",
    "code_score": 2.5536969410244823,
    "refiner_prompt": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    n = 26\n    start_time = time.time()\n    deadline = start_time + float(timeout)\n\n    rng = np.random.default_rng(1234567 + int((start_time * 1e6) % 1e6))\n\n    def compute_radii_lp(centers):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n        N = centers.shape[0]\n        # Distances to borders\n        b = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        # Build constraints: r_i <= b_i and r_i + r_j <= d_ij\n        rows = []\n        rhs = []\n        # r_i <= b_i\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            rows.append(row)\n            rhs.append(b[i])\n        # r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i+1, N):\n                dij = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(N)\n                row[i] = 1.0\n                row[j] = 1.0\n                rows.append(row)\n                rhs.append(max(dij - 1e-9, 0.0))\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        c = -np.ones(N, dtype=float)  # maximize sum r -> minimize -sum r\n        bounds = [(1e-9, None)] * N\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return compute_radii_fallback(centers), False\n            r = np.maximum(res.x, 1e-9)\n            r *= 0.999\n            return r, True\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n    def compute_radii_fallback(centers):\n        N = centers.shape[0]\n        r = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        r = np.maximum(r, 1e-4)\n        for _ in range(12):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dij = np.linalg.norm(centers[i] - centers[j])\n                    s = r[i] + r[j]\n                    if s > dij:\n                        if s <= 1e-12:\n                            continue\n                        scale = max(dij / s, 0.5)\n                        r[i] *= scale\n                        r[j] *= scale\n            r = np.minimum(r, np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]]))\n            r = np.maximum(r, 1e-6)\n        r *= 0.999\n        return r\n\n    def ensure_valid_centers(centers, eps=1e-3):\n        centers = np.clip(centers, eps, 1.0 - eps)\n        centers += (rng.random(centers.shape) - 0.5) * 1e-6\n        centers = np.clip(centers, eps, 1.0 - eps)\n        return centers\n\n    def generate_hex_seeds(n, rng):\n        seeds = []\n        d = np.sqrt(2.0 / (np.sqrt(3.0) * n)) * 0.95\n        dx = d\n        dy = np.sqrt(3.0) * d / 2.0\n        ys = []\n        y = dy * 0.6\n        while y < 1.0 - dy * 0.6:\n            ys.append(y)\n            y += dy\n        centers = []\n        for row, y in enumerate(ys):\n            offset = (0.0 if row % 2 == 0 else dx * 0.5)\n            x = dx * 0.6 + offset\n            row_pts = []\n            while x < 1.0 - dx * 0.6:\n                row_pts.append([x, y])\n                x += dx\n            centers.extend(row_pts)\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        if centers.shape[0] > n:\n            idxs = farthest_point_sampling(centers, n, rng)\n            centers = centers[idxs]\n        seeds.append(centers.copy())\n        for _ in range(3):\n            c = centers.copy()\n            c += (rng.random(c.shape) - 0.5) * (0.12 * d)\n            c = np.clip(c, 1e-3, 1.0 - 1e-3)\n            seeds.append(c)\n        return seeds\n\n    def generate_random_seeds(n, rng):\n        seeds = []\n        for _ in range(3):\n            centers = rng.random((n, 2)) * 0.9 + 0.05\n            seeds.append(centers)\n        return seeds\n\n    def generate_edge_corner_seeds(n, rng):\n        seeds = []\n        centers = []\n        corners = np.array([[0.08,0.08],[0.92,0.08],[0.08,0.92],[0.92,0.92]])\n        centers.extend(corners.tolist())\n        edge_points = []\n        for t in np.linspace(0.12, 0.88, 7):\n            edge_points.append([t, 0.06])\n            edge_points.append([t, 0.94])\n            edge_points.append([0.06, t])\n            edge_points.append([0.94, t])\n        rng.shuffle(edge_points)\n        centers.extend(edge_points[:max(0, n - len(centers))])\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] > n:\n            centers = centers[:n]\n        elif centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        seeds.append(centers)\n        return seeds\n\n    def farthest_point_sampling(points, k, rng):\n        npts = points.shape[0]\n        if k >= npts:\n            return np.arange(npts)\n        idxs = []\n        idx = int(rng.integers(0, npts))\n        idxs.append(idx)\n        d2 = np.full(npts, np.inf)\n        for _ in range(1, k):\n            p = points[idxs[-1]]\n            diff = points - p\n            dist2 = np.einsum('ij,ij->i', diff, diff)\n            d2 = np.minimum(d2, dist2)\n            idx = int(np.argmax(d2))\n            if idx in idxs:\n                idx = int(rng.integers(0, npts))\n            idxs.append(idx)\n        return np.array(idxs, dtype=int)\n\n    def dual_like_push(centers, r, step, rng):\n        nloc = centers.shape[0]\n        disp = np.zeros_like(centers)\n        x = centers[:,0]; y = centers[:,1]\n        # Boundary slacks\n        sl = x - r\n        sr = (1.0 - x) - r\n        sb = y - r\n        st = (1.0 - y) - r\n        # Push away inversely proportional to slack\n        tol = 1e-6\n        for i in range(nloc):\n            dl = sl[i]; dr = sr[i]; db = sb[i]; dt = st[i]\n            wsum = 0.0\n            vx, vy = 0.0, 0.0\n            if dl < 0.01:\n                w = 1.0 / (dl + tol)\n                vx += w\n                wsum += w\n            if dr < 0.01:\n                w = 1.0 / (dr + tol)\n                vx -= w\n                wsum += w\n            if db < 0.01:\n                w = 1.0 / (db + tol)\n                vy += w\n                wsum += w\n            if dt < 0.01:\n                w = 1.0 / (dt + tol)\n                vy -= w\n                wsum += w\n            if wsum > 0:\n                disp[i,0] += (vx / wsum) * step\n                disp[i,1] += (vy / wsum) * step\n        # Pair pushes\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = np.linalg.norm(diff)\n                if dij < 1e-12:\n                    v = (rng.random(2) - 0.5)\n                    v /= max(np.linalg.norm(v), 1e-9)\n                    disp[i] -= step * 0.5 * v\n                    disp[j] += step * 0.5 * v\n                    continue\n                s = dij - (r[i] + r[j])\n                if s < 0.01:\n                    w = 1.0 / (s + tol)\n                    v = diff / dij\n                    disp[i] -= v * (0.5 * step * w / (1.0 + w))\n                    disp[j] += v * (0.5 * step * w / (1.0 + w))\n        norms = np.linalg.norm(disp, axis=1)\n        mask = norms > 0\n        if np.any(mask):\n            scale = np.minimum(1.0, (step / (norms[mask] + 1e-12)))\n            disp[mask] = disp[mask] * scale[:,None]\n        new_centers = centers + disp\n        new_centers = np.clip(new_centers, 1e-3, 1.0 - 1e-3)\n        return new_centers\n\n    def slp_step(centers, tau):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return None, None, None, False\n        nloc = centers.shape[0]\n        x = centers[:,0].copy()\n        y = centers[:,1].copy()\n        eps = 1e-3\n        # variable order: [dx_0..dx_{n-1}, dy_0..dy_{n-1}, r_0..r_{n-1}]\n        varN = 3*nloc\n        rows = []\n        rhs = []\n        def add_row(coeffs, b):\n            rows.append(coeffs)\n            rhs.append(b)\n        # Boundary constraints: r <= x+dx, r <= 1-(x+dx), r <= y+dy, r <= 1-(y+dy)\n        for i in range(nloc):\n            coeff = np.zeros(varN)\n            # r_i - dx_i <= x_i - eps_r? we can keep eps safety by subtracting tiny amount\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = -1.0\n            add_row(coeff, x[i] - 0.0)\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = 1.0\n            add_row(coeff, 1.0 - x[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = -1.0\n            add_row(coeff, y[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = 1.0\n            add_row(coeff, 1.0 - y[i])\n        # Pairwise linearized constraints\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = float(np.linalg.norm(diff))\n                if dij < 1e-9:\n                    vx, vy = 0.0, 0.0\n                    dij = 0.0\n                else:\n                    vx = diff[0] / dij\n                    vy = diff[1] / dij\n                coeff = np.zeros(varN)\n                coeff[2*nloc + i] = 1.0\n                coeff[2*nloc + j] = 1.0\n                # - v_x * (dx_j - dx_i) - v_y * (dy_j - dy_i)\n                coeff[j] += -vx\n                coeff[i] += vx\n                coeff[nloc + j] += -vy\n                coeff[nloc + i] += vy\n                add_row(coeff, dij - 1e-6)\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        # Objective: maximize sum r -> minimize -sum r\n        c = np.zeros(varN, dtype=float)\n        c[2*nloc:] = -1.0\n        # Bounds for dx,dy trust-region and inside [eps,1-eps]\n        lb_dx = -np.minimum(tau, x - eps)\n        ub_dx = np.minimum(tau, 1.0 - eps - x)\n        lb_dy = -np.minimum(tau, y - eps)\n        ub_dy = np.minimum(tau, 1.0 - eps - y)\n        bounds = []\n        for i in range(nloc):\n            bounds.append((float(-lb_dx[i]) if False else float(-np.inf), float(np.inf)))  # placeholder\n        bounds = []\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, x[i] - eps)), float(np.minimum(tau, 1.0 - eps - x[i]))))\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, y[i] - eps)), float(np.minimum(tau, 1.0 - eps - y[i]))))\n        for i in range(nloc):\n            bounds.append((1e-9, None))\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return None, None, None, False\n            vec = res.x\n            dx = vec[0:nloc]\n            dy = vec[nloc:2*nloc]\n            r_lin = vec[2*nloc:]\n            return dx, dy, r_lin, True\n        except Exception:\n            return None, None, None, False\n\n    def slp_optimize(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        tau = 0.12\n        min_tau = 0.002\n        no_improve = 0\n        iter_count = 0\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and tau >= min_tau:\n            iter_count += 1\n            dx, dy, r_lin, ok = slp_step(centers, tau)\n            if not ok:\n                tau *= 0.6\n                no_improve += 1\n                # Small shake if stuck\n                if no_improve % 3 == 0:\n                    centers = centers + (rng.random(centers.shape) - 0.5) * (2.0 * tau)\n                    centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                    r, ok2 = compute_radii_lp(centers)\n                    if ok2 and np.sum(r) > best_s - 1e-6:\n                        best_s = float(np.sum(r))\n                        best_centers = centers.copy()\n                        best_r = r.copy()\n                continue\n            cand = centers.copy()\n            cand[:,0] += dx\n            cand[:,1] += dy\n            cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n            r_exact, ok2 = compute_radii_lp(cand)\n            if not ok2:\n                tau *= 0.65\n                no_improve += 1\n            else:\n                s_new = float(np.sum(r_exact))\n                if s_new > best_s + 1e-9:\n                    centers = cand\n                    r = r_exact\n                    best_s = s_new\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    tau *= 1.25\n                    no_improve = 0\n                else:\n                    # Try a dual-like push based on current r to escape\n                    tau *= 0.82\n                    no_improve += 1\n                    if no_improve % 2 == 0:\n                        pushed = dual_like_push(centers, r, tau*0.6, rng)\n                        r_push, ok3 = compute_radii_lp(pushed)\n                        if ok3:\n                            s_push = float(np.sum(r_push))\n                            if s_push > best_s - 1e-7:\n                                centers = pushed\n                                r = r_push\n                                if s_push > best_s:\n                                    best_s = s_push\n                                    best_centers = centers.copy()\n                                    best_r = r.copy()\n            if no_improve >= 6:\n                # Large random restart around best found so far\n                centers = best_centers + (rng.random(best_centers.shape) - 0.5) * (2.0 * tau)\n                centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                r, ok2 = compute_radii_lp(centers)\n                if ok2 and np.sum(r) > best_s - 1e-6:\n                    best_s = float(np.sum(r))\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                no_improve = 0\n        return best_centers, best_r, best_s\n\n    def local_optimize_pattern(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        step = 0.1\n        min_step = 0.0015\n        dirs = []\n        for k in range(8):\n            ang = 2.0 * np.pi * k / 8\n            dirs.append(np.array([np.cos(ang), np.sin(ang)], dtype=float))\n        dirs = np.array(dirs)\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and step >= min_step:\n            improved = False\n            order = np.arange(centers.shape[0])\n            rng.shuffle(order)\n            for idx in order:\n                best_local = None\n                best_local_r = None\n                best_local_s = -1.0\n                rng.shuffle(dirs)\n                for d in dirs:\n                    cand = centers.copy()\n                    cand[idx] = cand[idx] + step * d\n                    cand[idx] = np.clip(cand[idx], 1e-3, 1.0 - 1e-3)\n                    r_cand, ok2 = compute_radii_lp(cand)\n                    if not ok2:\n                        continue\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_local_s + 1e-9:\n                        best_local_s = s_cand\n                        best_local = cand\n                        best_local_r = r_cand\n                    if time.time() > local_deadline - 0.005:\n                        break\n                if best_local is not None and best_local_s > best_s + 1e-9:\n                    centers = best_local\n                    r = best_local_r\n                    best_s = best_local_s\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    improved = True\n                if time.time() > local_deadline - 0.005:\n                    break\n            if not improved:\n                step *= 0.7\n                shake_count = max(1, int(centers.shape[0] * 0.18))\n                indices = rng.choice(centers.shape[0], shake_count, replace=False)\n                shake = (rng.random((shake_count, 2)) - 0.5) * (2.0 * step)\n                cand = centers.copy()\n                cand[indices] = cand[indices] + shake\n                cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n                r_cand, ok2 = compute_radii_lp(cand)\n                if ok2:\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_s - 2e-4:\n                        centers = cand\n                        r = r_cand\n                        if s_cand > best_s:\n                            best_s = s_cand\n                            best_centers = centers.copy()\n                            best_r = r.copy()\n        return best_centers, best_r, best_s\n\n    # Construct seeds\n    seeds = []\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        base_centers = current_best_solution[:, :2].copy()\n        base_centers = ensure_valid_centers(base_centers)\n        seeds.append(base_centers)\n        for _ in range(2):\n            c = base_centers + (rng.random(base_centers.shape) - 0.5) * 1e-3\n            c = ensure_valid_centers(c)\n            seeds.append(c)\n    seeds.extend(generate_hex_seeds(n, rng))\n    seeds.extend(generate_random_seeds(n, rng))\n    seeds.extend(generate_edge_corner_seeds(n, rng))\n\n    # Deduplicate seeds\n    unique_seeds = []\n    seen = set()\n    for C in seeds:\n        key = tuple(np.round(C.flatten(), 3))\n        if key not in seen:\n            seen.add(key)\n            unique_seeds.append(C)\n\n    # Budget scheduling\n    max_seeds = len(unique_seeds)\n    if timeout < 1.0:\n        max_seeds = min(max_seeds, 3)\n    elif timeout < 3.0:\n        max_seeds = min(max_seeds, 8)\n    elif timeout < 10.0:\n        max_seeds = min(max_seeds, 12)\n    best_circles = None\n    best_score = -1.0\n    all_scores = []\n\n    seed_idx = 0\n    while seed_idx < max_seeds and time.time() < deadline - 0.05:\n        time_left = max(0.0, deadline - time.time())\n        remaining = max_seeds - seed_idx\n        per_seed = max(0.4, time_left / remaining)\n        centers0 = ensure_valid_centers(unique_seeds[seed_idx])\n        # Try SLP first; fallback to pattern if little time or scipy missing\n        slp_budget = per_seed * 0.7\n        pat_budget = per_seed * 0.3\n        c_slp, r_slp, s_slp = slp_optimize(centers0, slp_budget, rng, deadline)\n        c_pat, r_pat, s_pat = local_optimize_pattern(c_slp, pat_budget, rng, deadline)\n        if s_pat > best_score:\n            best_score = s_pat\n            best_circles = np.hstack([c_pat, r_pat.reshape(-1, 1)])\n        all_scores.append(best_score)\n        seed_idx += 1\n\n    if best_circles is None:\n        centers = np.clip(rng.random((n,2))*0.8 + 0.1, 1e-3, 1-1e-3)\n        r, _ = compute_radii_lp(centers)\n        best_circles = np.hstack([centers, r.reshape(-1,1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {'circles': best_circles, 'all_scores': all_scores}",
    "refiner_code": "import numpy as np\nimport time\n\ndef main(timeout, current_best_solution):\n    n = 26\n    start_time = time.time()\n    deadline = start_time + float(timeout)\n\n    rng = np.random.default_rng(1234567 + int((start_time * 1e6) % 1e6))\n\n    def compute_radii_lp(centers):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n        N = centers.shape[0]\n        # Distances to borders\n        b = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        # Build constraints: r_i <= b_i and r_i + r_j <= d_ij\n        rows = []\n        rhs = []\n        # r_i <= b_i\n        for i in range(N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            rows.append(row)\n            rhs.append(b[i])\n        # r_i + r_j <= d_ij\n        for i in range(N):\n            for j in range(i+1, N):\n                dij = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(N)\n                row[i] = 1.0\n                row[j] = 1.0\n                rows.append(row)\n                rhs.append(max(dij - 1e-9, 0.0))\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        c = -np.ones(N, dtype=float)  # maximize sum r -> minimize -sum r\n        bounds = [(1e-9, None)] * N\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return compute_radii_fallback(centers), False\n            r = np.maximum(res.x, 1e-9)\n            r *= 0.999\n            return r, True\n        except Exception:\n            return compute_radii_fallback(centers), False\n\n    def compute_radii_fallback(centers):\n        N = centers.shape[0]\n        r = np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]])\n        r = np.maximum(r, 1e-4)\n        for _ in range(12):\n            for i in range(N):\n                for j in range(i+1, N):\n                    dij = np.linalg.norm(centers[i] - centers[j])\n                    s = r[i] + r[j]\n                    if s > dij:\n                        if s <= 1e-12:\n                            continue\n                        scale = max(dij / s, 0.5)\n                        r[i] *= scale\n                        r[j] *= scale\n            r = np.minimum(r, np.minimum.reduce([centers[:,0], centers[:,1], 1.0 - centers[:,0], 1.0 - centers[:,1]]))\n            r = np.maximum(r, 1e-6)\n        r *= 0.999\n        return r\n\n    def ensure_valid_centers(centers, eps=1e-3):\n        centers = np.clip(centers, eps, 1.0 - eps)\n        centers += (rng.random(centers.shape) - 0.5) * 1e-6\n        centers = np.clip(centers, eps, 1.0 - eps)\n        return centers\n\n    def generate_hex_seeds(n, rng):\n        seeds = []\n        d = np.sqrt(2.0 / (np.sqrt(3.0) * n)) * 0.95\n        dx = d\n        dy = np.sqrt(3.0) * d / 2.0\n        ys = []\n        y = dy * 0.6\n        while y < 1.0 - dy * 0.6:\n            ys.append(y)\n            y += dy\n        centers = []\n        for row, y in enumerate(ys):\n            offset = (0.0 if row % 2 == 0 else dx * 0.5)\n            x = dx * 0.6 + offset\n            row_pts = []\n            while x < 1.0 - dx * 0.6:\n                row_pts.append([x, y])\n                x += dx\n            centers.extend(row_pts)\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        if centers.shape[0] > n:\n            idxs = farthest_point_sampling(centers, n, rng)\n            centers = centers[idxs]\n        seeds.append(centers.copy())\n        for _ in range(3):\n            c = centers.copy()\n            c += (rng.random(c.shape) - 0.5) * (0.12 * d)\n            c = np.clip(c, 1e-3, 1.0 - 1e-3)\n            seeds.append(c)\n        return seeds\n\n    def generate_random_seeds(n, rng):\n        seeds = []\n        for _ in range(3):\n            centers = rng.random((n, 2)) * 0.9 + 0.05\n            seeds.append(centers)\n        return seeds\n\n    def generate_edge_corner_seeds(n, rng):\n        seeds = []\n        centers = []\n        corners = np.array([[0.08,0.08],[0.92,0.08],[0.08,0.92],[0.92,0.92]])\n        centers.extend(corners.tolist())\n        edge_points = []\n        for t in np.linspace(0.12, 0.88, 7):\n            edge_points.append([t, 0.06])\n            edge_points.append([t, 0.94])\n            edge_points.append([0.06, t])\n            edge_points.append([0.94, t])\n        rng.shuffle(edge_points)\n        centers.extend(edge_points[:max(0, n - len(centers))])\n        centers = np.array(centers, dtype=float)\n        if centers.shape[0] > n:\n            centers = centers[:n]\n        elif centers.shape[0] < n:\n            extra = rng.random((n - centers.shape[0], 2)) * 0.8 + 0.1\n            centers = np.vstack([centers, extra])\n        seeds.append(centers)\n        return seeds\n\n    def farthest_point_sampling(points, k, rng):\n        npts = points.shape[0]\n        if k >= npts:\n            return np.arange(npts)\n        idxs = []\n        idx = int(rng.integers(0, npts))\n        idxs.append(idx)\n        d2 = np.full(npts, np.inf)\n        for _ in range(1, k):\n            p = points[idxs[-1]]\n            diff = points - p\n            dist2 = np.einsum('ij,ij->i', diff, diff)\n            d2 = np.minimum(d2, dist2)\n            idx = int(np.argmax(d2))\n            if idx in idxs:\n                idx = int(rng.integers(0, npts))\n            idxs.append(idx)\n        return np.array(idxs, dtype=int)\n\n    def dual_like_push(centers, r, step, rng):\n        nloc = centers.shape[0]\n        disp = np.zeros_like(centers)\n        x = centers[:,0]; y = centers[:,1]\n        sl = x - r\n        sr = (1.0 - x) - r\n        sb = y - r\n        st = (1.0 - y) - r\n        tol = 1e-6\n        for i in range(nloc):\n            dl = sl[i]; dr = sr[i]; db = sb[i]; dt = st[i]\n            wsum = 0.0\n            vx, vy = 0.0, 0.0\n            if dl < 0.01:\n                w = 1.0 / (dl + tol)\n                vx += w\n                wsum += w\n            if dr < 0.01:\n                w = 1.0 / (dr + tol)\n                vx -= w\n                wsum += w\n            if db < 0.01:\n                w = 1.0 / (db + tol)\n                vy += w\n                wsum += w\n            if dt < 0.01:\n                w = 1.0 / (dt + tol)\n                vy -= w\n                wsum += w\n            if wsum > 0:\n                disp[i,0] += (vx / wsum) * step\n                disp[i,1] += (vy / wsum) * step\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = np.linalg.norm(diff)\n                if dij < 1e-12:\n                    v = (rng.random(2) - 0.5)\n                    v /= max(np.linalg.norm(v), 1e-9)\n                    disp[i] -= step * 0.5 * v\n                    disp[j] += step * 0.5 * v\n                    continue\n                s = dij - (r[i] + r[j])\n                if s < 0.01:\n                    w = 1.0 / (s + tol)\n                    v = diff / dij\n                    disp[i] -= v * (0.5 * step * w / (1.0 + w))\n                    disp[j] += v * (0.5 * step * w / (1.0 + w))\n        norms = np.linalg.norm(disp, axis=1)\n        mask = norms > 0\n        if np.any(mask):\n            scale = np.minimum(1.0, (step / (norms[mask] + 1e-12)))\n            disp[mask] = disp[mask] * scale[:,None]\n        new_centers = centers + disp\n        new_centers = np.clip(new_centers, 1e-3, 1.0 - 1e-3)\n        return new_centers\n\n    def slp_step(centers, tau):\n        try:\n            from scipy.optimize import linprog\n        except Exception:\n            return None, None, None, False\n        nloc = centers.shape[0]\n        x = centers[:,0].copy()\n        y = centers[:,1].copy()\n        eps = 1e-3\n        varN = 3*nloc\n        rows = []\n        rhs = []\n        def add_row(coeffs, b):\n            rows.append(coeffs)\n            rhs.append(b)\n        for i in range(nloc):\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = -1.0\n            add_row(coeff, x[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[i] = 1.0\n            add_row(coeff, 1.0 - x[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = -1.0\n            add_row(coeff, y[i])\n            coeff = np.zeros(varN)\n            coeff[2*nloc + i] = 1.0\n            coeff[nloc + i] = 1.0\n            add_row(coeff, 1.0 - y[i])\n        for i in range(nloc):\n            for j in range(i+1, nloc):\n                diff = centers[j] - centers[i]\n                dij = float(np.linalg.norm(diff))\n                if dij < 1e-9:\n                    vx, vy = 0.0, 0.0\n                    dij = 0.0\n                else:\n                    vx = diff[0] / dij\n                    vy = diff[1] / dij\n                coeff = np.zeros(varN)\n                coeff[2*nloc + i] = 1.0\n                coeff[2*nloc + j] = 1.0\n                coeff[j] += -vx\n                coeff[i] += vx\n                coeff[nloc + j] += -vy\n                coeff[nloc + i] += vy\n                add_row(coeff, dij - 1e-6)\n        A_ub = np.array(rows, dtype=float)\n        b_ub = np.array(rhs, dtype=float)\n        c = np.zeros(varN, dtype=float)\n        c[2*nloc:] = -1.0\n        bounds = []\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, x[i] - eps)), float(np.minimum(tau, 1.0 - eps - x[i]))))\n        for i in range(nloc):\n            bounds.append((float(-np.minimum(tau, y[i] - eps)), float(np.minimum(tau, 1.0 - eps - y[i]))))\n        for i in range(nloc):\n            bounds.append((1e-9, None))\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success or res.x is None:\n                return None, None, None, False\n            vec = res.x\n            dx = vec[0:nloc]\n            dy = vec[nloc:2*nloc]\n            r_lin = vec[2*nloc:]\n            return dx, dy, r_lin, True\n        except Exception:\n            return None, None, None, False\n\n    def slp_optimize(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        tau = 0.12\n        min_tau = 0.002\n        no_improve = 0\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and tau >= min_tau:\n            dx, dy, r_lin, ok = slp_step(centers, tau)\n            if not ok:\n                tau *= 0.6\n                no_improve += 1\n                if no_improve % 3 == 0:\n                    centers = centers + (rng.random(centers.shape) - 0.5) * (2.0 * tau)\n                    centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                    r, ok2 = compute_radii_lp(centers)\n                    if ok2 and np.sum(r) > best_s - 1e-6:\n                        best_s = float(np.sum(r))\n                        best_centers = centers.copy()\n                        best_r = r.copy()\n                continue\n            cand = centers.copy()\n            cand[:,0] += dx\n            cand[:,1] += dy\n            cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n            r_exact, ok2 = compute_radii_lp(cand)\n            if not ok2:\n                tau *= 0.65\n                no_improve += 1\n            else:\n                s_new = float(np.sum(r_exact))\n                if s_new > best_s + 1e-9:\n                    centers = cand\n                    r = r_exact\n                    best_s = s_new\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    tau *= 1.25\n                    no_improve = 0\n                else:\n                    tau *= 0.82\n                    no_improve += 1\n                    if no_improve % 2 == 0:\n                        pushed = dual_like_push(centers, r, tau*0.6, rng)\n                        r_push, ok3 = compute_radii_lp(pushed)\n                        if ok3:\n                            s_push = float(np.sum(r_push))\n                            if s_push > best_s - 1e-7:\n                                centers = pushed\n                                r = r_push\n                                if s_push > best_s:\n                                    best_s = s_push\n                                    best_centers = centers.copy()\n                                    best_r = r.copy()\n            if no_improve >= 6:\n                centers = best_centers + (rng.random(best_centers.shape) - 0.5) * (2.0 * tau)\n                centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n                r, ok2 = compute_radii_lp(centers)\n                if ok2 and np.sum(r) > best_s - 1e-6:\n                    best_s = float(np.sum(r))\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                no_improve = 0\n        return best_centers, best_r, best_s\n\n    def local_optimize_pattern(centers, budget, rng, deadline):\n        centers = centers.copy()\n        centers = np.clip(centers, 1e-3, 1.0 - 1e-3)\n        r, ok = compute_radii_lp(centers)\n        if not ok:\n            r = compute_radii_fallback(centers)\n        best_centers = centers.copy()\n        best_r = r.copy()\n        best_s = float(np.sum(r))\n        step = 0.1\n        min_step = 0.0015\n        dirs = []\n        for k in range(8):\n            ang = 2.0 * np.pi * k / 8\n            dirs.append(np.array([np.cos(ang), np.sin(ang)], dtype=float))\n        dirs = np.array(dirs)\n        local_deadline = min(time.time() + budget, deadline)\n        while time.time() < local_deadline - 0.01 and step >= min_step:\n            improved = False\n            order = np.arange(centers.shape[0])\n            rng.shuffle(order)\n            for idx in order:\n                best_local = None\n                best_local_r = None\n                best_local_s = -1.0\n                rng.shuffle(dirs)\n                for d in dirs:\n                    cand = centers.copy()\n                    cand[idx] = cand[idx] + step * d\n                    cand[idx] = np.clip(cand[idx], 1e-3, 1.0 - 1e-3)\n                    r_cand, ok2 = compute_radii_lp(cand)\n                    if not ok2:\n                        continue\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_local_s + 1e-9:\n                        best_local_s = s_cand\n                        best_local = cand\n                        best_local_r = r_cand\n                    if time.time() > local_deadline - 0.005:\n                        break\n                if best_local is not None and best_local_s > best_s + 1e-9:\n                    centers = best_local\n                    r = best_local_r\n                    best_s = best_local_s\n                    best_centers = centers.copy()\n                    best_r = r.copy()\n                    improved = True\n                if time.time() > local_deadline - 0.005:\n                    break\n            if not improved:\n                step *= 0.7\n                shake_count = max(1, int(centers.shape[0] * 0.18))\n                indices = rng.choice(centers.shape[0], shake_count, replace=False)\n                shake = (rng.random((shake_count, 2)) - 0.5) * (2.0 * step)\n                cand = centers.copy()\n                cand[indices] = cand[indices] + shake\n                cand = np.clip(cand, 1e-3, 1.0 - 1e-3)\n                r_cand, ok2 = compute_radii_lp(cand)\n                if ok2:\n                    s_cand = float(np.sum(r_cand))\n                    if s_cand > best_s - 2e-4:\n                        centers = cand\n                        r = r_cand\n                        if s_cand > best_s:\n                            best_s = s_cand\n                            best_centers = centers.copy()\n                            best_r = r.copy()\n        return best_centers, best_r, best_s\n\n    seeds = []\n    if current_best_solution is not None and current_best_solution.shape[0] == n:\n        base_centers = current_best_solution[:, :2].copy()\n        base_centers = ensure_valid_centers(base_centers)\n        seeds.append(base_centers)\n        for _ in range(2):\n            c = base_centers + (rng.random(base_centers.shape) - 0.5) * 1e-3\n            c = ensure_valid_centers(c)\n            seeds.append(c)\n    seeds.extend(generate_hex_seeds(n, rng))\n    seeds.extend(generate_random_seeds(n, rng))\n    seeds.extend(generate_edge_corner_seeds(n, rng))\n\n    unique_seeds = []\n    seen = set()\n    for C in seeds:\n        key = tuple(np.round(C.flatten(), 3))\n        if key not in seen:\n            seen.add(key)\n            unique_seeds.append(C)\n\n    max_seeds = len(unique_seeds)\n    if timeout < 1.0:\n        max_seeds = min(max_seeds, 3)\n    elif timeout < 3.0:\n        max_seeds = min(max_seeds, 8)\n    elif timeout < 10.0:\n        max_seeds = min(max_seeds, 12)\n    best_circles = None\n    best_score = -1.0\n    all_scores = []\n\n    seed_idx = 0\n    while seed_idx < max_seeds and time.time() < deadline - 0.05:\n        time_left = max(0.0, deadline - time.time())\n        remaining = max_seeds - seed_idx\n        per_seed = max(0.4, time_left / remaining)\n        centers0 = ensure_valid_centers(unique_seeds[seed_idx])\n        slp_budget = per_seed * 0.7\n        pat_budget = per_seed * 0.3\n        c_slp, r_slp, s_slp = slp_optimize(centers0, slp_budget, rng, deadline)\n        c_pat, r_pat, s_pat = local_optimize_pattern(c_slp, pat_budget, rng, deadline)\n        if s_pat > best_score:\n            best_score = s_pat\n            best_circles = np.hstack([c_pat, r_pat.reshape(-1, 1)])\n        all_scores.append(best_score)\n        seed_idx += 1\n\n    if best_circles is None:\n        centers = np.clip(rng.random((n,2))*0.8 + 0.1, 1e-3, 1-1e-3)\n        r, _ = compute_radii_lp(centers)\n        best_circles = np.hstack([centers, r.reshape(-1,1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {'circles': best_circles, 'all_scores': all_scores}",
    "refiner_score": 2.6058366847328935
}