{
    "best_score": 2.608445134362756,
    "best_code": "import numpy as np\nimport time\n\ndef linprog_solve(c, A_ub=None, b_ub=None, bounds=None):\n    try:\n        from scipy.optimize import linprog\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n        return res\n    except Exception:\n        return None\n\ndef solve_radii_lp(centers, r_min=1e-8):\n    n = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n    # Border upper bounds\n    b = np.minimum.reduce([x, y, 1.0 - x, 1.0 - y])\n    b = np.maximum(b, r_min)  # ensure feasible lower bound doesn't exceed upper\n    # Objective: minimize -sum r_i\n    c = -np.ones(n)\n    # Constraints r_i + r_j <= d_ij\n    pairs_i = []\n    pairs_j = []\n    dists = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dij = np.linalg.norm(centers[i] - centers[j])\n            dists.append(dij)\n            pairs_i.append(i)\n            pairs_j.append(j)\n    m = len(dists)\n    if m > 0:\n        A_ub = np.zeros((m, n))\n        for k in range(m):\n            A_ub[k, pairs_i[k]] = 1.0\n            A_ub[k, pairs_j[k]] = 1.0\n        b_ub = np.array(dists)\n    else:\n        A_ub = None\n        b_ub = None\n    bounds = [(r_min, b[i]) for i in range(n)]\n    res = linprog_solve(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n    if res is not None and res.success and res.x is not None:\n        r = res.x\n        return np.maximum(r, r_min), True\n    # Fallback heuristic if LP unavailable or failed\n    r = b.copy()\n    # iterative pairwise projection\n    for _ in range(2000):\n        viol_sum = 0.0\n        for k in range(m):\n            i = pairs_i[k]\n            j = pairs_j[k]\n            s = (r[i] + r[j]) - dists[k]\n            if s > 1e-12:\n                # shrink proportionally\n                denom = r[i] + r[j] + 1e-12\n                di = r[i] / denom\n                dj = r[j] / denom\n                r[i] = max(r_min, r[i] - s * di)\n                r[j] = max(r_min, r[j] - s * dj)\n                viol_sum += s\n        if viol_sum < 1e-10:\n            break\n    return np.maximum(r, r_min), False\n\ndef farthest_sampling(n, margin=0.02, n_candidates=1200, rng=None, include_center=False):\n    if rng is None:\n        rng = np.random.default_rng()\n    # Generate candidate points\n    cand = rng.random((n_candidates, 2))\n    cand = margin + (1.0 - 2 * margin) * cand\n    centers = []\n    if include_center:\n        centers.append(np.array([0.5, 0.5]))\n    else:\n        # seed with best candidate vs center\n        d = np.linalg.norm(cand - np.array([0.5, 0.5]), axis=1)\n        idx0 = np.argmax(d)\n        centers.append(cand[idx0])\n    used = np.zeros(n_candidates, dtype=bool)\n    if not include_center:\n        used[idx0] = True\n    for _ in range(n - 1):\n        # compute min dist to existing\n        arr_centers = np.array(centers)\n        diff = cand[:, None, :] - arr_centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=2)\n        min_dist = dist.min(axis=1)\n        min_dist[used] = -1.0\n        idx = np.argmax(min_dist)\n        centers.append(cand[idx])\n        used[idx] = True\n    return np.array(centers[:n])\n\ndef ring_initial(n, margin=0.02):\n    centers = []\n    centers.append([0.5, 0.5])\n    remaining = n - 1\n    if remaining <= 0:\n        return np.array(centers)\n    # two rings\n    radii = [0.25, 0.4]\n    idx = 0\n    for r in radii:\n        if remaining <= 0:\n            break\n        k = min(remaining, max(6, int(2 * np.pi * r * 10)))\n        for i in range(k):\n            ang = 2 * np.pi * i / k + (0 if idx % 2 == 0 else np.pi / k)\n            centers.append([0.5 + r * np.cos(ang), 0.5 + r * np.sin(ang)])\n            remaining -= 1\n            if remaining <= 0:\n                break\n        idx += 1\n    if remaining > 0:\n        # fill at corners-inward\n        corners = np.array([\n            [margin, margin],\n            [1 - margin, margin],\n            [margin, 1 - margin],\n            [1 - margin, 1 - margin],\n            [0.25, 0.25],\n            [0.75, 0.25],\n            [0.25, 0.75],\n            [0.75, 0.75],\n        ])\n        for i in range(min(remaining, len(corners))):\n            centers.append(corners[i].tolist())\n    return np.array(centers[:n])\n\ndef project_centers(centers, margin):\n    return np.clip(centers, margin, 1.0 - margin)\n\ndef compute_forces(centers, radii, pair_margin=0.01, border_margin=0.01):\n    n = centers.shape[0]\n    forces = np.zeros_like(centers)\n    # Pair forces for near-tight constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            delta = centers[j] - centers[i]\n            dist = np.linalg.norm(delta)\n            if dist < 1e-12:\n                # random small separation\n                direction = np.random.randn(2)\n                direction /= (np.linalg.norm(direction) + 1e-12)\n                f = 0.1 * direction\n                forces[i] -= f\n                forces[j] += f\n                continue\n            slack = dist - (radii[i] + radii[j])\n            if slack < pair_margin:\n                # push apart with strength inversely related to slack\n                direction = delta / dist\n                strength = (pair_margin - slack) / (pair_margin + 1e-12)\n                f = direction * strength\n                forces[i] -= f\n                forces[j] += f\n    # Border forces for near-tight border constraints\n    x = centers[:, 0]\n    y = centers[:, 1]\n    b_vals = np.vstack([x, y, 1.0 - x, 1.0 - y]).T\n    b_i = np.min(b_vals, axis=1)\n    slack_b = b_i - radii\n    # Determine active border and push inward\n    active = slack_b < border_margin\n    if np.any(active):\n        idxs = np.where(active)[0]\n        for idx in idxs:\n            vals = b_vals[idx]\n            which = np.argmin(vals)\n            push = np.zeros(2)\n            # 0:x,1:y,2:1-x,3:1-y\n            if which == 0:\n                push[0] = 1.0\n            elif which == 1:\n                push[1] = 1.0\n            elif which == 2:\n                push[0] = -1.0\n            else:\n                push[1] = -1.0\n            strength = (border_margin - slack_b[idx]) / (border_margin + 1e-12)\n            forces[idx] += push * strength * 0.5\n    # Mild attraction to center to avoid drifting to borders\n    forces += 0.01 * (np.array([0.5, 0.5]) - centers)\n    return forces\n\ndef optimize_centers(centers, time_budget, r_min=1e-8, rng=None):\n    start = time.time()\n    if rng is None:\n        rng = np.random.default_rng()\n    centers = centers.copy()\n    # Keep centers within open square margins\n    margin = 5e-4\n    centers = project_centers(centers, margin)\n    v = np.zeros_like(centers)\n    best_centers = centers.copy()\n    best_r, _ = solve_radii_lp(best_centers, r_min=r_min)\n    best_score = float(np.sum(best_r))\n    step = 0.08\n    decay = 0.995\n    for it in range(6000):\n        if time.time() - start > time_budget:\n            break\n        # Solve optimal radii for current centers\n        r, _ = solve_radii_lp(centers, r_min=r_min)\n        score = float(np.sum(r))\n        if score > best_score + 1e-12:\n            best_score = score\n            best_centers = centers.copy()\n        # Forces based on active/tight constraints\n        forces = compute_forces(centers, r, pair_margin=0.01, border_margin=0.01)\n        # Normalize forces to control step size\n        norm = np.linalg.norm(forces) / (centers.shape[0] + 1e-12)\n        if norm > 0:\n            forces = forces / (norm + 1e-12)\n        # Momentum update\n        v = 0.85 * v + step * forces\n        centers = centers + v\n        # Keep inside bounds\n        centers = project_centers(centers, margin)\n        # Occasional small random shake if stagnating\n        if it % 80 == 79:\n            centers += rng.normal(scale=0.002, size=centers.shape)\n            centers = project_centers(centers, margin)\n        step = max(step * decay, 1e-4)\n    # Final LP on best centers found during search\n    r_final, _ = solve_radii_lp(best_centers, r_min=r_min)\n    return best_centers, r_final, best_score\n\ndef build_initial_centers_set(n, rng):\n    inits = []\n    # Farthest sampling with and without center anchor\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=False))\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=True))\n    # Ring-based layout\n    inits.append(ring_initial(n, margin=0.02))\n    # Random uniform\n    inits.append(0.02 + (1 - 0.04) * rng.random((n, 2)))\n    # Jittered grid\n    g = int(np.ceil(np.sqrt(n)))\n    xs = np.linspace(0.1, 0.9, g)\n    ys = np.linspace(0.1, 0.9, g)\n    grid = np.array([[xi, yi] for xi in xs for yi in ys])\n    rng.shuffle(grid)\n    grid = grid[:n]\n    grid += rng.normal(scale=0.02, size=grid.shape)\n    grid = np.clip(grid, 0.02, 0.98)\n    inits.append(grid)\n    return inits\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization using LP-based radius computation\n    and multi-restart local search.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    start_time = time.time()\n    rng = np.random.default_rng()\n    n = 26\n    all_scores = []\n    r_min = 1e-8\n\n    best_circles = None\n    best_score = -np.inf\n\n    # If we have a current best solution, consider it as a starting point\n    if current_best_solution is not None and isinstance(current_best_solution, np.ndarray):\n        if current_best_solution.shape[0] == n and current_best_solution.shape[1] == 3:\n            centers = current_best_solution[:, :2]\n            centers = np.clip(centers, 1e-3, 1 - 1e-3)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            score = float(np.sum(r))\n            all_scores.append(score)\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # Prepare initial centers\n    inits = build_initial_centers_set(n, rng)\n    # Add a few additional farthest samplings for diversity\n    extra_restarts = 4\n    for _ in range(extra_restarts):\n        inits.append(\n            farthest_sampling(\n                n,\n                margin=0.01 + 0.01 * rng.random(),\n                n_candidates=1200,\n                rng=rng,\n                include_center=rng.random() < 0.5,\n            )\n        )\n\n    # Time allocation per restart\n    remaining_time = max(0.0, timeout - (time.time() - start_time))\n    if remaining_time <= 0:\n        if best_circles is None:\n            centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n            best_score = float(np.sum(r))\n            all_scores.append(best_score)\n        return {\"circles\": best_circles, \"all_scores\": all_scores}\n\n    num_restarts = len(inits) + extra_restarts\n    per_restart = remaining_time / max(num_restarts, 1)\n\n    # Run restarts from the initial set\n    for init_centers in inits:\n        if time.time() - start_time > timeout:\n            break\n        centers, r, _ = optimize_centers(\n            init_centers, time_budget=per_restart * 0.6, r_min=r_min, rng=rng\n        )\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # A few randomized extra restarts around best found\n    extras = extra_restarts\n    for _ in range(extras):\n        if time.time() - start_time > timeout:\n            break\n        if best_circles is None:\n            base = farthest_sampling(n, margin=0.02, n_candidates=1000, rng=rng)\n        else:\n            base = best_circles[:, :2].copy()\n        # jitter around best\n        base += rng.normal(scale=0.01, size=base.shape)\n        base = np.clip(base, 1e-3, 1 - 1e-3)\n        centers, r, _ = optimize_centers(\n            base, time_budget=per_restart * 0.6, r_min=r_min, rng=rng\n        )\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    if best_circles is None:\n        centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n        r, _ = solve_radii_lp(centers, r_min=r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {\"circles\": best_circles, \"all_scores\": all_scores}",
    "best_circles": [
        [
            0.4279982704418503,
            0.49082714743054184,
            0.13156295109134797
        ],
        [
            0.7744853206719818,
            0.4120276288314022,
            0.05234986309441467
        ],
        [
            0.6807654072229309,
            0.5735558554083876,
            0.13439806904407928
        ],
        [
            0.49636490455211735,
            0.7018059595437431,
            0.09021634410872409
        ],
        [
            0.2824355204919781,
            0.7005394064341821,
            0.12371678883921713
        ],
        [
            0.2245979485813819,
            0.5125261611516458,
            0.07299153616555873
        ],
        [
            0.2527114680948432,
            0.3462200246736329,
            0.09567411241078072
        ],
        [
            0.41654477488757125,
            0.27763647294626564,
            0.08193516657593383
        ],
        [
            0.621190941351857,
            0.3191592397823129,
            0.12688100594246557
        ],
        [
            0.9008714423706642,
            0.4955285979515658,
            0.09912855762933581
        ],
        [
            0.8882345428752926,
            0.7060446687942386,
            0.11176545712470742
        ],
        [
            0.9084042148939682,
            0.9084042148939682,
            0.09159578510603184
        ],
        [
            0.6770923701268721,
            0.8539651846358396,
            0.1460348153641604
        ],
        [
            0.4224252062989993,
            0.8889736497996705,
            0.11102635020032947
        ],
        [
            0.21972248632377084,
            0.9074814548086994,
            0.09251854519130065
        ],
        [
            0.06482920348852354,
            0.9351707965114765,
            0.0648292034885235
        ],
        [
            0.08796291180924466,
            0.7841391189667497,
            0.08796291180924466
        ],
        [
            0.09041363282519045,
            0.6057784102984994,
            0.09041363282519045
        ],
        [
            0.08797731777712665,
            0.42740309695747314,
            0.08797731777712665
        ],
        [
            0.09271132838126865,
            0.24677547566983277,
            0.09271132838126865
        ],
        [
            0.0773778529758596,
            0.0773778529758596,
            0.0773778529758596
        ],
        [
            0.27471854592287487,
            0.12582070039479384,
            0.12582070039479384
        ],
        [
            0.5100053390562755,
            0.10999661266175687,
            0.10999661266175687
        ],
        [
            0.729223332232667,
            0.10922174995048886,
            0.10922174995048886
        ],
        [
            0.9182313639825543,
            0.08176863601744568,
            0.08176863601744566
        ],
        [
            0.8814301598073301,
            0.27869902249657064,
            0.11856984019266992
        ]
    ],
    "code_candidate": "\nimport numpy as np\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    n = 26\n\n    # Use current_best_solution if provided, otherwise start fresh\n    if current_best_solution is not None:\n        circles = current_best_solution.copy()\n    else:\n        # Simple initial placement\n        centers = np.zeros((n, 2))\n\n        # Center circle\n        centers[0] = [0.5, 0.5]\n\n        # Ring of 8 around center\n        for i in range(min(8, n - 1)):\n            angle = 2 * np.pi * i / 8\n            centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n        # Outer ring for remaining\n        if n > 9:\n            remaining = n - 9\n            for i in range(remaining):\n                angle = 2 * np.pi * i / remaining\n                centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n        centers = np.clip(centers, 0.01, 0.99)\n        radii = compute_max_radii(centers)\n        circles = np.hstack([centers, radii.reshape(-1, 1)])\n\n    score = float(np.sum(circles[:, 2]))\n    return {'circles': circles, 'all_scores': [score]}\n\n\ndef compute_max_radii(centers):\n    \"\"\"Compute maximum radii that don't overlap and stay in unit square.\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # Limit by distance to borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n",
    "code_score": 0.9797642169962063,
    "refiner_prompt": "import numpy as np\nimport time\n\ndef linprog_solve(c, A_ub=None, b_ub=None, bounds=None):\n    try:\n        from scipy.optimize import linprog\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n        return res\n    except Exception:\n        return None\n\ndef solve_radii_lp(centers, r_min=1e-8):\n    n = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n    # Border upper bounds\n    b = np.minimum.reduce([x, y, 1.0 - x, 1.0 - y])\n    b = np.maximum(b, r_min)  # ensure feasible lower bound doesn't exceed upper\n    # Objective: minimize -sum r_i\n    c = -np.ones(n)\n    # Constraints r_i + r_j <= d_ij\n    pairs_i = []\n    pairs_j = []\n    dists = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dij = np.linalg.norm(centers[i] - centers[j])\n            dists.append(dij)\n            pairs_i.append(i)\n            pairs_j.append(j)\n    m = len(dists)\n    if m > 0:\n        A_ub = np.zeros((m, n))\n        for k in range(m):\n            A_ub[k, pairs_i[k]] = 1.0\n            A_ub[k, pairs_j[k]] = 1.0\n        b_ub = np.array(dists)\n    else:\n        A_ub = None\n        b_ub = None\n    bounds = [(r_min, b[i]) for i in range(n)]\n    res = linprog_solve(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n    if res is not None and res.success and res.x is not None:\n        r = res.x\n        return np.maximum(r, r_min), True\n    # Fallback heuristic if LP unavailable or failed\n    r = b.copy()\n    # iterative pairwise projection\n    for _ in range(2000):\n        viol_sum = 0.0\n        for k in range(m):\n            i = pairs_i[k]\n            j = pairs_j[k]\n            s = (r[i] + r[j]) - dists[k]\n            if s > 1e-12:\n                # shrink proportionally\n                di = r[i] / (r[i] + r[j] + 1e-12)\n                dj = r[j] / (r[i] + r[j] + 1e-12)\n                r[i] = max(r_min, r[i] - s * di)\n                r[j] = max(r_min, r[j] - s * dj)\n                viol_sum += s\n        if viol_sum < 1e-10:\n            break\n    return np.maximum(r, r_min), False\n\ndef farthest_sampling(n, margin=0.02, n_candidates=1200, rng=None, include_center=False):\n    if rng is None:\n        rng = np.random.default_rng()\n    # Generate candidate points\n    cand = rng.random((n_candidates, 2))\n    cand = margin + (1.0 - 2 * margin) * cand\n    centers = []\n    if include_center:\n        centers.append(np.array([0.5, 0.5]))\n    else:\n        # seed with best candidate vs center\n        d = np.linalg.norm(cand - np.array([0.5, 0.5]), axis=1)\n        centers.append(cand[np.argmax(d)])\n    used = np.zeros(n_candidates, dtype=bool)\n    if not include_center:\n        used[np.argmax(d)] = True\n    for _ in range(n - 1):\n        # compute min dist to existing\n        diff = cand[:, None, :] - np.array(centers)[None, :, :]\n        dist = np.linalg.norm(diff, axis=2)\n        min_dist = dist.min(axis=1)\n        min_dist[used] = -1.0\n        idx = np.argmax(min_dist)\n        centers.append(cand[idx])\n        used[idx] = True\n    return np.array(centers[:n])\n\ndef ring_initial(n, margin=0.02):\n    centers = []\n    centers.append([0.5, 0.5])\n    remaining = n - 1\n    if remaining <= 0:\n        return np.array(centers)\n    # two rings\n    radii = [0.25, 0.4]\n    idx = 0\n    for r in radii:\n        if remaining <= 0:\n            break\n        k = min(remaining, max(6, int(2 * np.pi * r * 10)))\n        for i in range(k):\n            ang = 2 * np.pi * i / k + (0 if idx % 2 == 0 else np.pi / k)\n            centers.append([0.5 + r * np.cos(ang), 0.5 + r * np.sin(ang)])\n            remaining -= 1\n            if remaining <= 0:\n                break\n        idx += 1\n    if remaining > 0:\n        # fill at corners-inward\n        corners = np.array([\n            [margin, margin],\n            [1 - margin, margin],\n            [margin, 1 - margin],\n            [1 - margin, 1 - margin],\n            [0.25, 0.25],\n            [0.75, 0.25],\n            [0.25, 0.75],\n            [0.75, 0.75],\n        ])\n        for i in range(min(remaining, len(corners))):\n            centers.append(corners[i].tolist())\n    return np.array(centers[:n])\n\ndef project_centers(centers, margin):\n    return np.clip(centers, margin, 1.0 - margin)\n\ndef compute_forces(centers, radii, pair_margin=0.01, border_margin=0.01):\n    n = centers.shape[0]\n    forces = np.zeros_like(centers)\n    # Pair forces for near-tight constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            delta = centers[j] - centers[i]\n            dist = np.linalg.norm(delta)\n            if dist < 1e-12:\n                # random small separation\n                direction = np.random.randn(2)\n                direction /= (np.linalg.norm(direction) + 1e-12)\n                f = 0.1 * direction\n                forces[i] -= f\n                forces[j] += f\n                continue\n            slack = dist - (radii[i] + radii[j])\n            if slack < pair_margin:\n                # push apart with strength inversely related to slack\n                direction = delta / dist\n                strength = (pair_margin - slack) / (pair_margin + 1e-12)\n                f = direction * strength\n                forces[i] -= f\n                forces[j] += f\n    # Border forces for near-tight border constraints\n    x = centers[:, 0]\n    y = centers[:, 1]\n    b_vals = np.vstack([x, y, 1.0 - x, 1.0 - y]).T\n    b_i = np.min(b_vals, axis=1)\n    slack_b = b_i - radii\n    # Determine active border and push inward\n    active = slack_b < border_margin\n    if np.any(active):\n        idxs = np.where(active)[0]\n        for idx in idxs:\n            vals = b_vals[idx]\n            which = np.argmin(vals)\n            push = np.zeros(2)\n            # 0:x,1:y,2:1-x,3:1-y\n            if which == 0:\n                push[0] = 1.0\n            elif which == 1:\n                push[1] = 1.0\n            elif which == 2:\n                push[0] = -1.0\n            else:\n                push[1] = -1.0\n            strength = (border_margin - slack_b[idx]) / (border_margin + 1e-12)\n            forces[idx] += push * strength * 0.5\n    # Mild attraction to center to avoid drifting to borders\n    forces += 0.01 * (np.array([0.5, 0.5]) - centers)\n    return forces\n\ndef optimize_centers(centers, time_budget, r_min=1e-8, rng=None):\n    start = time.time()\n    if rng is None:\n        rng = np.random.default_rng()\n    centers = centers.copy()\n    # Keep centers within open square margins\n    margin = 5e-4\n    centers = project_centers(centers, margin)\n    v = np.zeros_like(centers)\n    best_centers = centers.copy()\n    best_r, _ = solve_radii_lp(best_centers, r_min=r_min)\n    best_score = float(np.sum(best_r))\n    step = 0.08\n    decay = 0.995\n    for it in range(6000):\n        if time.time() - start > time_budget:\n            break\n        # Solve optimal radii for current centers\n        r, ok = solve_radii_lp(centers, r_min=r_min)\n        score = float(np.sum(r))\n        if score > best_score + 1e-12:\n            best_score = score\n            best_centers = centers.copy()\n        # Forces based on active/tight constraints\n        forces = compute_forces(centers, r, pair_margin=0.01, border_margin=0.01)\n        # Normalize forces to control step size\n        norm = np.linalg.norm(forces) / (centers.shape[0] + 1e-12)\n        if norm > 0:\n            forces = forces / (norm + 1e-12)\n        # Momentum update\n        v = 0.85 * v + step * forces\n        centers = centers + v\n        # Keep inside bounds\n        centers = project_centers(centers, margin)\n        # Occasional small random shake if stagnating\n        if it % 80 == 79:\n            centers += rng.normal(scale=0.002, size=centers.shape)\n            centers = project_centers(centers, margin)\n        step = max(step * decay, 1e-4)\n    # Final LP on best centers found during search\n    r_final, _ = solve_radii_lp(best_centers, r_min=r_min)\n    return best_centers, r_final, best_score\n\ndef build_initial_centers_set(n, rng):\n    inits = []\n    # Farthest sampling with and without center anchor\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=False))\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=True))\n    # Ring-based layout\n    inits.append(ring_initial(n, margin=0.02))\n    # Random uniform\n    inits.append(0.02 + (1 - 0.04) * rng.random((n, 2)))\n    # Jittered grid\n    g = int(np.ceil(np.sqrt(n)))\n    xs = np.linspace(0.1, 0.9, g)\n    ys = np.linspace(0.1, 0.9, g)\n    grid = np.array([[xi, yi] for xi in xs for yi in ys])\n    rng.shuffle(grid)\n    grid = grid[:n]\n    grid += rng.normal(scale=0.02, size=grid.shape)\n    grid = np.clip(grid, 0.02, 0.98)\n    inits.append(grid)\n    return inits\n\ndef main(timeout, current_best_solution):\n    start_time = time.time()\n    rng = np.random.default_rng()\n    n = 26\n    all_scores = []\n    r_min = 1e-8\n\n    best_circles = None\n    best_score = -np.inf\n\n    # If we have a current best solution, consider it as a starting point\n    if current_best_solution is not None and isinstance(current_best_solution, np.ndarray):\n        if current_best_solution.shape[0] == n and current_best_solution.shape[1] == 3:\n            centers = current_best_solution[:, :2]\n            centers = np.clip(centers, 1e-3, 1 - 1e-3)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            score = float(np.sum(r))\n            all_scores.append(score)\n            if score > best_score:\n                best_score = score\n                best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # Prepare initial centers\n    inits = build_initial_centers_set(n, rng)\n    # Add a few additional farthest samplings for diversity\n    for _ in range(4):\n        inits.append(farthest_sampling(n, margin=0.01 + 0.01 * rng.random(), n_candidates=1200, rng=rng, include_center=rng.random() < 0.5))\n\n    # Time allocation per restart\n    remaining_time = max(0.0, timeout - (time.time() - start_time))\n    if remaining_time <= 0:\n        if best_circles is None:\n            centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n            best_score = float(np.sum(r))\n            all_scores.append(best_score)\n        return {'circles': best_circles, 'all_scores': all_scores}\n\n    num_restarts = len(inits) + 4\n    per_restart = remaining_time / max(num_restarts, 1)\n\n    # Run restarts\n    for i, init_centers in enumerate(inits):\n        if time.time() - start_time > timeout:\n            break\n        centers, r, _ = optimize_centers(init_centers, time_budget=per_restart * 0.6, r_min=r_min, rng=rng)\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # A few randomized extra restarts around best found\n    extras = 4\n    for k in range(extras):\n        if time.time() - start_time > timeout:\n            break\n        if best_circles is None:\n            base = farthest_sampling(n, margin=0.02, n_candidates=1000, rng=rng)\n        else:\n            base = best_circles[:, :2].copy()\n        # jitter\n        base += rng.normal(scale=0.01, size=base.shape)\n        base = np.clip(base, 1e-3, 1 - 1e-3)\n        centers, r, _ = optimize_centers(base, time_budget=per_restart * 0.6, r_min=r_min, rng=rng)\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    if best_circles is None:\n        centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n        r, _ = solve_radii_lp(centers, r_min=r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {'circles': best_circles, 'all_scores': all_scores}",
    "refiner_code": "import numpy as np\nimport time\n\ndef linprog_solve(c, A_ub=None, b_ub=None, bounds=None):\n    try:\n        from scipy.optimize import linprog\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method=\"highs\")\n        return res\n    except Exception:\n        return None\n\ndef solve_radii_lp(centers, r_min=1e-8):\n    n = centers.shape[0]\n    x = centers[:, 0]\n    y = centers[:, 1]\n    # Border upper bounds\n    b = np.minimum.reduce([x, y, 1.0 - x, 1.0 - y])\n    b = np.maximum(b, r_min)  # ensure feasible lower bound doesn't exceed upper\n    # Objective: minimize -sum r_i\n    c = -np.ones(n)\n    # Constraints r_i + r_j <= d_ij\n    pairs_i = []\n    pairs_j = []\n    dists = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dij = np.linalg.norm(centers[i] - centers[j])\n            dists.append(dij)\n            pairs_i.append(i)\n            pairs_j.append(j)\n    m = len(dists)\n    if m > 0:\n        A_ub = np.zeros((m, n))\n        for k in range(m):\n            A_ub[k, pairs_i[k]] = 1.0\n            A_ub[k, pairs_j[k]] = 1.0\n        b_ub = np.array(dists)\n    else:\n        A_ub = None\n        b_ub = None\n    bounds = [(r_min, b[i]) for i in range(n)]\n    res = linprog_solve(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n    if res is not None and res.success and res.x is not None:\n        r = res.x\n        return np.maximum(r, r_min), True\n    # Fallback heuristic if LP unavailable or failed\n    r = b.copy()\n    # iterative pairwise projection\n    for _ in range(2000):\n        viol_sum = 0.0\n        for k in range(m):\n            i = pairs_i[k]\n            j = pairs_j[k]\n            s = (r[i] + r[j]) - dists[k]\n            if s > 1e-12:\n                # shrink proportionally\n                denom = r[i] + r[j] + 1e-12\n                di = r[i] / denom\n                dj = r[j] / denom\n                r[i] = max(r_min, r[i] - s * di)\n                r[j] = max(r_min, r[j] - s * dj)\n                viol_sum += s\n        if viol_sum < 1e-10:\n            break\n    return np.maximum(r, r_min), False\n\ndef farthest_sampling(n, margin=0.02, n_candidates=1200, rng=None, include_center=False):\n    if rng is None:\n        rng = np.random.default_rng()\n    # Generate candidate points\n    cand = rng.random((n_candidates, 2))\n    cand = margin + (1.0 - 2 * margin) * cand\n    centers = []\n    if include_center:\n        centers.append(np.array([0.5, 0.5]))\n    else:\n        # seed with best candidate vs center\n        d = np.linalg.norm(cand - np.array([0.5, 0.5]), axis=1)\n        idx0 = np.argmax(d)\n        centers.append(cand[idx0])\n    used = np.zeros(n_candidates, dtype=bool)\n    if not include_center:\n        used[idx0] = True\n    for _ in range(n - 1):\n        # compute min dist to existing\n        arr_centers = np.array(centers)\n        diff = cand[:, None, :] - arr_centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=2)\n        min_dist = dist.min(axis=1)\n        min_dist[used] = -1.0\n        idx = np.argmax(min_dist)\n        centers.append(cand[idx])\n        used[idx] = True\n    return np.array(centers[:n])\n\ndef ring_initial(n, margin=0.02):\n    centers = []\n    centers.append([0.5, 0.5])\n    remaining = n - 1\n    if remaining <= 0:\n        return np.array(centers)\n    # two rings\n    radii = [0.25, 0.4]\n    idx = 0\n    for r in radii:\n        if remaining <= 0:\n            break\n        k = min(remaining, max(6, int(2 * np.pi * r * 10)))\n        for i in range(k):\n            ang = 2 * np.pi * i / k + (0 if idx % 2 == 0 else np.pi / k)\n            centers.append([0.5 + r * np.cos(ang), 0.5 + r * np.sin(ang)])\n            remaining -= 1\n            if remaining <= 0:\n                break\n        idx += 1\n    if remaining > 0:\n        # fill at corners-inward\n        corners = np.array([\n            [margin, margin],\n            [1 - margin, margin],\n            [margin, 1 - margin],\n            [1 - margin, 1 - margin],\n            [0.25, 0.25],\n            [0.75, 0.25],\n            [0.25, 0.75],\n            [0.75, 0.75],\n        ])\n        for i in range(min(remaining, len(corners))):\n            centers.append(corners[i].tolist())\n    return np.array(centers[:n])\n\ndef project_centers(centers, margin):\n    return np.clip(centers, margin, 1.0 - margin)\n\ndef compute_forces(centers, radii, pair_margin=0.01, border_margin=0.01):\n    n = centers.shape[0]\n    forces = np.zeros_like(centers)\n    # Pair forces for near-tight constraints\n    for i in range(n):\n        for j in range(i + 1, n):\n            delta = centers[j] - centers[i]\n            dist = np.linalg.norm(delta)\n            if dist < 1e-12:\n                # random small separation\n                direction = np.random.randn(2)\n                direction /= (np.linalg.norm(direction) + 1e-12)\n                f = 0.1 * direction\n                forces[i] -= f\n                forces[j] += f\n                continue\n            slack = dist - (radii[i] + radii[j])\n            if slack < pair_margin:\n                # push apart with strength inversely related to slack\n                direction = delta / dist\n                strength = (pair_margin - slack) / (pair_margin + 1e-12)\n                f = direction * strength\n                forces[i] -= f\n                forces[j] += f\n    # Border forces for near-tight border constraints\n    x = centers[:, 0]\n    y = centers[:, 1]\n    b_vals = np.vstack([x, y, 1.0 - x, 1.0 - y]).T\n    b_i = np.min(b_vals, axis=1)\n    slack_b = b_i - radii\n    # Determine active border and push inward\n    active = slack_b < border_margin\n    if np.any(active):\n        idxs = np.where(active)[0]\n        for idx in idxs:\n            vals = b_vals[idx]\n            which = np.argmin(vals)\n            push = np.zeros(2)\n            # 0:x,1:y,2:1-x,3:1-y\n            if which == 0:\n                push[0] = 1.0\n            elif which == 1:\n                push[1] = 1.0\n            elif which == 2:\n                push[0] = -1.0\n            else:\n                push[1] = -1.0\n            strength = (border_margin - slack_b[idx]) / (border_margin + 1e-12)\n            forces[idx] += push * strength * 0.5\n    # Mild attraction to center to avoid drifting to borders\n    forces += 0.01 * (np.array([0.5, 0.5]) - centers)\n    return forces\n\ndef optimize_centers(centers, time_budget, r_min=1e-8, rng=None):\n    start = time.time()\n    if rng is None:\n        rng = np.random.default_rng()\n    centers = centers.copy()\n    # Keep centers within open square margins\n    margin = 5e-4\n    centers = project_centers(centers, margin)\n    v = np.zeros_like(centers)\n    best_centers = centers.copy()\n    best_r, _ = solve_radii_lp(best_centers, r_min=r_min)\n    best_score = float(np.sum(best_r))\n    step = 0.08\n    decay = 0.995\n    for it in range(6000):\n        if time.time() - start > time_budget:\n            break\n        # Solve optimal radii for current centers\n        r, _ = solve_radii_lp(centers, r_min=r_min)\n        score = float(np.sum(r))\n        if score > best_score + 1e-12:\n            best_score = score\n            best_centers = centers.copy()\n        # Forces based on active/tight constraints\n        forces = compute_forces(centers, r, pair_margin=0.01, border_margin=0.01)\n        # Normalize forces to control step size\n        norm = np.linalg.norm(forces) / (centers.shape[0] + 1e-12)\n        if norm > 0:\n            forces = forces / (norm + 1e-12)\n        # Momentum update\n        v = 0.85 * v + step * forces\n        centers = centers + v\n        # Keep inside bounds\n        centers = project_centers(centers, margin)\n        # Occasional small random shake if stagnating\n        if it % 80 == 79:\n            centers += rng.normal(scale=0.002, size=centers.shape)\n            centers = project_centers(centers, margin)\n        step = max(step * decay, 1e-4)\n    # Final LP on best centers found during search\n    r_final, _ = solve_radii_lp(best_centers, r_min=r_min)\n    return best_centers, r_final, best_score\n\ndef build_initial_centers_set(n, rng):\n    inits = []\n    # Farthest sampling with and without center anchor\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=False))\n    inits.append(farthest_sampling(n, margin=0.02, n_candidates=1500, rng=rng, include_center=True))\n    # Ring-based layout\n    inits.append(ring_initial(n, margin=0.02))\n    # Random uniform\n    inits.append(0.02 + (1 - 0.04) * rng.random((n, 2)))\n    # Jittered grid\n    g = int(np.ceil(np.sqrt(n)))\n    xs = np.linspace(0.1, 0.9, g)\n    ys = np.linspace(0.1, 0.9, g)\n    grid = np.array([[xi, yi] for xi in xs for yi in ys])\n    rng.shuffle(grid)\n    grid = grid[:n]\n    grid += rng.normal(scale=0.02, size=grid.shape)\n    grid = np.clip(grid, 0.02, 0.98)\n    inits.append(grid)\n    return inits\n\ndef main(timeout, current_best_solution):\n    \"\"\"\n    Circle packing optimization using LP-based radius computation\n    and multi-restart local search.\n\n    Args:\n        timeout: Time budget in seconds\n        current_best_solution: Previous best circles array (n, 3) or None\n\n    Returns:\n        dict with 'circles' (n, 3) array and 'all_scores' list\n    \"\"\"\n    start_time = time.time()\n    rng = np.random.default_rng()\n    n = 26\n    all_scores = []\n    r_min = 1e-8\n\n    best_circles = None\n    best_score = -np.inf\n\n    # If we have a current best solution, consider it as a starting point\n    if current_best_solution is not None and isinstance(current_best_solution, np.ndarray):\n        if current_best_solution.shape[0] == n and current_best_solution.shape[1] == 3:\n            centers = current_best_solution[:, :2]\n            centers = np.clip(centers, 1e-3, 1 - 1e-3)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            score = float(np.sum(r))\n            all_scores.append(score)\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # Prepare initial centers\n    inits = build_initial_centers_set(n, rng)\n    # Add a few additional farthest samplings for diversity\n    extra_restarts = 4\n    for _ in range(extra_restarts):\n        inits.append(\n            farthest_sampling(\n                n,\n                margin=0.01 + 0.01 * rng.random(),\n                n_candidates=1200,\n                rng=rng,\n                include_center=rng.random() < 0.5,\n            )\n        )\n\n    # Time allocation per restart\n    remaining_time = max(0.0, timeout - (time.time() - start_time))\n    if remaining_time <= 0:\n        if best_circles is None:\n            centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n            r, _ = solve_radii_lp(centers, r_min=r_min)\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n            best_score = float(np.sum(r))\n            all_scores.append(best_score)\n        return {\"circles\": best_circles, \"all_scores\": all_scores}\n\n    num_restarts = len(inits) + extra_restarts\n    per_restart = remaining_time / max(num_restarts, 1)\n\n    # Run restarts from the initial set\n    for init_centers in inits:\n        if time.time() - start_time > timeout:\n            break\n        centers, r, _ = optimize_centers(\n            init_centers, time_budget=per_restart * 0.6, r_min=r_min, rng=rng\n        )\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    # A few randomized extra restarts around best found\n    extras = extra_restarts\n    for _ in range(extras):\n        if time.time() - start_time > timeout:\n            break\n        if best_circles is None:\n            base = farthest_sampling(n, margin=0.02, n_candidates=1000, rng=rng)\n        else:\n            base = best_circles[:, :2].copy()\n        # jitter around best\n        base += rng.normal(scale=0.01, size=base.shape)\n        base = np.clip(base, 1e-3, 1 - 1e-3)\n        centers, r, _ = optimize_centers(\n            base, time_budget=per_restart * 0.6, r_min=r_min, rng=rng\n        )\n        score = float(np.sum(r))\n        all_scores.append(score)\n        if score > best_score:\n            best_score = score\n            best_circles = np.hstack([centers, r.reshape(-1, 1)])\n\n    if best_circles is None:\n        centers = farthest_sampling(n, margin=0.02, n_candidates=1200, rng=rng)\n        r, _ = solve_radii_lp(centers, r_min=r_min)\n        best_circles = np.hstack([centers, r.reshape(-1, 1)])\n        best_score = float(np.sum(r))\n        all_scores.append(best_score)\n\n    return {\"circles\": best_circles, \"all_scores\": all_scores}",
    "refiner_score": 2.608445134362756
}