<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TurboGEPA Evolution - Live</title>
  <script src="https://unpkg.com/cytoscape@3.28.1/dist/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.8.5/dist/dagre.min.js"></script>
  <script src="https://unpkg.com/cytoscape-dagre@2.5.0/cytoscape-dagre.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #0a0e1a;
      color: #e4e9f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #141820;
      padding: 1rem 1.5rem;
      border-bottom: 1px solid #2a3040;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .header-left {
      display: flex;
      gap: 1rem;
      align-items: center;
    }

    .title {
      font-size: 1.25rem;
      font-weight: 600;
      color: #fff;
    }

    .status {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
      color: #8b95a8;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #10b981;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .controls {
      display: flex;
      gap: 0.5rem;
    }

    button {
      padding: 0.5rem 1rem;
      background: #1f2937;
      color: #e4e9f0;
      border: 1px solid #374151;
      border-radius: 0.375rem;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }

    button:hover {
      background: #374151;
      border-color: #4b5563;
    }

    .container {
      display: grid;
      grid-template-columns: 1fr 400px;
      gap: 1rem;
      padding: 1rem;
      height: calc(100vh - 70px);
    }

    .left-column {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .graph-container {
      background: #141820;
      border-radius: 0.5rem;
      border: 1px solid #2a3040;
      overflow: hidden;
      position: relative;
      flex: 1;
      min-height: 0;
    }

    #cy {
      width: 100%;
      height: 100%;
    }

    .chart-container {
      background: #141820;
      border-radius: 0.5rem;
      border: 1px solid #2a3040;
      padding: 1rem;
      height: 400px;
      position: relative;
    }

    .chart-wrapper {
      position: relative;
      height: 360px;
      width: 100%;
    }

    #qualityChart {
      width: 100% !important;
      height: 100% !important;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      overflow-y: auto;
    }

    .card {
      background: #141820;
      border: 1px solid #2a3040;
      border-radius: 0.5rem;
      padding: 1rem;
    }

    .card-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: #8b95a8;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.75rem;
    }

    .legend {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.875rem;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 0.25rem;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.75rem;
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .stat-label {
      font-size: 0.75rem;
      color: #8b95a8;
    }

    .stat-value {
      font-size: 1.25rem;
      font-weight: 600;
      color: #fff;
    }

    .details {
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .detail-row {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .detail-label {
      font-size: 0.75rem;
      color: #8b95a8;
    }

    .detail-value {
      font-size: 0.875rem;
      color: #e4e9f0;
      font-family: 'Courier New', monospace;
    }

    .prompt-text {
      background: #0a0e1a;
      border: 1px solid #2a3040;
      border-radius: 0.375rem;
      padding: 0.75rem;
      font-size: 0.8125rem;
      line-height: 1.5;
      color: #d1d5db;
      max-height: 300px;
      overflow-y: auto;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .empty-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #6b7280;
      text-align: center;
      padding: 2rem;
    }

    .empty-state svg {
      width: 64px;
      height: 64px;
      margin-bottom: 1rem;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <div class="title">TurboGEPA Evolution</div>
      <div class="status">
        <div class="status-dot"></div>
        <span id="statusText">Connecting...</span>
      </div>
    </div>
    <div class="controls">
      <button onclick="refreshData()">Refresh</button>
      <button onclick="fitGraph()">Fit</button>
    </div>
  </header>

  <div class="container">
    <div class="left-column">
      <div class="graph-container">
        <div id="cy"></div>
      </div>

      <div class="chart-container">
        <div class="card-title">Quality Over Iterations <span id="chartDebug" style="font-size: 10px; color: #6b7280; font-weight: normal;"></span></div>
        <div class="chart-wrapper">
          <canvas id="qualityChart"></canvas>
        </div>
      </div>
    </div>

    <div class="sidebar">
      <div class="card">
        <div class="card-title">Legend</div>
        <div class="legend">
          <div class="legend-item">
            <div class="legend-color" style="background: #10b981;"></div>
            <span>Promoted (completed evaluation)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #f59e0b;"></div>
            <span>In Flight (evaluating)</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background: #6366f1;"></div>
            <span>Other (queued/pending)</span>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Islands</div>
        <div id="islandLegend" class="legend"></div>
      </div>

      <div class="card">
        <div class="card-title">Statistics</div>
        <div class="stats">
          <div class="stat">
            <div class="stat-label">Nodes</div>
            <div class="stat-value" id="nodeCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Edges</div>
            <div class="stat-value" id="edgeCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Evaluations</div>
            <div class="stat-value" id="evalCount">0</div>
          </div>
          <div class="stat">
            <div class="stat-label">Best Quality</div>
            <div class="stat-value" id="bestQuality">-</div>
          </div>
        </div>
      </div>

      <div class="card">
        <div class="card-title">Candidate Details</div>
        <div id="detailsContent" class="empty-state">
          <svg fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          <p>Click a node to view details</p>
        </div>
      </div>
    </div>
  </div>

  <script>
    const IS_MODAL_HOST = window.location.hostname.endsWith(".modal.run");
    const EVOLUTION_BASE = IS_MODAL_HOST ? "/evolution" : "/.turbo_gepa/evolution";

    function _withCacheBuster(url) {
      const separator = url.includes("?") ? "&" : "?";
      return `${url}${separator}t=${Date.now()}`;
    }

    function fetchCurrentRun() {
      const base = IS_MODAL_HOST
        ? `${EVOLUTION_BASE}?run=current`
        : `${EVOLUTION_BASE}/current.json`;
      return fetch(_withCacheBuster(base));
    }

    function fetchRunData(runId) {
      const safeRun = encodeURIComponent(runId);
      const base = IS_MODAL_HOST
        ? `${EVOLUTION_BASE}?run=${safeRun}`
        : `${EVOLUTION_BASE}/${safeRun}.json`;
      return fetch(_withCacheBuster(base));
    }

    let cy = null;
    let nodeData = new Map();
    let refreshInterval = null;
    let nodePositions = new Map(); // Cache node positions
    let lastNodeCount = 0; // Track if graph structure changed

    // Quality chart state
    let qualityChart = null;
    let lastSeenEval = 0;
    let currentRunId = null;
    let graphRunId = null;

    // Island color bookkeeping
    let islandColorMap = new Map();
    let islandPaletteIndex = 0;
    const ISLAND_PALETTE = [
      "#3B82F6",
      "#F97316",
      "#F43F5E",
      "#22C55E",
      "#A855F7",
      "#0EA5E9",
      "#FACC15",
      "#FB7185",
      "#34D399",
      "#E879F9"
    ];

    function resetIslandColors() {
      islandColorMap = new Map();
      islandPaletteIndex = 0;
    }

    function getIslandColor(islandId) {
      const key = islandId ?? "unknown";
      if (!islandColorMap.has(key)) {
        const color = ISLAND_PALETTE[islandPaletteIndex % ISLAND_PALETTE.length];
        islandPaletteIndex += 1;
        islandColorMap.set(key, color);
      }
      return islandColorMap.get(key);
    }

    function formatIsland(islandId) {
      if (islandId === null || islandId === undefined) {
        return "Unknown";
      }
      return `Island ${islandId}`;
    }

    function updateIslandLegend(displayIslands) {
      const legendEl = document.getElementById('islandLegend');
      if (!legendEl) return;
      legendEl.innerHTML = '';
      if (!displayIslands || displayIslands.size === 0) {
        const empty = document.createElement('div');
        empty.className = 'detail-value';
        empty.style.color = '#6b7280';
        empty.textContent = 'No islands detected yet';
        legendEl.appendChild(empty);
        return;
      }
      displayIslands.forEach(islandId => {
        const row = document.createElement('div');
        row.className = 'legend-item';
        const color = getIslandColor(islandId);
        row.innerHTML = `
          <div class="legend-color" style="background: ${color};"></div>
          <span>${formatIsland(islandId)}</span>
        `;
        legendEl.appendChild(row);
      });
    }

    // Initialize Cytoscape
    function initCytoscape() {
      if (cy) return;

      cy = cytoscape({
        container: document.getElementById('cy'),
        style: [
          {
            selector: 'node',
            style: {
              'background-color': 'data(colorCurrent)',
              'label': 'data(label)',
              'color': '#ffffff',
              'text-valign': 'center',
              'text-halign': 'center',
              'font-size': '12px',
              'width': '60px',
              'height': '60px',
              'border-width': '3px',
              'border-color': 'data(colorOrigin)',
              'outline-width': 2,
              'outline-color': '#4b5563',
              'text-wrap': 'wrap',
              'text-max-width': '80px'
            }
          },
          {
            selector: 'node[status="promoted"]',
            style: {
              'outline-color': '#10b981'
            }
          },
          {
            selector: 'node[status="in_flight"]',
            style: {
              'outline-color': '#f59e0b'
            }
          },
          {
            selector: 'node.highlighted',
            style: {
              'border-width': '4px',
              'border-color': '#fbbf24',
              'z-index': 999
            }
          },
          {
            selector: 'node[migrated = "true"]',
            style: {
              'border-style': 'dashed'
            }
          },
          {
            selector: 'edge',
            style: {
              'width': 2,
              'line-color': '#4b5563',
              'target-arrow-color': '#4b5563',
              'target-arrow-shape': 'triangle',
              'curve-style': 'bezier',
              'arrow-scale': 1.5
            }
          },
          {
            selector: 'edge.cross-island',
            style: {
              'line-color': '#f472b6',
              'target-arrow-color': '#f472b6',
              'width': 3
            }
          }
        ],
        layout: {
          name: 'preset'
        },
        wheelSensitivity: 0.1,
        minZoom: 0.1,
        maxZoom: 3
      });

      // Click handler
      cy.on('tap', 'node', function(evt) {
        const node = evt.target;
        const nodeId = node.id();
        const data = nodeData.get(nodeId);

        // Highlight selected node
        cy.nodes().removeClass('highlighted');
        node.addClass('highlighted');

        showDetails(data);
      });

      // Register dagre layout
      if (typeof cytoscape !== 'undefined' && typeof cytoscapeDagre !== 'undefined') {
        cytoscape.use(cytoscapeDagre);
      }
    }

    // Initialize quality chart
    function initQualityChart() {
      if (qualityChart) return;

      const ctx = document.getElementById('qualityChart');
      if (!ctx) {
        console.log('[Chart] Canvas element not found');
        return;
      }

      console.log('[Chart] Initializing chart...');

      qualityChart = new Chart(ctx, {
        type: 'line',
        data: {
          datasets: [{
            label: 'Best Quality',
            data: [],
            borderColor: '#6B8AFF',
            backgroundColor: 'transparent',
            pointRadius: 4,
            pointHoverRadius: 6,
            borderWidth: 3,
            tension: 0.25
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            x: {
              type: 'linear',
              title: {
                display: true,
                text: 'Evaluations',
                color: '#8b95a8'
              },
              ticks: {
                autoSkip: true,
                color: '#8b95a8'
              },
              grid: {
                color: '#2a3040'
              }
            },
            y: {
              min: 0,
              max: 1.0,
              title: {
                display: true,
                text: 'Best Quality',
                color: '#8b95a8'
              },
              ticks: {
                stepSize: 0.1,
                color: '#8b95a8',
                callback: function(value) {
                  return (value * 100).toFixed(0) + '%';
                }
              },
              grid: {
                color: '#2a3040'
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return 'Quality: ' + context.parsed.y.toFixed(3);
                }
              }
            }
          }
        }
      });

      console.log('[Chart] Chart initialized successfully');
    }

    // Update quality chart with new data
    function updateQualityChart(data) {
      if (!data) {
        console.log('[Chart] No data provided');
        return;
      }

      initQualityChart();
      if (!qualityChart) {
        console.log('[Chart] Chart not initialized');
        return;
      }

      const runId = data.run_id;
      const timeline = data.timeline || [];

      console.log('[Chart] Update called:', {
        runId,
        timelineLength: timeline.length,
        currentRunId,
        lastSeenEval
      });

      // Reset if run changed
      if (currentRunId !== runId) {
        console.log('[Chart] New run detected, resetting');
        currentRunId = runId;
        lastSeenEval = 0;
        qualityChart.data.datasets[0].data = [];
      }

      // Append new points
      let pointsAdded = 0;
      timeline.forEach(snapshot => {
        const evals = snapshot.evaluations;
        const quality = snapshot.best_quality;

        console.log('[Chart] Snapshot:', { evals, quality, lastSeenEval, condition: typeof quality === 'number' && evals > lastSeenEval });

        if (typeof quality === 'number' && typeof evals === 'number' && evals > lastSeenEval) {
          qualityChart.data.datasets[0].data.push({
            x: evals,
            y: quality
          });
          lastSeenEval = Math.max(lastSeenEval, evals);
          pointsAdded++;
          console.log('[Chart] Added point:', { x: evals, y: quality });
        } else {
          console.log('[Chart] Skipped point - reason:', {
            qualityIsNumber: typeof quality === 'number',
            evalsIsNumber: typeof evals === 'number',
            evalsGreaterThanLast: evals > lastSeenEval
          });
        }
      });

      console.log('[Chart] Points added:', pointsAdded, 'Total points:', qualityChart.data.datasets[0].data.length);

      // Update debug display
      const debugEl = document.getElementById('chartDebug');
      if (debugEl) {
        debugEl.textContent = `(${qualityChart.data.datasets[0].data.length} points)`;
      }

      qualityChart.update('none');
    }

    // Show candidate details
    function showDetails(data) {
      if (!data) return;

      const originLabel = formatIsland(data.origin_island);
      const currentLabel = formatIsland(data.current_island ?? data.origin_island);
      const migratedLabel = data.origin_island != null && data.current_island != null && data.origin_island !== data.current_island
        ? `Yes (from ${formatIsland(data.origin_island)})`
        : "No";
      const content = `
        <div class="details">
          <div class="detail-row">
            <div class="detail-label">Fingerprint</div>
            <div class="detail-value">${data.fingerprint || 'N/A'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Generation</div>
            <div class="detail-value">${data.generation ?? 'N/A'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Quality</div>
            <div class="detail-value">${data.quality != null ? data.quality.toFixed(3) : 'N/A'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Shard Progress</div>
            <div class="detail-value">${data.shard_fraction != null ? (data.shard_fraction * 100).toFixed(0) + '%' : 'N/A'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Status</div>
            <div class="detail-value">${data.status || 'N/A'}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Origin Island</div>
            <div class="detail-value">${originLabel}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Current Island</div>
            <div class="detail-value">${currentLabel}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Migrated?</div>
            <div class="detail-value">${migratedLabel}</div>
          </div>
          <div class="detail-row">
            <div class="detail-label">Prompt</div>
            <div class="prompt-text">${data.prompt_full || data.prompt || '(empty)'}</div>
          </div>
        </div>
      `;

      document.getElementById('detailsContent').innerHTML = content;
    }

    // Update graph from data
    function updateGraph(data) {
      if (!data || !data.lineage || !data.evolution_stats) {
        console.warn('Invalid data structure', data);
        return;
      }

      initCytoscape();

      const runMeta = data.run_metadata || {};
      const runId = runMeta.run_id || data.run_id || null;
      if (runId && graphRunId !== runId) {
        graphRunId = runId;
        resetIslandColors();
      }

      const lineage = data.lineage;
      const parentChildren = data.evolution_stats.parent_children || {};

      nodeData.clear();

      const nodeMap = new Map();
      lineage.forEach(item => {
        if (item.fingerprint) {
          nodeMap.set(item.fingerprint, { ...item });
        }
      });

      const ensureNode = (fp) => {
        if (!fp) return null;
        if (!nodeMap.has(fp)) {
          nodeMap.set(fp, { fingerprint: fp, status: 'other' });
        }
        return nodeMap.get(fp);
      };

      Object.entries(parentChildren).forEach(([parent, children]) => {
        ensureNode(parent);
        children.forEach(child => ensureNode(child));
      });

      const nodes = [];
      const edges = [];
      const islandSet = new Set();

      nodeMap.forEach((item, fp) => {
        if (!fp) return;
        const originIsland = item.origin_island ?? null;
        const currentIsland = item.current_island ?? originIsland ?? null;
        const islandKey = currentIsland ?? originIsland ?? 'unknown';
        const quality = typeof item.quality === 'number' ? item.quality : null;
        const labelQuality = quality !== null ? quality.toFixed(2) : '—';
        const labelIsland =
          originIsland === null && currentIsland === null
            ? 'I?'
            : originIsland === currentIsland || originIsland === null
              ? `I${currentIsland ?? originIsland}`
              : `I${originIsland}→I${currentIsland}`;
        const label = `${fp.substring(0, 8)}\nq=${labelQuality}\n${labelIsland}`;
        if (islandKey !== 'unknown') {
          islandSet.add(islandKey);
        }
        const colorCurrent = getIslandColor(currentIsland ?? originIsland ?? 'unknown');
        const colorOrigin = getIslandColor(originIsland ?? currentIsland ?? 'unknown');
        const migrated = originIsland !== null && currentIsland !== null && originIsland !== currentIsland;
        const prompt = item.prompt || '';
        const promptFull = item.prompt_full || prompt;

        const details = {
          fingerprint: fp,
          generation: item.generation ?? null,
          quality: quality,
          shard_fraction: item.shard_fraction ?? null,
          status: item.status || 'other',
          prompt,
          prompt_full: promptFull,
          origin_island: originIsland,
          current_island: currentIsland,
          migrated_from_island: item.migrated_from_island ?? null
        };
        nodeData.set(fp, details);

        nodes.push({
          data: {
            id: fp,
            label,
            status: details.status,
            colorCurrent,
            colorOrigin,
            migrated: migrated ? 'true' : 'false'
          }
        });
      });

      updateIslandLegend(islandSet);

      Object.entries(parentChildren).forEach(([parent, children]) => {
        children.forEach(child => {
          if (!parent || !child) return;
          const parentInfo = nodeData.get(parent) || {};
          const childInfo = nodeData.get(child) || {};
          const parentIsland = parentInfo.origin_island ?? parentInfo.current_island ?? null;
          const childIsland = childInfo.origin_island ?? childInfo.current_island ?? null;
          const crossIsland = parentIsland !== null && childIsland !== null && parentIsland !== childIsland;
          edges.push({
            data: {
              id: `${parent}-${child}`,
              source: parent,
              target: child
            },
            classes: crossIsland ? 'cross-island' : ''
          });
        });
      });

      const existingNodeIds = new Set(cy.nodes().map(n => n.id()));
      const existingEdgeIds = new Set(cy.edges().map(e => e.id()));

      const newNodeIds = new Set(nodes.map(n => n.data.id));
      const newEdgeIds = new Set(edges.map(e => e.data.id));

      const nodesAdded = [...newNodeIds].some(id => !existingNodeIds.has(id));
      const edgesAdded = [...newEdgeIds].some(id => !existingEdgeIds.has(id));
      const structureChanged = nodesAdded || edgesAdded || existingNodeIds.size !== newNodeIds.size;

      if (structureChanged) {
        cy.elements().remove();
        cy.add([...nodes, ...edges]);

        const layout = cy.layout({
          name: 'dagre',
          rankDir: 'LR',
          nodeSep: 80,
          rankSep: 120,
          padding: 50,
          spacingFactor: 1.1
        });

        layout.run();

        setTimeout(() => {
          cy.nodes().forEach(node => {
            const pos = node.position();
            nodePositions.set(node.id(), { x: pos.x, y: pos.y });
          });
        }, 50);
      } else {
        nodes.forEach(nodeObj => {
          const nodeId = nodeObj.data.id;
          const cyNode = cy.getElementById(nodeId);

          if (cyNode && cyNode.length > 0) {
            cyNode.data('label', nodeObj.data.label);
            cyNode.data('status', nodeObj.data.status);
            cyNode.data('colorCurrent', nodeObj.data.colorCurrent);
            cyNode.data('colorOrigin', nodeObj.data.colorOrigin);
            cyNode.data('migrated', nodeObj.data.migrated);
          }
        });
      }

      lastNodeCount = nodes.length;

      document.getElementById('nodeCount').textContent = nodes.length;
      document.getElementById('edgeCount').textContent = edges.length;
      document.getElementById('evalCount').textContent = runMeta?.evaluations || 0;
      document.getElementById('bestQuality').textContent =
        runMeta?.best_quality != null
          ? runMeta.best_quality.toFixed(3)
          : '-';

      if (runMeta?.best_prompt) {
        const bestNode = lineage.find(item =>
          item.prompt === runMeta.best_prompt ||
          item.prompt_full === runMeta.best_prompt
        );

        if (bestNode && bestNode.fingerprint) {
          setTimeout(() => {
            const node = cy.getElementById(bestNode.fingerprint);
            if (node && node.length > 0) {
              cy.nodes().removeClass('highlighted');
              node.addClass('highlighted');
              cy.center(node);
              showDetails(nodeData.get(bestNode.fingerprint) || bestNode);
            }
          }, 100);
        }
      }
    }

    // Fetch current run data
    async function fetchData() {
      try {
        // First get current run ID
        const currentResp = await fetchCurrentRun();
        if (!currentResp.ok) throw new Error('Failed to fetch current.json');

        const current = await currentResp.json();
        const runId = current.run_id;

        if (!runId) {
          document.getElementById('statusText').textContent = 'Waiting for run to start...';
          return;
        }

        // Fetch run data
        const dataResp = await fetchRunData(runId);
        if (!dataResp.ok) throw new Error('Failed to fetch run data');

        const data = await dataResp.json();

        updateGraph(data);
        updateQualityChart(data);
        document.getElementById('statusText').textContent = `Live - Run ${runId}`;

      } catch (error) {
        console.error('Error fetching data:', error);
        document.getElementById('statusText').textContent = 'Error: ' + error.message;
      }
    }

    // Refresh data
    function refreshData() {
      fetchData();
    }

    // Fit graph to viewport
    function fitGraph() {
      if (cy) {
        cy.fit(undefined, 50);
      }
    }

    // Start auto-refresh
    function startAutoRefresh() {
      // Initial fetch
      fetchData();

      // Set up interval (every 2 seconds)
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
      refreshInterval = setInterval(fetchData, 2000);
    }

    // Initialize on load
    window.addEventListener('load', () => {
      initCytoscape();
      initQualityChart();
      startAutoRefresh();
    });

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    });
  </script>
</body>
</html>
